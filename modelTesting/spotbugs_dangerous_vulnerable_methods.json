[
    {
        "explanation": "com.opensymphony.xwork2.DefaultActionProxy.getConfig() may expose internal representation by returning DefaultActionProxy.config",
        "fileName": "com/opensymphony/xwork2/DefaultActionProxy.java",
        "methodStartLineNumber": 126,
        "methodEndLineNumber": 128,
        "warning_type": "EI_EXPOSE_REP",
        "codeSnippet": "    public ActionConfig getConfig() {\n        return config;\n",
        "classStartLineNumber": 41,
        "classEndLineNumber": 220,
        "classCode": "public class DefaultActionProxy implements ActionProxy, Serializable {\n\n    private static final long serialVersionUID = 3293074152487468527L;\n\n    private static final Logger LOG = LogManager.getLogger(DefaultActionProxy.class);\n\n    protected Configuration configuration;\n    protected ActionConfig config;\n    protected ActionInvocation invocation;\n    protected UnknownHandlerManager unknownHandlerManager;\n    protected LocalizedTextProvider localizedTextProvider;\n\n    protected String actionName;\n    protected String namespace;\n    protected String method;\n    protected boolean executeResult;\n    protected boolean cleanupContext;\n\n    protected ObjectFactory objectFactory;\n\n    protected ActionEventListener actionEventListener;\n\n    private boolean methodSpecified = true;\n\n    /**\n     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n     *\n     * <p>\n     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n     * </p>\n     *\n     * (like a RMIActionProxy).\n     *\n     * @param inv the action invocation\n     * @param namespace the namespace\n     * @param actionName the action name\n     * @param methodName the method name\n     * @param executeResult execute result\n     * @param cleanupContext cleanup context\n     */\n    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n\n        this.invocation = inv;\n        this.cleanupContext = cleanupContext;\n        LOG.debug(\"Creating an DefaultActionProxy for namespace [{}] and action name [{}]\", namespace, actionName);\n\n        this.actionName = StringEscapeUtils.escapeHtml4(actionName);\n        this.namespace = namespace;\n        this.executeResult = executeResult;\n        this.method = StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(methodName));\n    }\n\n    @Inject\n    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n\n    @Inject\n    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n\n    @Inject\n    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    @Inject(required = false)\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public Object getAction() {\n        return invocation.getAction();\n    }\n\n    public String getActionName() {\n        return actionName;\n    }\n\n    public ActionConfig getConfig() {\n        return config;\n    }\n\n    public void setExecuteResult(boolean executeResult) {\n        this.executeResult = executeResult;\n    }\n\n    public boolean getExecuteResult() {\n        return executeResult;\n    }\n\n    public ActionInvocation getInvocation() {\n        return invocation;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public String execute() throws Exception {\n        ActionContext nestedContext = ActionContext.getContext();\n        ActionContext.bind(invocation.getInvocationContext());\n\n        try {\n            return invocation.invoke();\n        } finally {\n            if (cleanupContext) {\n                ActionContext.bind(nestedContext);\n            }\n        }\n    }\n\n\n    public String getMethod() {\n        return method;\n    }\n\n    private void resolveMethod() {\n        // if the method is set to null, use the one from the configuration\n        // if the one from the configuration is also null, use \"execute\"\n        if (StringUtils.isEmpty(this.method)) {\n            this.method = config.getMethodName();\n            if (StringUtils.isEmpty(this.method)) {\n                this.method = ActionConfig.DEFAULT_METHOD;\n            }\n            methodSpecified = false;\n        }\n    }\n\n    protected void prepare() {\n        config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n\n        if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n            config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n        }\n        if (config == null) {\n            throw new ConfigurationException(getErrorMessage());\n        }\n\n        resolveMethod();\n\n        if (config.isAllowedMethod(method)) {\n            invocation.init(this);\n        } else {\n            throw new ConfigurationException(prepareNotAllowedErrorMessage());\n        }\n    }\n\n    protected String prepareNotAllowedErrorMessage() {\n        return localizedTextProvider.findDefaultText(\n                \"struts.exception.method-not-allowed\",\n                Locale.getDefault(),\n                new String[]{method, actionName}\n        );\n    }\n\n    protected String getErrorMessage() {\n        if ((namespace != null) && (namespace.trim().length() > 0)) {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-package-action\",\n                    Locale.getDefault(),\n                    new String[]{namespace, actionName});\n        } else {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-action\",\n                    Locale.getDefault(),\n                    new String[]{actionName});\n        }\n    }\n\n    public boolean isMethodSpecified() {\n        return methodSpecified;\n    }\n}\n",
        "compositeId": "com.opensymphony.xwork2.DefaultActionProxy.getConfig() may expose internal representation by returning DefaultActionProxy.config-com/opensymphony/xwork2/DefaultActionProxy.java",
        "classSize": 180
    },
    {
        "explanation": "com.opensymphony.xwork2.DefaultActionProxy.getInvocation() may expose internal representation by returning DefaultActionProxy.invocation",
        "fileName": "com/opensymphony/xwork2/DefaultActionProxy.java",
        "methodStartLineNumber": 138,
        "methodEndLineNumber": 140,
        "warning_type": "EI_EXPOSE_REP",
        "codeSnippet": "    public ActionInvocation getInvocation() {\n        return invocation;\n",
        "classStartLineNumber": 41,
        "classEndLineNumber": 220,
        "classCode": "public class DefaultActionProxy implements ActionProxy, Serializable {\n\n    private static final long serialVersionUID = 3293074152487468527L;\n\n    private static final Logger LOG = LogManager.getLogger(DefaultActionProxy.class);\n\n    protected Configuration configuration;\n    protected ActionConfig config;\n    protected ActionInvocation invocation;\n    protected UnknownHandlerManager unknownHandlerManager;\n    protected LocalizedTextProvider localizedTextProvider;\n\n    protected String actionName;\n    protected String namespace;\n    protected String method;\n    protected boolean executeResult;\n    protected boolean cleanupContext;\n\n    protected ObjectFactory objectFactory;\n\n    protected ActionEventListener actionEventListener;\n\n    private boolean methodSpecified = true;\n\n    /**\n     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n     *\n     * <p>\n     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n     * </p>\n     *\n     * (like a RMIActionProxy).\n     *\n     * @param inv the action invocation\n     * @param namespace the namespace\n     * @param actionName the action name\n     * @param methodName the method name\n     * @param executeResult execute result\n     * @param cleanupContext cleanup context\n     */\n    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n\n        this.invocation = inv;\n        this.cleanupContext = cleanupContext;\n        LOG.debug(\"Creating an DefaultActionProxy for namespace [{}] and action name [{}]\", namespace, actionName);\n\n        this.actionName = StringEscapeUtils.escapeHtml4(actionName);\n        this.namespace = namespace;\n        this.executeResult = executeResult;\n        this.method = StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(methodName));\n    }\n\n    @Inject\n    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n\n    @Inject\n    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n\n    @Inject\n    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    @Inject(required = false)\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public Object getAction() {\n        return invocation.getAction();\n    }\n\n    public String getActionName() {\n        return actionName;\n    }\n\n    public ActionConfig getConfig() {\n        return config;\n    }\n\n    public void setExecuteResult(boolean executeResult) {\n        this.executeResult = executeResult;\n    }\n\n    public boolean getExecuteResult() {\n        return executeResult;\n    }\n\n    public ActionInvocation getInvocation() {\n        return invocation;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public String execute() throws Exception {\n        ActionContext nestedContext = ActionContext.getContext();\n        ActionContext.bind(invocation.getInvocationContext());\n\n        try {\n            return invocation.invoke();\n        } finally {\n            if (cleanupContext) {\n                ActionContext.bind(nestedContext);\n            }\n        }\n    }\n\n\n    public String getMethod() {\n        return method;\n    }\n\n    private void resolveMethod() {\n        // if the method is set to null, use the one from the configuration\n        // if the one from the configuration is also null, use \"execute\"\n        if (StringUtils.isEmpty(this.method)) {\n            this.method = config.getMethodName();\n            if (StringUtils.isEmpty(this.method)) {\n                this.method = ActionConfig.DEFAULT_METHOD;\n            }\n            methodSpecified = false;\n        }\n    }\n\n    protected void prepare() {\n        config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n\n        if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n            config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n        }\n        if (config == null) {\n            throw new ConfigurationException(getErrorMessage());\n        }\n\n        resolveMethod();\n\n        if (config.isAllowedMethod(method)) {\n            invocation.init(this);\n        } else {\n            throw new ConfigurationException(prepareNotAllowedErrorMessage());\n        }\n    }\n\n    protected String prepareNotAllowedErrorMessage() {\n        return localizedTextProvider.findDefaultText(\n                \"struts.exception.method-not-allowed\",\n                Locale.getDefault(),\n                new String[]{method, actionName}\n        );\n    }\n\n    protected String getErrorMessage() {\n        if ((namespace != null) && (namespace.trim().length() > 0)) {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-package-action\",\n                    Locale.getDefault(),\n                    new String[]{namespace, actionName});\n        } else {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-action\",\n                    Locale.getDefault(),\n                    new String[]{actionName});\n        }\n    }\n\n    public boolean isMethodSpecified() {\n        return methodSpecified;\n    }\n}\n",
        "compositeId": "com.opensymphony.xwork2.DefaultActionProxy.getInvocation() may expose internal representation by returning DefaultActionProxy.invocation-com/opensymphony/xwork2/DefaultActionProxy.java",
        "classSize": 180
    },
    {
        "explanation": "com.opensymphony.xwork2.DefaultActionProxy.setConfiguration(Configuration) may expose internal representation by storing an externally mutable object into DefaultActionProxy.configuration",
        "fileName": "com/opensymphony/xwork2/DefaultActionProxy.java",
        "methodStartLineNumber": 99,
        "methodEndLineNumber": 102,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n",
        "classStartLineNumber": 41,
        "classEndLineNumber": 220,
        "classCode": "public class DefaultActionProxy implements ActionProxy, Serializable {\n\n    private static final long serialVersionUID = 3293074152487468527L;\n\n    private static final Logger LOG = LogManager.getLogger(DefaultActionProxy.class);\n\n    protected Configuration configuration;\n    protected ActionConfig config;\n    protected ActionInvocation invocation;\n    protected UnknownHandlerManager unknownHandlerManager;\n    protected LocalizedTextProvider localizedTextProvider;\n\n    protected String actionName;\n    protected String namespace;\n    protected String method;\n    protected boolean executeResult;\n    protected boolean cleanupContext;\n\n    protected ObjectFactory objectFactory;\n\n    protected ActionEventListener actionEventListener;\n\n    private boolean methodSpecified = true;\n\n    /**\n     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n     *\n     * <p>\n     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n     * </p>\n     *\n     * (like a RMIActionProxy).\n     *\n     * @param inv the action invocation\n     * @param namespace the namespace\n     * @param actionName the action name\n     * @param methodName the method name\n     * @param executeResult execute result\n     * @param cleanupContext cleanup context\n     */\n    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n\n        this.invocation = inv;\n        this.cleanupContext = cleanupContext;\n        LOG.debug(\"Creating an DefaultActionProxy for namespace [{}] and action name [{}]\", namespace, actionName);\n\n        this.actionName = StringEscapeUtils.escapeHtml4(actionName);\n        this.namespace = namespace;\n        this.executeResult = executeResult;\n        this.method = StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(methodName));\n    }\n\n    @Inject\n    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n\n    @Inject\n    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n\n    @Inject\n    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    @Inject(required = false)\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public Object getAction() {\n        return invocation.getAction();\n    }\n\n    public String getActionName() {\n        return actionName;\n    }\n\n    public ActionConfig getConfig() {\n        return config;\n    }\n\n    public void setExecuteResult(boolean executeResult) {\n        this.executeResult = executeResult;\n    }\n\n    public boolean getExecuteResult() {\n        return executeResult;\n    }\n\n    public ActionInvocation getInvocation() {\n        return invocation;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public String execute() throws Exception {\n        ActionContext nestedContext = ActionContext.getContext();\n        ActionContext.bind(invocation.getInvocationContext());\n\n        try {\n            return invocation.invoke();\n        } finally {\n            if (cleanupContext) {\n                ActionContext.bind(nestedContext);\n            }\n        }\n    }\n\n\n    public String getMethod() {\n        return method;\n    }\n\n    private void resolveMethod() {\n        // if the method is set to null, use the one from the configuration\n        // if the one from the configuration is also null, use \"execute\"\n        if (StringUtils.isEmpty(this.method)) {\n            this.method = config.getMethodName();\n            if (StringUtils.isEmpty(this.method)) {\n                this.method = ActionConfig.DEFAULT_METHOD;\n            }\n            methodSpecified = false;\n        }\n    }\n\n    protected void prepare() {\n        config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n\n        if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n            config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n        }\n        if (config == null) {\n            throw new ConfigurationException(getErrorMessage());\n        }\n\n        resolveMethod();\n\n        if (config.isAllowedMethod(method)) {\n            invocation.init(this);\n        } else {\n            throw new ConfigurationException(prepareNotAllowedErrorMessage());\n        }\n    }\n\n    protected String prepareNotAllowedErrorMessage() {\n        return localizedTextProvider.findDefaultText(\n                \"struts.exception.method-not-allowed\",\n                Locale.getDefault(),\n                new String[]{method, actionName}\n        );\n    }\n\n    protected String getErrorMessage() {\n        if ((namespace != null) && (namespace.trim().length() > 0)) {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-package-action\",\n                    Locale.getDefault(),\n                    new String[]{namespace, actionName});\n        } else {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-action\",\n                    Locale.getDefault(),\n                    new String[]{actionName});\n        }\n    }\n\n    public boolean isMethodSpecified() {\n        return methodSpecified;\n    }\n}\n",
        "compositeId": "com.opensymphony.xwork2.DefaultActionProxy.setConfiguration(Configuration) may expose internal representation by storing an externally mutable object into DefaultActionProxy.configuration-com/opensymphony/xwork2/DefaultActionProxy.java",
        "classSize": 180
    },
    {
        "explanation": "com.opensymphony.xwork2.DefaultActionProxy.setLocalizedTextProvider(LocalizedTextProvider) may expose internal representation by storing an externally mutable object into DefaultActionProxy.localizedTextProvider",
        "fileName": "com/opensymphony/xwork2/DefaultActionProxy.java",
        "methodStartLineNumber": 114,
        "methodEndLineNumber": 117,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n",
        "classStartLineNumber": 41,
        "classEndLineNumber": 220,
        "classCode": "public class DefaultActionProxy implements ActionProxy, Serializable {\n\n    private static final long serialVersionUID = 3293074152487468527L;\n\n    private static final Logger LOG = LogManager.getLogger(DefaultActionProxy.class);\n\n    protected Configuration configuration;\n    protected ActionConfig config;\n    protected ActionInvocation invocation;\n    protected UnknownHandlerManager unknownHandlerManager;\n    protected LocalizedTextProvider localizedTextProvider;\n\n    protected String actionName;\n    protected String namespace;\n    protected String method;\n    protected boolean executeResult;\n    protected boolean cleanupContext;\n\n    protected ObjectFactory objectFactory;\n\n    protected ActionEventListener actionEventListener;\n\n    private boolean methodSpecified = true;\n\n    /**\n     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n     *\n     * <p>\n     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n     * </p>\n     *\n     * (like a RMIActionProxy).\n     *\n     * @param inv the action invocation\n     * @param namespace the namespace\n     * @param actionName the action name\n     * @param methodName the method name\n     * @param executeResult execute result\n     * @param cleanupContext cleanup context\n     */\n    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n\n        this.invocation = inv;\n        this.cleanupContext = cleanupContext;\n        LOG.debug(\"Creating an DefaultActionProxy for namespace [{}] and action name [{}]\", namespace, actionName);\n\n        this.actionName = StringEscapeUtils.escapeHtml4(actionName);\n        this.namespace = namespace;\n        this.executeResult = executeResult;\n        this.method = StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(methodName));\n    }\n\n    @Inject\n    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n\n    @Inject\n    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n\n    @Inject\n    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    @Inject(required = false)\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public Object getAction() {\n        return invocation.getAction();\n    }\n\n    public String getActionName() {\n        return actionName;\n    }\n\n    public ActionConfig getConfig() {\n        return config;\n    }\n\n    public void setExecuteResult(boolean executeResult) {\n        this.executeResult = executeResult;\n    }\n\n    public boolean getExecuteResult() {\n        return executeResult;\n    }\n\n    public ActionInvocation getInvocation() {\n        return invocation;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public String execute() throws Exception {\n        ActionContext nestedContext = ActionContext.getContext();\n        ActionContext.bind(invocation.getInvocationContext());\n\n        try {\n            return invocation.invoke();\n        } finally {\n            if (cleanupContext) {\n                ActionContext.bind(nestedContext);\n            }\n        }\n    }\n\n\n    public String getMethod() {\n        return method;\n    }\n\n    private void resolveMethod() {\n        // if the method is set to null, use the one from the configuration\n        // if the one from the configuration is also null, use \"execute\"\n        if (StringUtils.isEmpty(this.method)) {\n            this.method = config.getMethodName();\n            if (StringUtils.isEmpty(this.method)) {\n                this.method = ActionConfig.DEFAULT_METHOD;\n            }\n            methodSpecified = false;\n        }\n    }\n\n    protected void prepare() {\n        config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n\n        if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n            config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n        }\n        if (config == null) {\n            throw new ConfigurationException(getErrorMessage());\n        }\n\n        resolveMethod();\n\n        if (config.isAllowedMethod(method)) {\n            invocation.init(this);\n        } else {\n            throw new ConfigurationException(prepareNotAllowedErrorMessage());\n        }\n    }\n\n    protected String prepareNotAllowedErrorMessage() {\n        return localizedTextProvider.findDefaultText(\n                \"struts.exception.method-not-allowed\",\n                Locale.getDefault(),\n                new String[]{method, actionName}\n        );\n    }\n\n    protected String getErrorMessage() {\n        if ((namespace != null) && (namespace.trim().length() > 0)) {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-package-action\",\n                    Locale.getDefault(),\n                    new String[]{namespace, actionName});\n        } else {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-action\",\n                    Locale.getDefault(),\n                    new String[]{actionName});\n        }\n    }\n\n    public boolean isMethodSpecified() {\n        return methodSpecified;\n    }\n}\n",
        "compositeId": "com.opensymphony.xwork2.DefaultActionProxy.setLocalizedTextProvider(LocalizedTextProvider) may expose internal representation by storing an externally mutable object into DefaultActionProxy.localizedTextProvider-com/opensymphony/xwork2/DefaultActionProxy.java",
        "classSize": 180
    },
    {
        "explanation": "com.opensymphony.xwork2.DefaultActionProxy.setObjectFactory(ObjectFactory) may expose internal representation by storing an externally mutable object into DefaultActionProxy.objectFactory",
        "fileName": "com/opensymphony/xwork2/DefaultActionProxy.java",
        "methodStartLineNumber": 94,
        "methodEndLineNumber": 97,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n",
        "classStartLineNumber": 41,
        "classEndLineNumber": 220,
        "classCode": "public class DefaultActionProxy implements ActionProxy, Serializable {\n\n    private static final long serialVersionUID = 3293074152487468527L;\n\n    private static final Logger LOG = LogManager.getLogger(DefaultActionProxy.class);\n\n    protected Configuration configuration;\n    protected ActionConfig config;\n    protected ActionInvocation invocation;\n    protected UnknownHandlerManager unknownHandlerManager;\n    protected LocalizedTextProvider localizedTextProvider;\n\n    protected String actionName;\n    protected String namespace;\n    protected String method;\n    protected boolean executeResult;\n    protected boolean cleanupContext;\n\n    protected ObjectFactory objectFactory;\n\n    protected ActionEventListener actionEventListener;\n\n    private boolean methodSpecified = true;\n\n    /**\n     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n     *\n     * <p>\n     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n     * </p>\n     *\n     * (like a RMIActionProxy).\n     *\n     * @param inv the action invocation\n     * @param namespace the namespace\n     * @param actionName the action name\n     * @param methodName the method name\n     * @param executeResult execute result\n     * @param cleanupContext cleanup context\n     */\n    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n\n        this.invocation = inv;\n        this.cleanupContext = cleanupContext;\n        LOG.debug(\"Creating an DefaultActionProxy for namespace [{}] and action name [{}]\", namespace, actionName);\n\n        this.actionName = StringEscapeUtils.escapeHtml4(actionName);\n        this.namespace = namespace;\n        this.executeResult = executeResult;\n        this.method = StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(methodName));\n    }\n\n    @Inject\n    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n\n    @Inject\n    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n\n    @Inject\n    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    @Inject(required = false)\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public Object getAction() {\n        return invocation.getAction();\n    }\n\n    public String getActionName() {\n        return actionName;\n    }\n\n    public ActionConfig getConfig() {\n        return config;\n    }\n\n    public void setExecuteResult(boolean executeResult) {\n        this.executeResult = executeResult;\n    }\n\n    public boolean getExecuteResult() {\n        return executeResult;\n    }\n\n    public ActionInvocation getInvocation() {\n        return invocation;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public String execute() throws Exception {\n        ActionContext nestedContext = ActionContext.getContext();\n        ActionContext.bind(invocation.getInvocationContext());\n\n        try {\n            return invocation.invoke();\n        } finally {\n            if (cleanupContext) {\n                ActionContext.bind(nestedContext);\n            }\n        }\n    }\n\n\n    public String getMethod() {\n        return method;\n    }\n\n    private void resolveMethod() {\n        // if the method is set to null, use the one from the configuration\n        // if the one from the configuration is also null, use \"execute\"\n        if (StringUtils.isEmpty(this.method)) {\n            this.method = config.getMethodName();\n            if (StringUtils.isEmpty(this.method)) {\n                this.method = ActionConfig.DEFAULT_METHOD;\n            }\n            methodSpecified = false;\n        }\n    }\n\n    protected void prepare() {\n        config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n\n        if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n            config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n        }\n        if (config == null) {\n            throw new ConfigurationException(getErrorMessage());\n        }\n\n        resolveMethod();\n\n        if (config.isAllowedMethod(method)) {\n            invocation.init(this);\n        } else {\n            throw new ConfigurationException(prepareNotAllowedErrorMessage());\n        }\n    }\n\n    protected String prepareNotAllowedErrorMessage() {\n        return localizedTextProvider.findDefaultText(\n                \"struts.exception.method-not-allowed\",\n                Locale.getDefault(),\n                new String[]{method, actionName}\n        );\n    }\n\n    protected String getErrorMessage() {\n        if ((namespace != null) && (namespace.trim().length() > 0)) {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-package-action\",\n                    Locale.getDefault(),\n                    new String[]{namespace, actionName});\n        } else {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-action\",\n                    Locale.getDefault(),\n                    new String[]{actionName});\n        }\n    }\n\n    public boolean isMethodSpecified() {\n        return methodSpecified;\n    }\n}\n",
        "compositeId": "com.opensymphony.xwork2.DefaultActionProxy.setObjectFactory(ObjectFactory) may expose internal representation by storing an externally mutable object into DefaultActionProxy.objectFactory-com/opensymphony/xwork2/DefaultActionProxy.java",
        "classSize": 180
    },
    {
        "explanation": "Class com.opensymphony.xwork2.DefaultActionProxy defines non-transient non-serializable instance field actionEventListener",
        "fileName": "com/opensymphony/xwork2/DefaultActionProxy.java",
        "methodStartLineNumber": 44,
        "methodEndLineNumber": 219,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "\n    private static final Logger LOG = LogManager.getLogger(DefaultActionProxy.class);\n\n    protected Configuration configuration;\n    protected ActionConfig config;\n    protected ActionInvocation invocation;\n    protected UnknownHandlerManager unknownHandlerManager;\n    protected LocalizedTextProvider localizedTextProvider;\n\n    protected String actionName;\n    protected String namespace;\n    protected String method;\n    protected boolean executeResult;\n    protected boolean cleanupContext;\n\n    protected ObjectFactory objectFactory;\n\n    protected ActionEventListener actionEventListener;\n\n    private boolean methodSpecified = true;\n\n    /**\n     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n     *\n     * <p>\n     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n     * </p>\n     *\n     * (like a RMIActionProxy).\n     *\n     * @param inv the action invocation\n     * @param namespace the namespace\n     * @param actionName the action name\n     * @param methodName the method name\n     * @param executeResult execute result\n     * @param cleanupContext cleanup context\n     */\n    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n\n        this.invocation = inv;\n        this.cleanupContext = cleanupContext;\n        LOG.debug(\"Creating an DefaultActionProxy for namespace [{}] and action name [{}]\", namespace, actionName);\n\n        this.actionName = StringEscapeUtils.escapeHtml4(actionName);\n        this.namespace = namespace;\n        this.executeResult = executeResult;\n        this.method = StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(methodName));\n    }\n\n    @Inject\n    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n\n    @Inject\n    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n\n    @Inject\n    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    @Inject(required = false)\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public Object getAction() {\n        return invocation.getAction();\n    }\n\n    public String getActionName() {\n        return actionName;\n    }\n\n    public ActionConfig getConfig() {\n        return config;\n    }\n\n    public void setExecuteResult(boolean executeResult) {\n        this.executeResult = executeResult;\n    }\n\n    public boolean getExecuteResult() {\n        return executeResult;\n    }\n\n    public ActionInvocation getInvocation() {\n        return invocation;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public String execute() throws Exception {\n        ActionContext nestedContext = ActionContext.getContext();\n        ActionContext.bind(invocation.getInvocationContext());\n\n        try {\n            return invocation.invoke();\n        } finally {\n            if (cleanupContext) {\n                ActionContext.bind(nestedContext);\n            }\n        }\n    }\n\n\n    public String getMethod() {\n        return method;\n    }\n\n    private void resolveMethod() {\n        // if the method is set to null, use the one from the configuration\n        // if the one from the configuration is also null, use \"execute\"\n        if (StringUtils.isEmpty(this.method)) {\n            this.method = config.getMethodName();\n            if (StringUtils.isEmpty(this.method)) {\n                this.method = ActionConfig.DEFAULT_METHOD;\n            }\n            methodSpecified = false;\n        }\n    }\n\n    protected void prepare() {\n        config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n\n        if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n            config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n        }\n        if (config == null) {\n            throw new ConfigurationException(getErrorMessage());\n        }\n\n        resolveMethod();\n\n        if (config.isAllowedMethod(method)) {\n            invocation.init(this);\n        } else {\n            throw new ConfigurationException(prepareNotAllowedErrorMessage());\n        }\n    }\n\n    protected String prepareNotAllowedErrorMessage() {\n        return localizedTextProvider.findDefaultText(\n                \"struts.exception.method-not-allowed\",\n                Locale.getDefault(),\n                new String[]{method, actionName}\n        );\n    }\n\n    protected String getErrorMessage() {\n        if ((namespace != null) && (namespace.trim().length() > 0)) {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-package-action\",\n                    Locale.getDefault(),\n                    new String[]{namespace, actionName});\n        } else {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-action\",\n                    Locale.getDefault(),\n                    new String[]{actionName});\n        }\n    }\n\n    public boolean isMethodSpecified() {\n        return methodSpecified;\n",
        "classStartLineNumber": 41,
        "classEndLineNumber": 220,
        "classCode": "public class DefaultActionProxy implements ActionProxy, Serializable {\n\n    private static final long serialVersionUID = 3293074152487468527L;\n\n    private static final Logger LOG = LogManager.getLogger(DefaultActionProxy.class);\n\n    protected Configuration configuration;\n    protected ActionConfig config;\n    protected ActionInvocation invocation;\n    protected UnknownHandlerManager unknownHandlerManager;\n    protected LocalizedTextProvider localizedTextProvider;\n\n    protected String actionName;\n    protected String namespace;\n    protected String method;\n    protected boolean executeResult;\n    protected boolean cleanupContext;\n\n    protected ObjectFactory objectFactory;\n\n    protected ActionEventListener actionEventListener;\n\n    private boolean methodSpecified = true;\n\n    /**\n     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n     *\n     * <p>\n     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n     * </p>\n     *\n     * (like a RMIActionProxy).\n     *\n     * @param inv the action invocation\n     * @param namespace the namespace\n     * @param actionName the action name\n     * @param methodName the method name\n     * @param executeResult execute result\n     * @param cleanupContext cleanup context\n     */\n    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n\n        this.invocation = inv;\n        this.cleanupContext = cleanupContext;\n        LOG.debug(\"Creating an DefaultActionProxy for namespace [{}] and action name [{}]\", namespace, actionName);\n\n        this.actionName = StringEscapeUtils.escapeHtml4(actionName);\n        this.namespace = namespace;\n        this.executeResult = executeResult;\n        this.method = StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(methodName));\n    }\n\n    @Inject\n    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n\n    @Inject\n    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n\n    @Inject\n    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    @Inject(required = false)\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public Object getAction() {\n        return invocation.getAction();\n    }\n\n    public String getActionName() {\n        return actionName;\n    }\n\n    public ActionConfig getConfig() {\n        return config;\n    }\n\n    public void setExecuteResult(boolean executeResult) {\n        this.executeResult = executeResult;\n    }\n\n    public boolean getExecuteResult() {\n        return executeResult;\n    }\n\n    public ActionInvocation getInvocation() {\n        return invocation;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public String execute() throws Exception {\n        ActionContext nestedContext = ActionContext.getContext();\n        ActionContext.bind(invocation.getInvocationContext());\n\n        try {\n            return invocation.invoke();\n        } finally {\n            if (cleanupContext) {\n                ActionContext.bind(nestedContext);\n            }\n        }\n    }\n\n\n    public String getMethod() {\n        return method;\n    }\n\n    private void resolveMethod() {\n        // if the method is set to null, use the one from the configuration\n        // if the one from the configuration is also null, use \"execute\"\n        if (StringUtils.isEmpty(this.method)) {\n            this.method = config.getMethodName();\n            if (StringUtils.isEmpty(this.method)) {\n                this.method = ActionConfig.DEFAULT_METHOD;\n            }\n            methodSpecified = false;\n        }\n    }\n\n    protected void prepare() {\n        config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n\n        if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n            config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n        }\n        if (config == null) {\n            throw new ConfigurationException(getErrorMessage());\n        }\n\n        resolveMethod();\n\n        if (config.isAllowedMethod(method)) {\n            invocation.init(this);\n        } else {\n            throw new ConfigurationException(prepareNotAllowedErrorMessage());\n        }\n    }\n\n    protected String prepareNotAllowedErrorMessage() {\n        return localizedTextProvider.findDefaultText(\n                \"struts.exception.method-not-allowed\",\n                Locale.getDefault(),\n                new String[]{method, actionName}\n        );\n    }\n\n    protected String getErrorMessage() {\n        if ((namespace != null) && (namespace.trim().length() > 0)) {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-package-action\",\n                    Locale.getDefault(),\n                    new String[]{namespace, actionName});\n        } else {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-action\",\n                    Locale.getDefault(),\n                    new String[]{actionName});\n        }\n    }\n\n    public boolean isMethodSpecified() {\n        return methodSpecified;\n    }\n}\n",
        "compositeId": "Class com.opensymphony.xwork2.DefaultActionProxy defines non-transient non-serializable instance field actionEventListener-com/opensymphony/xwork2/DefaultActionProxy.java",
        "classSize": 180,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.inject.Inject;\nimport org.apache.commons.text.StringEscapeUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport java.io.Serializable;\nimport java.util.Locale;\n\n/**\n * The Default ActionProxy implementation\n *\n * @author Rainer Hermanns\n * @author Revised by <a href=\"mailto:hu_pengfei@yahoo.com.cn\">Henry Hu</a>\n * @author tmjee\n * @since 2005-8-6\n */\npublic class DefaultActionProxy implements ActionProxy, Serializable {\n\n    private static final long serialVersionUID = 3293074152487468527L;\n\n    private static final Logger LOG = LogManager.getLogger(DefaultActionProxy.class);\n\n    protected Configuration configuration;\n    protected ActionConfig config;\n    protected ActionInvocation invocation;\n    protected UnknownHandlerManager unknownHandlerManager;\n    protected LocalizedTextProvider localizedTextProvider;\n\n    protected String actionName;\n    protected String namespace;\n    protected String method;\n    protected boolean executeResult;\n    protected boolean cleanupContext;\n\n    protected ObjectFactory objectFactory;\n\n    private transient ActionEventListener actionEventListener;\n\n    private boolean methodSpecified = true;\n\n    /**\n     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n     *\n     * <p>\n     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n     * </p>\n     *\n     * (like a RMIActionProxy).\n     *\n     * @param inv the action invocation\n     * @param namespace the namespace\n     * @param actionName the action name\n     * @param methodName the method name\n     * @param executeResult execute result\n     * @param cleanupContext cleanup context\n     */\n    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n\n        this.invocation = inv;\n        this.cleanupContext = cleanupContext;\n        LOG.debug(\"Creating an DefaultActionProxy for namespace [{}] and action name [{}]\", namespace, actionName);\n\n        this.actionName = StringEscapeUtils.escapeHtml4(actionName);\n        this.namespace = namespace;\n        this.executeResult = executeResult;\n        this.method = StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(methodName));\n    }\n\n    @Inject\n    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n\n    @Inject\n    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n\n    @Inject\n    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    @Inject(required = false)\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public Object getAction() {\n        return invocation.getAction();\n    }\n\n    public String getActionName() {\n        return actionName;\n    }\n\n    public ActionConfig getConfig() {\n        return config;\n    }\n\n    public void setExecuteResult(boolean executeResult) {\n        this.executeResult = executeResult;\n    }\n\n    public boolean getExecuteResult() {\n        return executeResult;\n    }\n\n    public ActionInvocation getInvocation() {\n        return invocation;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public String execute() throws Exception {\n        ActionContext nestedContext = ActionContext.getContext();\n        ActionContext.bind(invocation.getInvocationContext());\n\n        try {\n            return invocation.invoke();\n        } finally {\n            if (cleanupContext) {\n                ActionContext.bind(nestedContext);\n            }\n        }\n    }\n\n    public String getMethod() {\n        return method;\n    }\n\n    private void resolveMethod() {\n        // if the method is set to null, use the one from the configuration\n        // if the one from the configuration is also null, use \"execute\"\n        if (StringUtils.isEmpty(this.method)) {\n            this.method = config.getMethodName();\n            if (StringUtils.isEmpty(this.method)) {\n                this.method = ActionConfig.DEFAULT_METHOD;\n            }\n            methodSpecified = false;\n        }\n    }\n\n    protected void prepare() {\n        config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n\n        if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n            config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n        }\n        if (config == null) {\n            throw new ConfigurationException(getErrorMessage());\n        }\n\n        resolveMethod();\n\n        if (config.isAllowedMethod(method)) {\n            invocation.init(this);\n        } else {\n            throw new ConfigurationException(prepareNotAllowedErrorMessage());\n        }\n    }\n\n    protected String prepareNotAllowedErrorMessage() {\n        return localizedTextProvider.findDefaultText(\n                \"struts.exception.method-not-allowed\",\n                Locale.getDefault(),\n                new String[]{method, actionName}\n        );\n    }\n\n    protected String getErrorMessage() {\n        if ((namespace != null) && (namespace.trim().length() > 0)) {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-package-action\",\n                    Locale.getDefault(),\n                    new String[]{namespace, actionName});\n        } else {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-action\",\n                    Locale.getDefault(),\n                    new String[]{actionName});\n        }\n    }\n\n    public boolean isMethodSpecified() {\n        return methodSpecified;\n    }\n}\n"
    },
    {
        "explanation": "Class com.opensymphony.xwork2.DefaultActionProxy defines non-transient non-serializable instance field invocation",
        "fileName": "com/opensymphony/xwork2/DefaultActionProxy.java",
        "methodStartLineNumber": 44,
        "methodEndLineNumber": 219,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "\n    private static final Logger LOG = LogManager.getLogger(DefaultActionProxy.class);\n\n    protected Configuration configuration;\n    protected ActionConfig config;\n    protected ActionInvocation invocation;\n    protected UnknownHandlerManager unknownHandlerManager;\n    protected LocalizedTextProvider localizedTextProvider;\n\n    protected String actionName;\n    protected String namespace;\n    protected String method;\n    protected boolean executeResult;\n    protected boolean cleanupContext;\n\n    protected ObjectFactory objectFactory;\n\n    protected ActionEventListener actionEventListener;\n\n    private boolean methodSpecified = true;\n\n    /**\n     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n     *\n     * <p>\n     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n     * </p>\n     *\n     * (like a RMIActionProxy).\n     *\n     * @param inv the action invocation\n     * @param namespace the namespace\n     * @param actionName the action name\n     * @param methodName the method name\n     * @param executeResult execute result\n     * @param cleanupContext cleanup context\n     */\n    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n\n        this.invocation = inv;\n        this.cleanupContext = cleanupContext;\n        LOG.debug(\"Creating an DefaultActionProxy for namespace [{}] and action name [{}]\", namespace, actionName);\n\n        this.actionName = StringEscapeUtils.escapeHtml4(actionName);\n        this.namespace = namespace;\n        this.executeResult = executeResult;\n        this.method = StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(methodName));\n    }\n\n    @Inject\n    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n\n    @Inject\n    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n\n    @Inject\n    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    @Inject(required = false)\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public Object getAction() {\n        return invocation.getAction();\n    }\n\n    public String getActionName() {\n        return actionName;\n    }\n\n    public ActionConfig getConfig() {\n        return config;\n    }\n\n    public void setExecuteResult(boolean executeResult) {\n        this.executeResult = executeResult;\n    }\n\n    public boolean getExecuteResult() {\n        return executeResult;\n    }\n\n    public ActionInvocation getInvocation() {\n        return invocation;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public String execute() throws Exception {\n        ActionContext nestedContext = ActionContext.getContext();\n        ActionContext.bind(invocation.getInvocationContext());\n\n        try {\n            return invocation.invoke();\n        } finally {\n            if (cleanupContext) {\n                ActionContext.bind(nestedContext);\n            }\n        }\n    }\n\n\n    public String getMethod() {\n        return method;\n    }\n\n    private void resolveMethod() {\n        // if the method is set to null, use the one from the configuration\n        // if the one from the configuration is also null, use \"execute\"\n        if (StringUtils.isEmpty(this.method)) {\n            this.method = config.getMethodName();\n            if (StringUtils.isEmpty(this.method)) {\n                this.method = ActionConfig.DEFAULT_METHOD;\n            }\n            methodSpecified = false;\n        }\n    }\n\n    protected void prepare() {\n        config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n\n        if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n            config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n        }\n        if (config == null) {\n            throw new ConfigurationException(getErrorMessage());\n        }\n\n        resolveMethod();\n\n        if (config.isAllowedMethod(method)) {\n            invocation.init(this);\n        } else {\n            throw new ConfigurationException(prepareNotAllowedErrorMessage());\n        }\n    }\n\n    protected String prepareNotAllowedErrorMessage() {\n        return localizedTextProvider.findDefaultText(\n                \"struts.exception.method-not-allowed\",\n                Locale.getDefault(),\n                new String[]{method, actionName}\n        );\n    }\n\n    protected String getErrorMessage() {\n        if ((namespace != null) && (namespace.trim().length() > 0)) {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-package-action\",\n                    Locale.getDefault(),\n                    new String[]{namespace, actionName});\n        } else {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-action\",\n                    Locale.getDefault(),\n                    new String[]{actionName});\n        }\n    }\n\n    public boolean isMethodSpecified() {\n        return methodSpecified;\n",
        "classStartLineNumber": 41,
        "classEndLineNumber": 220,
        "classCode": "public class DefaultActionProxy implements ActionProxy, Serializable {\n\n    private static final long serialVersionUID = 3293074152487468527L;\n\n    private static final Logger LOG = LogManager.getLogger(DefaultActionProxy.class);\n\n    protected Configuration configuration;\n    protected ActionConfig config;\n    protected ActionInvocation invocation;\n    protected UnknownHandlerManager unknownHandlerManager;\n    protected LocalizedTextProvider localizedTextProvider;\n\n    protected String actionName;\n    protected String namespace;\n    protected String method;\n    protected boolean executeResult;\n    protected boolean cleanupContext;\n\n    protected ObjectFactory objectFactory;\n\n    protected ActionEventListener actionEventListener;\n\n    private boolean methodSpecified = true;\n\n    /**\n     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n     *\n     * <p>\n     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n     * </p>\n     *\n     * (like a RMIActionProxy).\n     *\n     * @param inv the action invocation\n     * @param namespace the namespace\n     * @param actionName the action name\n     * @param methodName the method name\n     * @param executeResult execute result\n     * @param cleanupContext cleanup context\n     */\n    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n\n        this.invocation = inv;\n        this.cleanupContext = cleanupContext;\n        LOG.debug(\"Creating an DefaultActionProxy for namespace [{}] and action name [{}]\", namespace, actionName);\n\n        this.actionName = StringEscapeUtils.escapeHtml4(actionName);\n        this.namespace = namespace;\n        this.executeResult = executeResult;\n        this.method = StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(methodName));\n    }\n\n    @Inject\n    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n\n    @Inject\n    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n\n    @Inject\n    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    @Inject(required = false)\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public Object getAction() {\n        return invocation.getAction();\n    }\n\n    public String getActionName() {\n        return actionName;\n    }\n\n    public ActionConfig getConfig() {\n        return config;\n    }\n\n    public void setExecuteResult(boolean executeResult) {\n        this.executeResult = executeResult;\n    }\n\n    public boolean getExecuteResult() {\n        return executeResult;\n    }\n\n    public ActionInvocation getInvocation() {\n        return invocation;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public String execute() throws Exception {\n        ActionContext nestedContext = ActionContext.getContext();\n        ActionContext.bind(invocation.getInvocationContext());\n\n        try {\n            return invocation.invoke();\n        } finally {\n            if (cleanupContext) {\n                ActionContext.bind(nestedContext);\n            }\n        }\n    }\n\n\n    public String getMethod() {\n        return method;\n    }\n\n    private void resolveMethod() {\n        // if the method is set to null, use the one from the configuration\n        // if the one from the configuration is also null, use \"execute\"\n        if (StringUtils.isEmpty(this.method)) {\n            this.method = config.getMethodName();\n            if (StringUtils.isEmpty(this.method)) {\n                this.method = ActionConfig.DEFAULT_METHOD;\n            }\n            methodSpecified = false;\n        }\n    }\n\n    protected void prepare() {\n        config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n\n        if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n            config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n        }\n        if (config == null) {\n            throw new ConfigurationException(getErrorMessage());\n        }\n\n        resolveMethod();\n\n        if (config.isAllowedMethod(method)) {\n            invocation.init(this);\n        } else {\n            throw new ConfigurationException(prepareNotAllowedErrorMessage());\n        }\n    }\n\n    protected String prepareNotAllowedErrorMessage() {\n        return localizedTextProvider.findDefaultText(\n                \"struts.exception.method-not-allowed\",\n                Locale.getDefault(),\n                new String[]{method, actionName}\n        );\n    }\n\n    protected String getErrorMessage() {\n        if ((namespace != null) && (namespace.trim().length() > 0)) {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-package-action\",\n                    Locale.getDefault(),\n                    new String[]{namespace, actionName});\n        } else {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-action\",\n                    Locale.getDefault(),\n                    new String[]{actionName});\n        }\n    }\n\n    public boolean isMethodSpecified() {\n        return methodSpecified;\n    }\n}\n",
        "compositeId": "Class com.opensymphony.xwork2.DefaultActionProxy defines non-transient non-serializable instance field invocation-com/opensymphony/xwork2/DefaultActionProxy.java",
        "classSize": 180,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.inject.Inject;\nimport org.apache.commons.text.StringEscapeUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport java.io.Serializable;\nimport java.util.Locale;\n\n/**\n * The Default ActionProxy implementation\n *\n * @author Rainer Hermanns\n * @author Revised by <a href=\"mailto:hu_pengfei@yahoo.com.cn\">Henry Hu</a>\n * @author tmjee\n * @since 2005-8-6\n */\npublic class DefaultActionProxy implements ActionProxy, Serializable {\n\n    private static final long serialVersionUID = 3293074152487468527L;\n\n    private static final Logger LOG = LogManager.getLogger(DefaultActionProxy.class);\n\n    protected Configuration configuration;\n    protected ActionConfig config;\n    protected transient ActionInvocation invocation;\n    protected UnknownHandlerManager unknownHandlerManager;\n    protected LocalizedTextProvider localizedTextProvider;\n\n    protected String actionName;\n    protected String namespace;\n    protected String method;\n    protected boolean executeResult;\n    protected boolean cleanupContext;\n\n    protected ObjectFactory objectFactory;\n\n    protected ActionEventListener actionEventListener;\n\n    private boolean methodSpecified = true;\n\n    /**\n     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n     *\n     * <p>\n     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n     * </p>\n     *\n     * (like a RMIActionProxy).\n     *\n     * @param inv the action invocation\n     * @param namespace the namespace\n     * @param actionName the action name\n     * @param methodName the method name\n     * @param executeResult execute result\n     * @param cleanupContext cleanup context\n     */\n    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n\n        this.invocation = inv;\n        this.cleanupContext = cleanupContext;\n        LOG.debug(\"Creating an DefaultActionProxy for namespace [{}] and action name [{}]\", namespace, actionName);\n\n        this.actionName = StringEscapeUtils.escapeHtml4(actionName);\n        this.namespace = namespace;\n        this.executeResult = executeResult;\n        this.method = StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(methodName));\n    }\n\n    @Inject\n    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n\n    @Inject\n    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n\n    @Inject\n    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    @Inject(required = false)\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public Object getAction() {\n        return invocation.getAction();\n    }\n\n    public String getActionName() {\n        return actionName;\n    }\n\n    public ActionConfig getConfig() {\n        return config;\n    }\n\n    public void setExecuteResult(boolean executeResult) {\n        this.executeResult = executeResult;\n    }\n\n    public boolean getExecuteResult() {\n        return executeResult;\n    }\n\n    public ActionInvocation getInvocation() {\n        return invocation;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public String execute() throws Exception {\n        ActionContext nestedContext = ActionContext.getContext();\n        ActionContext.bind(invocation.getInvocationContext());\n\n        try {\n            return invocation.invoke();\n        } finally {\n            if (cleanupContext) {\n                ActionContext.bind(nestedContext);\n            }\n        }\n    }\n\n\n    public String getMethod() {\n        return method;\n    }\n\n    private void resolveMethod() {\n        // if the method is set to null, use the one from the configuration\n        // if the one from the configuration is also null, use \"execute\"\n        if (StringUtils.isEmpty(this.method)) {\n            this.method = config.getMethodName();\n            if (StringUtils.isEmpty(this.method)) {\n                this.method = ActionConfig.DEFAULT_METHOD;\n            }\n            methodSpecified = false;\n        }\n    }\n\n    protected void prepare() {\n        config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n\n        if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n            config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n        }\n        if (config == null) {\n            throw new ConfigurationException(getErrorMessage());\n        }\n\n        resolveMethod();\n\n        if (config.isAllowedMethod(method)) {\n            invocation.init(this);\n        } else {\n            throw new ConfigurationException(prepareNotAllowedErrorMessage());\n        }\n    }\n\n    protected String prepareNotAllowedErrorMessage() {\n        return localizedTextProvider.findDefaultText(\n                \"struts.exception.method-not-allowed\",\n                Locale.getDefault(),\n                new String[]{method, actionName}\n        );\n    }\n\n    protected String getErrorMessage() {\n        if ((namespace != null) && (namespace.trim().length() > 0)) {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-package-action\",\n                    Locale.getDefault(),\n                    new String[]{namespace, actionName});\n        } else {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-action\",\n                    Locale.getDefault(),\n                    new String[]{actionName});\n        }\n    }\n\n    public boolean isMethodSpecified() {\n        return methodSpecified;\n    }\n}\n"
    },
    {
        "explanation": "Class com.opensymphony.xwork2.DefaultActionProxy defines non-transient non-serializable instance field unknownHandlerManager",
        "fileName": "com/opensymphony/xwork2/DefaultActionProxy.java",
        "methodStartLineNumber": 44,
        "methodEndLineNumber": 219,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "\n    private static final Logger LOG = LogManager.getLogger(DefaultActionProxy.class);\n\n    protected Configuration configuration;\n    protected ActionConfig config;\n    protected ActionInvocation invocation;\n    protected UnknownHandlerManager unknownHandlerManager;\n    protected LocalizedTextProvider localizedTextProvider;\n\n    protected String actionName;\n    protected String namespace;\n    protected String method;\n    protected boolean executeResult;\n    protected boolean cleanupContext;\n\n    protected ObjectFactory objectFactory;\n\n    protected ActionEventListener actionEventListener;\n\n    private boolean methodSpecified = true;\n\n    /**\n     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n     *\n     * <p>\n     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n     * </p>\n     *\n     * (like a RMIActionProxy).\n     *\n     * @param inv the action invocation\n     * @param namespace the namespace\n     * @param actionName the action name\n     * @param methodName the method name\n     * @param executeResult execute result\n     * @param cleanupContext cleanup context\n     */\n    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n\n        this.invocation = inv;\n        this.cleanupContext = cleanupContext;\n        LOG.debug(\"Creating an DefaultActionProxy for namespace [{}] and action name [{}]\", namespace, actionName);\n\n        this.actionName = StringEscapeUtils.escapeHtml4(actionName);\n        this.namespace = namespace;\n        this.executeResult = executeResult;\n        this.method = StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(methodName));\n    }\n\n    @Inject\n    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n\n    @Inject\n    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n\n    @Inject\n    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    @Inject(required = false)\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public Object getAction() {\n        return invocation.getAction();\n    }\n\n    public String getActionName() {\n        return actionName;\n    }\n\n    public ActionConfig getConfig() {\n        return config;\n    }\n\n    public void setExecuteResult(boolean executeResult) {\n        this.executeResult = executeResult;\n    }\n\n    public boolean getExecuteResult() {\n        return executeResult;\n    }\n\n    public ActionInvocation getInvocation() {\n        return invocation;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public String execute() throws Exception {\n        ActionContext nestedContext = ActionContext.getContext();\n        ActionContext.bind(invocation.getInvocationContext());\n\n        try {\n            return invocation.invoke();\n        } finally {\n            if (cleanupContext) {\n                ActionContext.bind(nestedContext);\n            }\n        }\n    }\n\n\n    public String getMethod() {\n        return method;\n    }\n\n    private void resolveMethod() {\n        // if the method is set to null, use the one from the configuration\n        // if the one from the configuration is also null, use \"execute\"\n        if (StringUtils.isEmpty(this.method)) {\n            this.method = config.getMethodName();\n            if (StringUtils.isEmpty(this.method)) {\n                this.method = ActionConfig.DEFAULT_METHOD;\n            }\n            methodSpecified = false;\n        }\n    }\n\n    protected void prepare() {\n        config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n\n        if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n            config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n        }\n        if (config == null) {\n            throw new ConfigurationException(getErrorMessage());\n        }\n\n        resolveMethod();\n\n        if (config.isAllowedMethod(method)) {\n            invocation.init(this);\n        } else {\n            throw new ConfigurationException(prepareNotAllowedErrorMessage());\n        }\n    }\n\n    protected String prepareNotAllowedErrorMessage() {\n        return localizedTextProvider.findDefaultText(\n                \"struts.exception.method-not-allowed\",\n                Locale.getDefault(),\n                new String[]{method, actionName}\n        );\n    }\n\n    protected String getErrorMessage() {\n        if ((namespace != null) && (namespace.trim().length() > 0)) {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-package-action\",\n                    Locale.getDefault(),\n                    new String[]{namespace, actionName});\n        } else {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-action\",\n                    Locale.getDefault(),\n                    new String[]{actionName});\n        }\n    }\n\n    public boolean isMethodSpecified() {\n        return methodSpecified;\n",
        "classStartLineNumber": 41,
        "classEndLineNumber": 220,
        "classCode": "public class DefaultActionProxy implements ActionProxy, Serializable {\n\n    private static final long serialVersionUID = 3293074152487468527L;\n\n    private static final Logger LOG = LogManager.getLogger(DefaultActionProxy.class);\n\n    protected Configuration configuration;\n    protected ActionConfig config;\n    protected ActionInvocation invocation;\n    protected UnknownHandlerManager unknownHandlerManager;\n    protected LocalizedTextProvider localizedTextProvider;\n\n    protected String actionName;\n    protected String namespace;\n    protected String method;\n    protected boolean executeResult;\n    protected boolean cleanupContext;\n\n    protected ObjectFactory objectFactory;\n\n    protected ActionEventListener actionEventListener;\n\n    private boolean methodSpecified = true;\n\n    /**\n     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n     *\n     * <p>\n     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n     * </p>\n     *\n     * (like a RMIActionProxy).\n     *\n     * @param inv the action invocation\n     * @param namespace the namespace\n     * @param actionName the action name\n     * @param methodName the method name\n     * @param executeResult execute result\n     * @param cleanupContext cleanup context\n     */\n    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n\n        this.invocation = inv;\n        this.cleanupContext = cleanupContext;\n        LOG.debug(\"Creating an DefaultActionProxy for namespace [{}] and action name [{}]\", namespace, actionName);\n\n        this.actionName = StringEscapeUtils.escapeHtml4(actionName);\n        this.namespace = namespace;\n        this.executeResult = executeResult;\n        this.method = StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(methodName));\n    }\n\n    @Inject\n    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n\n    @Inject\n    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n\n    @Inject\n    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    @Inject(required = false)\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public Object getAction() {\n        return invocation.getAction();\n    }\n\n    public String getActionName() {\n        return actionName;\n    }\n\n    public ActionConfig getConfig() {\n        return config;\n    }\n\n    public void setExecuteResult(boolean executeResult) {\n        this.executeResult = executeResult;\n    }\n\n    public boolean getExecuteResult() {\n        return executeResult;\n    }\n\n    public ActionInvocation getInvocation() {\n        return invocation;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public String execute() throws Exception {\n        ActionContext nestedContext = ActionContext.getContext();\n        ActionContext.bind(invocation.getInvocationContext());\n\n        try {\n            return invocation.invoke();\n        } finally {\n            if (cleanupContext) {\n                ActionContext.bind(nestedContext);\n            }\n        }\n    }\n\n\n    public String getMethod() {\n        return method;\n    }\n\n    private void resolveMethod() {\n        // if the method is set to null, use the one from the configuration\n        // if the one from the configuration is also null, use \"execute\"\n        if (StringUtils.isEmpty(this.method)) {\n            this.method = config.getMethodName();\n            if (StringUtils.isEmpty(this.method)) {\n                this.method = ActionConfig.DEFAULT_METHOD;\n            }\n            methodSpecified = false;\n        }\n    }\n\n    protected void prepare() {\n        config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n\n        if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n            config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n        }\n        if (config == null) {\n            throw new ConfigurationException(getErrorMessage());\n        }\n\n        resolveMethod();\n\n        if (config.isAllowedMethod(method)) {\n            invocation.init(this);\n        } else {\n            throw new ConfigurationException(prepareNotAllowedErrorMessage());\n        }\n    }\n\n    protected String prepareNotAllowedErrorMessage() {\n        return localizedTextProvider.findDefaultText(\n                \"struts.exception.method-not-allowed\",\n                Locale.getDefault(),\n                new String[]{method, actionName}\n        );\n    }\n\n    protected String getErrorMessage() {\n        if ((namespace != null) && (namespace.trim().length() > 0)) {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-package-action\",\n                    Locale.getDefault(),\n                    new String[]{namespace, actionName});\n        } else {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-action\",\n                    Locale.getDefault(),\n                    new String[]{actionName});\n        }\n    }\n\n    public boolean isMethodSpecified() {\n        return methodSpecified;\n    }\n}\n",
        "compositeId": "Class com.opensymphony.xwork2.DefaultActionProxy defines non-transient non-serializable instance field unknownHandlerManager-com/opensymphony/xwork2/DefaultActionProxy.java",
        "classSize": 180,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.inject.Inject;\nimport org.apache.commons.text.StringEscapeUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport java.io.Serializable;\nimport java.util.Locale;\n\n/**\n * The Default ActionProxy implementation\n *\n * @author Rainer Hermanns\n * @author Revised by <a href=\"mailto:hu_pengfei@yahoo.com.cn\">Henry Hu</a>\n * @author tmjee\n * @since 2005-8-6\n */\npublic class DefaultActionProxy implements ActionProxy, Serializable {\n\n    private static final long serialVersionUID = 3293074152487468527L;\n\n    private static final Logger LOG = LogManager.getLogger(DefaultActionProxy.class);\n\n    protected Configuration configuration;\n    protected ActionConfig config;\n    protected ActionInvocation invocation;\n    protected transient UnknownHandlerManager unknownHandlerManager;\n    protected LocalizedTextProvider localizedTextProvider;\n\n    protected String actionName;\n    protected String namespace;\n    protected String method;\n    protected boolean executeResult;\n    protected boolean cleanupContext;\n\n    protected ObjectFactory objectFactory;\n\n    protected ActionEventListener actionEventListener;\n\n    private boolean methodSpecified = true;\n\n    /**\n     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n     *\n     * <p>\n     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n     * </p>\n     *\n     * (like a RMIActionProxy).\n     *\n     * @param inv the action invocation\n     * @param namespace the namespace\n     * @param actionName the action name\n     * @param methodName the method name\n     * @param executeResult execute result\n     * @param cleanupContext cleanup context\n     */\n    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n\n        this.invocation = inv;\n        this.cleanupContext = cleanupContext;\n        LOG.debug(\"Creating an DefaultActionProxy for namespace [{}] and action name [{}]\", namespace, actionName);\n\n        this.actionName = StringEscapeUtils.escapeHtml4(actionName);\n        this.namespace = namespace;\n        this.executeResult = executeResult;\n        this.method = StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(methodName));\n    }\n\n    @Inject\n    public void setObjectFactory(ObjectFactory factory) {\n        this.objectFactory = factory;\n    }\n\n    @Inject\n    public void setConfiguration(Configuration config) {\n        this.configuration = config;\n    }\n\n    @Inject\n    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    @Inject(required = false)\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public Object getAction() {\n        return invocation.getAction();\n    }\n\n    public String getActionName() {\n        return actionName;\n    }\n\n    public ActionConfig getConfig() {\n        return config;\n    }\n\n    public void setExecuteResult(boolean executeResult) {\n        this.executeResult = executeResult;\n    }\n\n    public boolean getExecuteResult() {\n        return executeResult;\n    }\n\n    public ActionInvocation getInvocation() {\n        return invocation;\n    }\n\n    public String getNamespace() {\n        return namespace;\n    }\n\n    public String execute() throws Exception {\n        ActionContext nestedContext = ActionContext.getContext();\n        ActionContext.bind(invocation.getInvocationContext());\n\n        try {\n            return invocation.invoke();\n        } finally {\n            if (cleanupContext) {\n                ActionContext.bind(nestedContext);\n            }\n        }\n    }\n\n\n    public String getMethod() {\n        return method;\n    }\n\n    private void resolveMethod() {\n        // if the method is set to null, use the one from the configuration\n        // if the one from the configuration is also null, use \"execute\"\n        if (StringUtils.isEmpty(this.method)) {\n            this.method = config.getMethodName();\n            if (StringUtils.isEmpty(this.method)) {\n                this.method = ActionConfig.DEFAULT_METHOD;\n            }\n            methodSpecified = false;\n        }\n    }\n\n    protected void prepare() {\n        config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n\n        if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n            config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n        }\n        if (config == null) {\n            throw new ConfigurationException(getErrorMessage());\n        }\n\n        resolveMethod();\n\n        if (config.isAllowedMethod(method)) {\n            invocation.init(this);\n        } else {\n            throw new ConfigurationException(prepareNotAllowedErrorMessage());\n        }\n    }\n\n    protected String prepareNotAllowedErrorMessage() {\n        return localizedTextProvider.findDefaultText(\n                \"struts.exception.method-not-allowed\",\n                Locale.getDefault(),\n                new String[]{method, actionName}\n        );\n    }\n\n    protected String getErrorMessage() {\n        if ((namespace != null) && (namespace.trim().length() > 0)) {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-package-action\",\n                    Locale.getDefault(),\n                    new String[]{namespace, actionName});\n        } else {\n            return localizedTextProvider.findDefaultText(\n                    \"xwork.exception.missing-action\",\n                    Locale.getDefault(),\n                    new String[]{actionName});\n        }\n    }\n\n    public boolean isMethodSpecified() {\n        return methodSpecified;\n    }\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.DefaultUnknownHandlerManager.getUnknownHandlers() may expose internal representation by returning DefaultUnknownHandlerManager.unknownHandlers",
        "fileName": "com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
        "methodStartLineNumber": 148,
        "methodEndLineNumber": 150,
        "warning_type": "EI_EXPOSE_REP",
        "codeSnippet": "    public List<UnknownHandler> getUnknownHandlers() {\n        return unknownHandlers;\n",
        "classStartLineNumber": 38,
        "classEndLineNumber": 152,
        "classCode": "public class DefaultUnknownHandlerManager implements UnknownHandlerManager {\n\n    private Container container;\n\n    protected ArrayList<UnknownHandler> unknownHandlers;\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n        try {\n            build();\n        } catch (Exception e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    /**\n     * Builds a list of UnknownHandlers in the order specified by the configured \"unknown-handler-stack\".\n     * If \"unknown-handler-stack\" was not configured, all UnknownHandlers will be returned, in no specific order\n     *\n     * @throws Exception in case of any error\n     */\n    protected void build() throws Exception {\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null && container != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param actionContext the action context\n     * @param actionName the action name\n     * @param actionConfig  the action config\n     * @param resultCode the result code\n     */\n    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it.\n     * Must throw an exception if method cannot be handled.\n     *\n     * @param action the action\n     * @param methodName the method name\n     * @throws NoSuchMethodException if method con not be handled\n     */\n    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        if (unknownHandlers.isEmpty()) {\n            throw new NoSuchMethodException(String.format(\"No UnknownHandlers defined to handle method [%s]\", methodName));\n        } else {\n            throw new NoSuchMethodException(String.format(\"None of defined UnknownHandlers can handle method [%s]\", methodName));\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param namespace the namespace\n     * @param actionName the action name\n     */\n    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean hasUnknownHandlers() {\n        return unknownHandlers != null && !unknownHandlers.isEmpty();\n    }\n\n    public List<UnknownHandler> getUnknownHandlers() {\n        return unknownHandlers;\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.DefaultUnknownHandlerManager.getUnknownHandlers() may expose internal representation by returning DefaultUnknownHandlerManager.unknownHandlers-com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
        "classSize": 115,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Default implementation of UnknownHandlerManager\n *\n * @see com.opensymphony.xwork2.UnknownHandlerManager\n */\npublic class DefaultUnknownHandlerManager implements UnknownHandlerManager {\n\n    private Container container;\n\n    protected ArrayList<UnknownHandler> unknownHandlers;\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n        try {\n            build();\n        } catch (Exception e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    /**\n     * Builds a list of UnknownHandlers in the order specified by the configured \"unknown-handler-stack\".\n     * If \"unknown-handler-stack\" was not configured, all UnknownHandlers will be returned, in no specific order\n     *\n     * @throws Exception in case of any error\n     */\n    protected void build() throws Exception {\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null && container != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param actionContext the action context\n     * @param actionName the action name\n     * @param actionConfig  the action config\n     * @param resultCode the result code\n     */\n    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it.\n     * Must throw an exception if method cannot be handled.\n     *\n     * @param action the action\n     * @param methodName the method name\n     * @throws NoSuchMethodException if method con not be handled\n     */\n    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        if (unknownHandlers.isEmpty()) {\n            throw new NoSuchMethodException(String.format(\"No UnknownHandlers defined to handle method [%s]\", methodName));\n        } else {\n            throw new NoSuchMethodException(String.format(\"None of defined UnknownHandlers can handle method [%s]\", methodName));\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param namespace the namespace\n     * @param actionName the action name\n     */\n    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean hasUnknownHandlers() {\n        return unknownHandlers != null && !unknownHandlers.isEmpty();\n    }\n\n    public List<UnknownHandler> getUnknownHandlers() {\n        return new ArrayList<>(unknownHandlers);\n    }\n\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.DefaultUnknownHandlerManager.setContainer(Container) may expose internal representation by storing an externally mutable object into DefaultUnknownHandlerManager.container",
        "fileName": "com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
        "methodStartLineNumber": 45,
        "methodEndLineNumber": 53,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setContainer(Container container) {\n        this.container = container;\n        try {\n            build();\n        } catch (Exception e) {\n            throw new ConfigurationException(e);\n        }\n    }\n",
        "classStartLineNumber": 38,
        "classEndLineNumber": 152,
        "classCode": "public class DefaultUnknownHandlerManager implements UnknownHandlerManager {\n\n    private Container container;\n\n    protected ArrayList<UnknownHandler> unknownHandlers;\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n        try {\n            build();\n        } catch (Exception e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    /**\n     * Builds a list of UnknownHandlers in the order specified by the configured \"unknown-handler-stack\".\n     * If \"unknown-handler-stack\" was not configured, all UnknownHandlers will be returned, in no specific order\n     *\n     * @throws Exception in case of any error\n     */\n    protected void build() throws Exception {\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null && container != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param actionContext the action context\n     * @param actionName the action name\n     * @param actionConfig  the action config\n     * @param resultCode the result code\n     */\n    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it.\n     * Must throw an exception if method cannot be handled.\n     *\n     * @param action the action\n     * @param methodName the method name\n     * @throws NoSuchMethodException if method con not be handled\n     */\n    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        if (unknownHandlers.isEmpty()) {\n            throw new NoSuchMethodException(String.format(\"No UnknownHandlers defined to handle method [%s]\", methodName));\n        } else {\n            throw new NoSuchMethodException(String.format(\"None of defined UnknownHandlers can handle method [%s]\", methodName));\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param namespace the namespace\n     * @param actionName the action name\n     */\n    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean hasUnknownHandlers() {\n        return unknownHandlers != null && !unknownHandlers.isEmpty();\n    }\n\n    public List<UnknownHandler> getUnknownHandlers() {\n        return unknownHandlers;\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.DefaultUnknownHandlerManager.setContainer(Container) may expose internal representation by storing an externally mutable object into DefaultUnknownHandlerManager.container-com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
        "classSize": 115
    },
    {
        "explanation": "Nullcheck of DefaultUnknownHandlerManager.container at line 64 of value previously dereferenced in com.opensymphony.xwork2.DefaultUnknownHandlerManager.build()",
        "fileName": "com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
        "methodStartLineNumber": 60,
        "methodEndLineNumber": 84,
        "warning_type": "RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE",
        "codeSnippet": "    protected void build() throws Exception {\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null && container != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n",
        "classStartLineNumber": 38,
        "classEndLineNumber": 152,
        "classCode": "public class DefaultUnknownHandlerManager implements UnknownHandlerManager {\n\n    private Container container;\n\n    protected ArrayList<UnknownHandler> unknownHandlers;\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n        try {\n            build();\n        } catch (Exception e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    /**\n     * Builds a list of UnknownHandlers in the order specified by the configured \"unknown-handler-stack\".\n     * If \"unknown-handler-stack\" was not configured, all UnknownHandlers will be returned, in no specific order\n     *\n     * @throws Exception in case of any error\n     */\n    protected void build() throws Exception {\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null && container != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param actionContext the action context\n     * @param actionName the action name\n     * @param actionConfig  the action config\n     * @param resultCode the result code\n     */\n    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it.\n     * Must throw an exception if method cannot be handled.\n     *\n     * @param action the action\n     * @param methodName the method name\n     * @throws NoSuchMethodException if method con not be handled\n     */\n    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        if (unknownHandlers.isEmpty()) {\n            throw new NoSuchMethodException(String.format(\"No UnknownHandlers defined to handle method [%s]\", methodName));\n        } else {\n            throw new NoSuchMethodException(String.format(\"None of defined UnknownHandlers can handle method [%s]\", methodName));\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param namespace the namespace\n     * @param actionName the action name\n     */\n    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean hasUnknownHandlers() {\n        return unknownHandlers != null && !unknownHandlers.isEmpty();\n    }\n\n    public List<UnknownHandler> getUnknownHandlers() {\n        return unknownHandlers;\n    }\n\n}\n",
        "compositeId": "Nullcheck of DefaultUnknownHandlerManager.container at line 64 of value previously dereferenced in com.opensymphony.xwork2.DefaultUnknownHandlerManager.build()-com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
        "classSize": 115,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Default implementation of UnknownHandlerManager\n *\n * @see com.opensymphony.xwork2.UnknownHandlerManager\n */\npublic class DefaultUnknownHandlerManager implements UnknownHandlerManager {\n\n    private Container container;\n\n    protected ArrayList<UnknownHandler> unknownHandlers;\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n        try {\n            build();\n        } catch (Exception e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    /**\n     * Builds a list of UnknownHandlers in the order specified by the configured \"unknown-handler-stack\".\n     * If \"unknown-handler-stack\" was not configured, all UnknownHandlers will be returned, in no specific order\n     *\n     * @throws Exception in case of any error\n     */\n    protected void build() throws Exception {\n        if (container == null) {\n            throw new Exception(\"Container is not initialized\");\n        }\n\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param actionContext the action context\n     * @param actionName the action name\n     * @param actionConfig  the action config\n     * @param resultCode the result code\n     */\n    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it.\n     * Must throw an exception if method cannot be handled.\n     *\n     * @param action the action\n     * @param methodName the method name\n     * @throws NoSuchMethodException if method con not be handled\n     */\n    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        if (unknownHandlers.isEmpty()) {\n            throw new NoSuchMethodException(String.format(\"No UnknownHandlers defined to handle method [%s]\", methodName));\n        } else {\n            throw new NoSuchMethodException(String.format(\"None of defined UnknownHandlers can handle method [%s]\", methodName));\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param namespace the namespace\n     * @param actionName the action name\n     */\n    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean hasUnknownHandlers() {\n        return unknownHandlers != null && !unknownHandlers.isEmpty();\n    }\n\n    public List<UnknownHandler> getUnknownHandlers() {\n        return unknownHandlers;\n    }\n\n}\n"
    },
    {
        "explanation": "DefaultUnknownHandlerManager.container not initialized in constructor and dereferenced in com.opensymphony.xwork2.DefaultUnknownHandlerManager.build()",
        "fileName": "com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
        "methodStartLineNumber": 60,
        "methodEndLineNumber": 84,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    protected void build() throws Exception {\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null && container != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n",
        "classStartLineNumber": 38,
        "classEndLineNumber": 152,
        "classCode": "public class DefaultUnknownHandlerManager implements UnknownHandlerManager {\n\n    private Container container;\n\n    protected ArrayList<UnknownHandler> unknownHandlers;\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n        try {\n            build();\n        } catch (Exception e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    /**\n     * Builds a list of UnknownHandlers in the order specified by the configured \"unknown-handler-stack\".\n     * If \"unknown-handler-stack\" was not configured, all UnknownHandlers will be returned, in no specific order\n     *\n     * @throws Exception in case of any error\n     */\n    protected void build() throws Exception {\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null && container != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param actionContext the action context\n     * @param actionName the action name\n     * @param actionConfig  the action config\n     * @param resultCode the result code\n     */\n    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it.\n     * Must throw an exception if method cannot be handled.\n     *\n     * @param action the action\n     * @param methodName the method name\n     * @throws NoSuchMethodException if method con not be handled\n     */\n    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        if (unknownHandlers.isEmpty()) {\n            throw new NoSuchMethodException(String.format(\"No UnknownHandlers defined to handle method [%s]\", methodName));\n        } else {\n            throw new NoSuchMethodException(String.format(\"None of defined UnknownHandlers can handle method [%s]\", methodName));\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param namespace the namespace\n     * @param actionName the action name\n     */\n    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean hasUnknownHandlers() {\n        return unknownHandlers != null && !unknownHandlers.isEmpty();\n    }\n\n    public List<UnknownHandler> getUnknownHandlers() {\n        return unknownHandlers;\n    }\n\n}\n",
        "compositeId": "DefaultUnknownHandlerManager.container not initialized in constructor and dereferenced in com.opensymphony.xwork2.DefaultUnknownHandlerManager.build()-com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
        "classSize": 115,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Default implementation of UnknownHandlerManager\n *\n * @see com.opensymphony.xwork2.UnknownHandlerManager\n */\npublic class DefaultUnknownHandlerManager implements UnknownHandlerManager {\n\n    private Container container;\n\n    protected ArrayList<UnknownHandler> unknownHandlers;\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n        try {\n            build();\n        } catch (Exception e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    /**\n     * Builds a list of UnknownHandlers in the order specified by the configured \"unknown-handler-stack\".\n     * If \"unknown-handler-stack\" was not configured, all UnknownHandlers will be returned, in no specific order\n     *\n     * @throws Exception in case of any error\n     */\n    protected void build() throws Exception {\n        if (container == null) {\n            throw new Exception(\"Container is not initialized\");\n        }\n\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param actionContext the action context\n     * @param actionName the action name\n     * @param actionConfig  the action config\n     * @param resultCode the result code\n     */\n    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it.\n     * Must throw an exception if method cannot be handled.\n     *\n     * @param action the action\n     * @param methodName the method name\n     * @throws NoSuchMethodException if method con not be handled\n     */\n    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        if (unknownHandlers.isEmpty()) {\n            throw new NoSuchMethodException(String.format(\"No UnknownHandlers defined to handle method [%s]\", methodName));\n        } else {\n            throw new NoSuchMethodException(String.format(\"None of defined UnknownHandlers can handle method [%s]\", methodName));\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param namespace the namespace\n     * @param actionName the action name\n     */\n    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean hasUnknownHandlers() {\n        return unknownHandlers != null && !unknownHandlers.isEmpty();\n    }\n\n    public List<UnknownHandler> getUnknownHandlers() {\n        return unknownHandlers;\n    }\n\n}\n"
    },
    {
        "explanation": "DefaultUnknownHandlerManager.unknownHandlers not initialized in constructor and dereferenced in com.opensymphony.xwork2.DefaultUnknownHandlerManager.handleUnknownAction(String, String)",
        "fileName": "com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
        "methodStartLineNumber": 133,
        "methodEndLineNumber": 142,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n",
        "classStartLineNumber": 38,
        "classEndLineNumber": 152,
        "classCode": "public class DefaultUnknownHandlerManager implements UnknownHandlerManager {\n\n    private Container container;\n\n    protected ArrayList<UnknownHandler> unknownHandlers;\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n        try {\n            build();\n        } catch (Exception e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    /**\n     * Builds a list of UnknownHandlers in the order specified by the configured \"unknown-handler-stack\".\n     * If \"unknown-handler-stack\" was not configured, all UnknownHandlers will be returned, in no specific order\n     *\n     * @throws Exception in case of any error\n     */\n    protected void build() throws Exception {\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null && container != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param actionContext the action context\n     * @param actionName the action name\n     * @param actionConfig  the action config\n     * @param resultCode the result code\n     */\n    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it.\n     * Must throw an exception if method cannot be handled.\n     *\n     * @param action the action\n     * @param methodName the method name\n     * @throws NoSuchMethodException if method con not be handled\n     */\n    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        if (unknownHandlers.isEmpty()) {\n            throw new NoSuchMethodException(String.format(\"No UnknownHandlers defined to handle method [%s]\", methodName));\n        } else {\n            throw new NoSuchMethodException(String.format(\"None of defined UnknownHandlers can handle method [%s]\", methodName));\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param namespace the namespace\n     * @param actionName the action name\n     */\n    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean hasUnknownHandlers() {\n        return unknownHandlers != null && !unknownHandlers.isEmpty();\n    }\n\n    public List<UnknownHandler> getUnknownHandlers() {\n        return unknownHandlers;\n    }\n\n}\n",
        "compositeId": "DefaultUnknownHandlerManager.unknownHandlers not initialized in constructor and dereferenced in com.opensymphony.xwork2.DefaultUnknownHandlerManager.handleUnknownAction(String, String)-com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
        "classSize": 115,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Default implementation of UnknownHandlerManager\n *\n * @see com.opensymphony.xwork2.UnknownHandlerManager\n */\npublic class DefaultUnknownHandlerManager implements UnknownHandlerManager {\n\n    private Container container;\n\n    protected ArrayList<UnknownHandler> unknownHandlers;\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n        try {\n            build();\n        } catch (Exception e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    /**\n     * Builds a list of UnknownHandlers in the order specified by the configured \"unknown-handler-stack\".\n     * If \"unknown-handler-stack\" was not configured, all UnknownHandlers will be returned, in no specific order\n     *\n     * @throws Exception in case of any error\n     */\n    protected void build() throws Exception {\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null && container != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param actionContext the action context\n     * @param actionName the action name\n     * @param actionConfig  the action config\n     * @param resultCode the result code\n     */\n    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n        if (unknownHandlers == null) {\n            return null;\n        }\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it.\n     * Must throw an exception if method cannot be handled.\n     *\n     * @param action the action\n     * @param methodName the method name\n     * @throws NoSuchMethodException if method con not be handled\n     */\n    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n        if (unknownHandlers == null || unknownHandlers.isEmpty()) {\n            throw new NoSuchMethodException(String.format(\"No UnknownHandlers defined to handle method [%s]\", methodName));\n        }\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        throw new NoSuchMethodException(String.format(\"None of defined UnknownHandlers can handle method [%s]\", methodName));\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param namespace the namespace\n     * @param actionName the action name\n     */\n    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n        if (unknownHandlers == null) {\n            return null;\n        }\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean hasUnknownHandlers() {\n        return unknownHandlers != null && !unknownHandlers.isEmpty();\n    }\n\n    public List<UnknownHandler> getUnknownHandlers() {\n        return unknownHandlers;\n    }\n\n}\n"
    },
    {
        "explanation": "DefaultUnknownHandlerManager.unknownHandlers not initialized in constructor and dereferenced in com.opensymphony.xwork2.DefaultUnknownHandlerManager.handleUnknownMethod(Object, String)",
        "fileName": "com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
        "methodStartLineNumber": 112,
        "methodEndLineNumber": 124,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        if (unknownHandlers.isEmpty()) {\n            throw new NoSuchMethodException(String.format(\"No UnknownHandlers defined to handle method [%s]\", methodName));\n        } else {\n            throw new NoSuchMethodException(String.format(\"None of defined UnknownHandlers can handle method [%s]\", methodName));\n",
        "classStartLineNumber": 38,
        "classEndLineNumber": 152,
        "classCode": "public class DefaultUnknownHandlerManager implements UnknownHandlerManager {\n\n    private Container container;\n\n    protected ArrayList<UnknownHandler> unknownHandlers;\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n        try {\n            build();\n        } catch (Exception e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    /**\n     * Builds a list of UnknownHandlers in the order specified by the configured \"unknown-handler-stack\".\n     * If \"unknown-handler-stack\" was not configured, all UnknownHandlers will be returned, in no specific order\n     *\n     * @throws Exception in case of any error\n     */\n    protected void build() throws Exception {\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null && container != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param actionContext the action context\n     * @param actionName the action name\n     * @param actionConfig  the action config\n     * @param resultCode the result code\n     */\n    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it.\n     * Must throw an exception if method cannot be handled.\n     *\n     * @param action the action\n     * @param methodName the method name\n     * @throws NoSuchMethodException if method con not be handled\n     */\n    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        if (unknownHandlers.isEmpty()) {\n            throw new NoSuchMethodException(String.format(\"No UnknownHandlers defined to handle method [%s]\", methodName));\n        } else {\n            throw new NoSuchMethodException(String.format(\"None of defined UnknownHandlers can handle method [%s]\", methodName));\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param namespace the namespace\n     * @param actionName the action name\n     */\n    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean hasUnknownHandlers() {\n        return unknownHandlers != null && !unknownHandlers.isEmpty();\n    }\n\n    public List<UnknownHandler> getUnknownHandlers() {\n        return unknownHandlers;\n    }\n\n}\n",
        "compositeId": "DefaultUnknownHandlerManager.unknownHandlers not initialized in constructor and dereferenced in com.opensymphony.xwork2.DefaultUnknownHandlerManager.handleUnknownMethod(Object, String)-com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
        "classSize": 115,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Default implementation of UnknownHandlerManager\n *\n * @see com.opensymphony.xwork2.UnknownHandlerManager\n */\npublic class DefaultUnknownHandlerManager implements UnknownHandlerManager {\n\n    private Container container;\n\n    protected ArrayList<UnknownHandler> unknownHandlers;\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n        try {\n            build();\n        } catch (Exception e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    /**\n     * Builds a list of UnknownHandlers in the order specified by the configured \"unknown-handler-stack\".\n     * If \"unknown-handler-stack\" was not configured, all UnknownHandlers will be returned, in no specific order\n     *\n     * @throws Exception in case of any error\n     */\n    protected void build() throws Exception {\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null && container != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param actionContext the action context\n     * @param actionName the action name\n     * @param actionConfig  the action config\n     * @param resultCode the result code\n     */\n    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n        if (unknownHandlers == null) {\n            return null;\n        }\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it.\n     * Must throw an exception if method cannot be handled.\n     *\n     * @param action the action\n     * @param methodName the method name\n     * @throws NoSuchMethodException if method con not be handled\n     */\n    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n        if (unknownHandlers == null || unknownHandlers.isEmpty()) {\n            throw new NoSuchMethodException(String.format(\"No UnknownHandlers defined to handle method [%s]\", methodName));\n        }\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        throw new NoSuchMethodException(String.format(\"None of defined UnknownHandlers can handle method [%s]\", methodName));\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param namespace the namespace\n     * @param actionName the action name\n     */\n    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n        if (unknownHandlers == null) {\n            return null;\n        }\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean hasUnknownHandlers() {\n        return unknownHandlers != null && !unknownHandlers.isEmpty();\n    }\n\n    public List<UnknownHandler> getUnknownHandlers() {\n        return unknownHandlers;\n    }\n\n}\n"
    },
    {
        "explanation": "DefaultUnknownHandlerManager.unknownHandlers not initialized in constructor and dereferenced in com.opensymphony.xwork2.DefaultUnknownHandlerManager.handleUnknownResult(ActionContext, String, ActionConfig, String)",
        "fileName": "com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
        "methodStartLineNumber": 93,
        "methodEndLineNumber": 102,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n",
        "classStartLineNumber": 38,
        "classEndLineNumber": 152,
        "classCode": "public class DefaultUnknownHandlerManager implements UnknownHandlerManager {\n\n    private Container container;\n\n    protected ArrayList<UnknownHandler> unknownHandlers;\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n        try {\n            build();\n        } catch (Exception e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    /**\n     * Builds a list of UnknownHandlers in the order specified by the configured \"unknown-handler-stack\".\n     * If \"unknown-handler-stack\" was not configured, all UnknownHandlers will be returned, in no specific order\n     *\n     * @throws Exception in case of any error\n     */\n    protected void build() throws Exception {\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null && container != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param actionContext the action context\n     * @param actionName the action name\n     * @param actionConfig  the action config\n     * @param resultCode the result code\n     */\n    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it.\n     * Must throw an exception if method cannot be handled.\n     *\n     * @param action the action\n     * @param methodName the method name\n     * @throws NoSuchMethodException if method con not be handled\n     */\n    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        if (unknownHandlers.isEmpty()) {\n            throw new NoSuchMethodException(String.format(\"No UnknownHandlers defined to handle method [%s]\", methodName));\n        } else {\n            throw new NoSuchMethodException(String.format(\"None of defined UnknownHandlers can handle method [%s]\", methodName));\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param namespace the namespace\n     * @param actionName the action name\n     */\n    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean hasUnknownHandlers() {\n        return unknownHandlers != null && !unknownHandlers.isEmpty();\n    }\n\n    public List<UnknownHandler> getUnknownHandlers() {\n        return unknownHandlers;\n    }\n\n}\n",
        "compositeId": "DefaultUnknownHandlerManager.unknownHandlers not initialized in constructor and dereferenced in com.opensymphony.xwork2.DefaultUnknownHandlerManager.handleUnknownResult(ActionContext, String, ActionConfig, String)-com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
        "classSize": 115,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Default implementation of UnknownHandlerManager\n *\n * @see com.opensymphony.xwork2.UnknownHandlerManager\n */\npublic class DefaultUnknownHandlerManager implements UnknownHandlerManager {\n\n    private Container container;\n\n    protected ArrayList<UnknownHandler> unknownHandlers;\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n        try {\n            build();\n        } catch (Exception e) {\n            throw new ConfigurationException(e);\n        }\n    }\n\n    /**\n     * Builds a list of UnknownHandlers in the order specified by the configured \"unknown-handler-stack\".\n     * If \"unknown-handler-stack\" was not configured, all UnknownHandlers will be returned, in no specific order\n     *\n     * @throws Exception in case of any error\n     */\n    protected void build() throws Exception {\n        Configuration configuration = container.getInstance(Configuration.class);\n        ObjectFactory factory = container.getInstance(ObjectFactory.class);\n\n        if (configuration != null && container != null) {\n            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n            unknownHandlers = new ArrayList<>();\n\n            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n                //get UnknownHandlers in the specified order\n                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n                    UnknownHandler uh = factory.buildUnknownHandler(unknownHandlerConfig.getName(), new HashMap<String, Object>());\n                    unknownHandlers.add(uh);\n                }\n            } else {\n                //add all available UnknownHandlers\n                Set<String> unknownHandlerNames = container.getInstanceNames(UnknownHandler.class);\n                for (String unknownHandlerName : unknownHandlerNames) {\n                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerName);\n                    unknownHandlers.add(uh);\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param actionContext the action context\n     * @param actionName the action name\n     * @param actionConfig  the action config\n     * @param resultCode the result code\n     */\n    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n        if (unknownHandlers == null) {\n            return null;\n        }\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it.\n     * Must throw an exception if method cannot be handled.\n     *\n     * @param action the action\n     * @param methodName the method name\n     * @throws NoSuchMethodException if method con not be handled\n     */\n    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n        if (unknownHandlers == null || unknownHandlers.isEmpty()) {\n            throw new NoSuchMethodException(String.format(\"No UnknownHandlers defined to handle method [%s]\", methodName));\n        }\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        throw new NoSuchMethodException(String.format(\"None of defined UnknownHandlers can handle method [%s]\", methodName));\n    }\n\n    /**\n     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n     *\n     * @param namespace the namespace\n     * @param actionName the action name\n     */\n    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n        if (unknownHandlers == null) {\n            return null;\n        }\n        for (UnknownHandler unknownHandler : unknownHandlers) {\n            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    public boolean hasUnknownHandlers() {\n        return unknownHandlers != null && !unknownHandlers.isEmpty();\n    }\n\n    public List<UnknownHandler> getUnknownHandlers() {\n        return unknownHandlers;\n    }\n\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.ObjectFactory.setClassLoader(ClassLoader) may expose internal representation by storing an externally mutable object into ObjectFactory.ccl",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 73,
        "methodEndLineNumber": 76,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "com.opensymphony.xwork2.ObjectFactory.setClassLoader(ClassLoader) may expose internal representation by storing an externally mutable object into ObjectFactory.ccl-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.InterceptorConfig;\nimport com.opensymphony.xwork2.config.entities.ResultConfig;\nimport com.opensymphony.xwork2.conversion.TypeConverter;\nimport com.opensymphony.xwork2.factory.*;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.interceptor.Interceptor;\nimport com.opensymphony.xwork2.util.ClassLoaderUtil;\nimport com.opensymphony.xwork2.validator.Validator;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * ObjectFactory is responsible for building the core framework objects. Users may register their \n * own implementation of the ObjectFactory to control instantiation of these Objects.\n *\n * <p>\n * This default implementation uses the {@link #buildBean(Class,java.util.Map) buildBean} \n * method to create all classes (interceptors, actions, results, etc).\n * </p>\n *\n * @author Jason Carreira\n */\npublic class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl != null ? new SecureClassLoaderWrapper(cl) : null;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n\n    private static class SecureClassLoaderWrapper extends ClassLoader {\n        private final ClassLoader wrappedClassLoader;\n\n        public SecureClassLoaderWrapper(ClassLoader wrappedClassLoader) {\n            super(wrappedClassLoader.getParent());\n            this.wrappedClassLoader = wrappedClassLoader;\n        }\n\n        @Override\n        public Class<?> loadClass(String name) throws ClassNotFoundException {\n            return wrappedClassLoader.loadClass(name);\n        }\n    }\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.ObjectFactory.setContainer(Container) may expose internal representation by storing an externally mutable object into ObjectFactory.container",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 68,
        "methodEndLineNumber": 71,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setContainer(Container container) {\n        this.container = container;\n    }\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "com.opensymphony.xwork2.ObjectFactory.setContainer(Container) may expose internal representation by storing an externally mutable object into ObjectFactory.container-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215
    },
    {
        "explanation": "Class com.opensymphony.xwork2.ObjectFactory defines non-transient non-serializable instance field actionFactory",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 51,
        "methodEndLineNumber": 262,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "Class com.opensymphony.xwork2.ObjectFactory defines non-transient non-serializable instance field actionFactory-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.InterceptorConfig;\nimport com.opensymphony.xwork2.config.entities.ResultConfig;\nimport com.opensymphony.xwork2.conversion.TypeConverter;\nimport com.opensymphony.xwork2.factory.*;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.interceptor.Interceptor;\nimport com.opensymphony.xwork2.util.ClassLoaderUtil;\nimport com.opensymphony.xwork2.validator.Validator;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * ObjectFactory is responsible for building the core framework objects. Users may register their \n * own implementation of the ObjectFactory to control instantiation of these Objects.\n *\n * <p>\n * This default implementation uses the {@link #buildBean(Class,java.util.Map) buildBean} \n * method to create all classes (interceptors, actions, results, etc).\n * </p>\n *\n * @author Jason Carreira\n */\npublic class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private transient ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n"
    },
    {
        "explanation": "Class com.opensymphony.xwork2.ObjectFactory defines non-transient non-serializable instance field converterFactory",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 51,
        "methodEndLineNumber": 262,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "Class com.opensymphony.xwork2.ObjectFactory defines non-transient non-serializable instance field converterFactory-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.InterceptorConfig;\nimport com.opensymphony.xwork2.config.entities.ResultConfig;\nimport com.opensymphony.xwork2.conversion.TypeConverter;\nimport com.opensymphony.xwork2.factory.*;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.interceptor.Interceptor;\nimport com.opensymphony.xwork2.util.ClassLoaderUtil;\nimport com.opensymphony.xwork2.validator.Validator;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * ObjectFactory is responsible for building the core framework objects. Users may register their \n * own implementation of the ObjectFactory to control instantiation of these Objects.\n *\n * <p>\n * This default implementation uses the {@link #buildBean(Class,java.util.Map) buildBean} \n * method to create all classes (interceptors, actions, results, etc).\n * </p>\n *\n * @author Jason Carreira\n */\npublic class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private transient ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n"
    },
    {
        "explanation": "Class com.opensymphony.xwork2.ObjectFactory defines non-transient non-serializable instance field interceptorFactory",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 51,
        "methodEndLineNumber": 262,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "Class com.opensymphony.xwork2.ObjectFactory defines non-transient non-serializable instance field interceptorFactory-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.InterceptorConfig;\nimport com.opensymphony.xwork2.config.entities.ResultConfig;\nimport com.opensymphony.xwork2.conversion.TypeConverter;\nimport com.opensymphony.xwork2.factory.*;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.interceptor.Interceptor;\nimport com.opensymphony.xwork2.util.ClassLoaderUtil;\nimport com.opensymphony.xwork2.validator.Validator;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * ObjectFactory is responsible for building the core framework objects. Users may register their \n * own implementation of the ObjectFactory to control instantiation of these Objects.\n *\n * <p>\n * This default implementation uses the {@link #buildBean(Class,java.util.Map) buildBean} \n * method to create all classes (interceptors, actions, results, etc).\n * </p>\n *\n * @author Jason Carreira\n */\npublic class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private transient InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n"
    },
    {
        "explanation": "Class com.opensymphony.xwork2.ObjectFactory defines non-transient non-serializable instance field resultFactory",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 51,
        "methodEndLineNumber": 262,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "Class com.opensymphony.xwork2.ObjectFactory defines non-transient non-serializable instance field resultFactory-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.InterceptorConfig;\nimport com.opensymphony.xwork2.config.entities.ResultConfig;\nimport com.opensymphony.xwork2.conversion.TypeConverter;\nimport com.opensymphony.xwork2.factory.*;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.interceptor.Interceptor;\nimport com.opensymphony.xwork2.util.ClassLoaderUtil;\nimport com.opensymphony.xwork2.validator.Validator;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * ObjectFactory is responsible for building the core framework objects. Users may register their \n * own implementation of the ObjectFactory to control instantiation of these Objects.\n *\n * <p>\n * This default implementation uses the {@link #buildBean(Class,java.util.Map) buildBean} \n * method to create all classes (interceptors, actions, results, etc).\n * </p>\n *\n * @author Jason Carreira\n */\npublic class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private transient ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n"
    },
    {
        "explanation": "Class com.opensymphony.xwork2.ObjectFactory defines non-transient non-serializable instance field unknownHandlerFactory",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 51,
        "methodEndLineNumber": 262,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "Class com.opensymphony.xwork2.ObjectFactory defines non-transient non-serializable instance field unknownHandlerFactory-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.InterceptorConfig;\nimport com.opensymphony.xwork2.config.entities.ResultConfig;\nimport com.opensymphony.xwork2.conversion.TypeConverter;\nimport com.opensymphony.xwork2.factory.*;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.interceptor.Interceptor;\nimport com.opensymphony.xwork2.util.ClassLoaderUtil;\nimport com.opensymphony.xwork2.validator.Validator;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * ObjectFactory is responsible for building the core framework objects. Users may register their \n * own implementation of the ObjectFactory to control instantiation of these Objects.\n *\n * <p>\n * This default implementation uses the {@link #buildBean(Class,java.util.Map) buildBean} \n * method to create all classes (interceptors, actions, results, etc).\n * </p>\n *\n * @author Jason Carreira\n */\npublic class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private transient UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n"
    },
    {
        "explanation": "Class com.opensymphony.xwork2.ObjectFactory defines non-transient non-serializable instance field validatorFactory",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 51,
        "methodEndLineNumber": 262,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "Class com.opensymphony.xwork2.ObjectFactory defines non-transient non-serializable instance field validatorFactory-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.InterceptorConfig;\nimport com.opensymphony.xwork2.config.entities.ResultConfig;\nimport com.opensymphony.xwork2.conversion.TypeConverter;\nimport com.opensymphony.xwork2.factory.*;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.interceptor.Interceptor;\nimport com.opensymphony.xwork2.util.ClassLoaderUtil;\nimport com.opensymphony.xwork2.validator.Validator;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * ObjectFactory is responsible for building the core framework objects. Users may register their \n * own implementation of the ObjectFactory to control instantiation of these Objects.\n *\n * <p>\n * This default implementation uses the {@link #buildBean(Class,java.util.Map) buildBean} \n * method to create all classes (interceptors, actions, results, etc).\n * </p>\n *\n * @author Jason Carreira\n */\npublic class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private transient ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.ObjectFactory is Serializable; consider declaring a serialVersionUID",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 51,
        "methodEndLineNumber": 262,
        "warning_type": "SE_NO_SERIALVERSIONID",
        "codeSnippet": "\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "com.opensymphony.xwork2.ObjectFactory is Serializable; consider declaring a serialVersionUID-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.InterceptorConfig;\nimport com.opensymphony.xwork2.config.entities.ResultConfig;\nimport com.opensymphony.xwork2.conversion.TypeConverter;\nimport com.opensymphony.xwork2.factory.*;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.interceptor.Interceptor;\nimport com.opensymphony.xwork2.util.ClassLoaderUtil;\nimport com.opensymphony.xwork2.validator.Validator;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * ObjectFactory is responsible for building the core framework objects. Users may register their \n * own implementation of the ObjectFactory to control instantiation of these Objects.\n *\n * <p>\n * This default implementation uses the {@link #buildBean(Class,java.util.Map) buildBean} \n * method to create all classes (interceptors, actions, results, etc).\n * </p>\n *\n * @author Jason Carreira\n */\npublic class ObjectFactory implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n"
    },
    {
        "explanation": "ObjectFactory.actionFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ObjectFactory.buildAction(String, String, ActionConfig, Map)",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 142,
        "methodEndLineNumber": 144,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "ObjectFactory.actionFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ObjectFactory.buildAction(String, String, ActionConfig, Map)-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.InterceptorConfig;\nimport com.opensymphony.xwork2.config.entities.ResultConfig;\nimport com.opensymphony.xwork2.conversion.TypeConverter;\nimport com.opensymphony.xwork2.factory.*;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.interceptor.Interceptor;\nimport com.opensymphony.xwork2.util.ClassLoaderUtil;\nimport com.opensymphony.xwork2.validator.Validator;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * ObjectFactory is responsible for building the core framework objects. Users may register their \n * own implementation of the ObjectFactory to control instantiation of these Objects.\n *\n * <p>\n * This default implementation uses the {@link #buildBean(Class,java.util.Map) buildBean} \n * method to create all classes (interceptors, actions, results, etc).\n * </p>\n *\n * @author Jason Carreira\n */\npublic class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n        this.actionFactory = new DefaultActionFactory();\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        if (actionFactory == null) {\n            throw new IllegalStateException(\"ActionFactory is not initialized\");\n        }\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n"
    },
    {
        "explanation": "ObjectFactory.container not initialized in constructor and dereferenced in com.opensymphony.xwork2.ObjectFactory.buildBean(Class, Map)",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 154,
        "methodEndLineNumber": 156,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "ObjectFactory.container not initialized in constructor and dereferenced in com.opensymphony.xwork2.ObjectFactory.buildBean(Class, Map)-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215
    },
    {
        "explanation": "ObjectFactory.converterFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ObjectFactory.buildConverter(Class, Map)",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 248,
        "methodEndLineNumber": 250,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "ObjectFactory.converterFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ObjectFactory.buildConverter(Class, Map)-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215
    },
    {
        "explanation": "ObjectFactory.interceptorFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ObjectFactory.buildInterceptor(InterceptorConfig, Map)",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 209,
        "methodEndLineNumber": 211,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "ObjectFactory.interceptorFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ObjectFactory.buildInterceptor(InterceptorConfig, Map)-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215
    },
    {
        "explanation": "ObjectFactory.resultFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ObjectFactory.buildResult(ResultConfig, Map)",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 222,
        "methodEndLineNumber": 224,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "ObjectFactory.resultFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ObjectFactory.buildResult(ResultConfig, Map)-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.InterceptorConfig;\nimport com.opensymphony.xwork2.config.entities.ResultConfig;\nimport com.opensymphony.xwork2.conversion.TypeConverter;\nimport com.opensymphony.xwork2.factory.*;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.interceptor.Interceptor;\nimport com.opensymphony.xwork2.util.ClassLoaderUtil;\nimport com.opensymphony.xwork2.validator.Validator;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * ObjectFactory is responsible for building the core framework objects. Users may register their \n * own implementation of the ObjectFactory to control instantiation of these Objects.\n *\n * <p>\n * This default implementation uses the {@link #buildBean(Class,java.util.Map) buildBean} \n * method to create all classes (interceptors, actions, results, etc).\n * </p>\n *\n * @author Jason Carreira\n */\npublic class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n        // Initialize resultFactory to prevent dereferencing null\n        this.resultFactory = new ResultFactory() {\n            @Override\n            public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n                // Default implementation, can be overridden by DI\n                return null;\n            }\n        };\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n"
    },
    {
        "explanation": "ObjectFactory.unknownHandlerFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ObjectFactory.buildUnknownHandler(String, Map)",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 260,
        "methodEndLineNumber": 262,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "ObjectFactory.unknownHandlerFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ObjectFactory.buildUnknownHandler(String, Map)-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.InterceptorConfig;\nimport com.opensymphony.xwork2.config.entities.ResultConfig;\nimport com.opensymphony.xwork2.conversion.TypeConverter;\nimport com.opensymphony.xwork2.factory.*;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.interceptor.Interceptor;\nimport com.opensymphony.xwork2.util.ClassLoaderUtil;\nimport com.opensymphony.xwork2.validator.Validator;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * ObjectFactory is responsible for building the core framework objects. Users may register their \n * own implementation of the ObjectFactory to control instantiation of these Objects.\n *\n * <p>\n * This default implementation uses the {@link #buildBean(Class,java.util.Map) buildBean} \n * method to create all classes (interceptors, actions, results, etc).\n * </p>\n *\n * @author Jason Carreira\n */\npublic class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n        this.unknownHandlerFactory = new UnknownHandlerFactory() {\n            @Override\n            public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n                Class<?> clazz = getClassInstance(unknownHandlerName);\n                return (UnknownHandler) buildBean(clazz, extraContext);\n            }\n        };\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n"
    },
    {
        "explanation": "ObjectFactory.validatorFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ObjectFactory.buildValidator(String, Map, Map)",
        "fileName": "com/opensymphony/xwork2/ObjectFactory.java",
        "methodStartLineNumber": 236,
        "methodEndLineNumber": 238,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n",
        "classStartLineNumber": 50,
        "classEndLineNumber": 264,
        "classCode": "public class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n",
        "compositeId": "ObjectFactory.validatorFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ObjectFactory.buildValidator(String, Map, Map)-com/opensymphony/xwork2/ObjectFactory.java",
        "classSize": 215,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2;\n\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.config.entities.InterceptorConfig;\nimport com.opensymphony.xwork2.config.entities.ResultConfig;\nimport com.opensymphony.xwork2.conversion.TypeConverter;\nimport com.opensymphony.xwork2.factory.*;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.interceptor.Interceptor;\nimport com.opensymphony.xwork2.util.ClassLoaderUtil;\nimport com.opensymphony.xwork2.validator.Validator;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * ObjectFactory is responsible for building the core framework objects. Users may register their \n * own implementation of the ObjectFactory to control instantiation of these Objects.\n *\n * <p>\n * This default implementation uses the {@link #buildBean(Class,java.util.Map) buildBean} \n * method to create all classes (interceptors, actions, results, etc).\n * </p>\n *\n * @author Jason Carreira\n */\npublic class ObjectFactory implements Serializable {\n\n    private static final Logger LOG = LogManager.getLogger(ObjectFactory.class);\n\n    private transient ClassLoader ccl;\n\n    private Container container;\n    private ActionFactory actionFactory;\n    private ResultFactory resultFactory;\n    private InterceptorFactory interceptorFactory;\n    private ValidatorFactory validatorFactory;\n    private ConverterFactory converterFactory;\n    private UnknownHandlerFactory unknownHandlerFactory;\n\n    public ObjectFactory() {\n        // Initialize validatorFactory to a default implementation or null\n        this.validatorFactory = new DefaultValidatorFactory();\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value=StrutsConstants.STRUTS_OBJECT_FACTORY_CLASSLOADER, required=false)\n    public void setClassLoader(ClassLoader cl) {\n        this.ccl = cl;\n    }\n\n    @Inject\n    public void setActionFactory(ActionFactory actionFactory) {\n        this.actionFactory = actionFactory;\n    }\n\n    @Inject\n    public void setResultFactory(ResultFactory resultFactory) {\n        this.resultFactory = resultFactory;\n    }\n\n    @Inject\n    public void setInterceptorFactory(InterceptorFactory interceptorFactory) {\n        this.interceptorFactory = interceptorFactory;\n    }\n\n    @Inject\n    public void setValidatorFactory(ValidatorFactory validatorFactory) {\n        this.validatorFactory = validatorFactory;\n    }\n\n    @Inject\n    public void setConverterFactory(ConverterFactory converterFactory) {\n        this.converterFactory = converterFactory;\n    }\n\n    @Inject\n    public void setUnknownHandlerFactory(UnknownHandlerFactory unknownHandlerFactory) {\n        this.unknownHandlerFactory = unknownHandlerFactory;\n    }\n\n    /**\n     * Allows for ObjectFactory implementations that support\n     * Actions without no-arg constructors.\n     *\n     * @return true if no-arg constructor is required, false otherwise\n     */\n    public boolean isNoArgConstructorRequired() {\n        return true;\n    }\n\n    /**\n     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n     * lookups will be faster.\n     *\n     * @param className The fully qualified name of the class to return\n     * @return The class itself\n     * @throws ClassNotFoundException if class not found in classpath\n     */\n    public Class getClassInstance(String className) throws ClassNotFoundException {\n        if (ccl != null) {\n            return ccl.loadClass(className);\n        }\n\n        return ClassLoaderUtil.loadClass(className, this.getClass());\n    }\n\n    /**\n     * Build an instance of the action class to handle a particular request (eg. web request)\n     * @param actionName the name the action configuration is set up with in the configuration\n     * @param namespace the namespace the action is configured in\n     * @param config the action configuration found in the config for the actionName / namespace\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of the action class to handle a web request\n     * @throws Exception in case of any error\n     */\n    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n        return actionFactory.buildAction(actionName, namespace, config, extraContext);\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param clazz the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n        return container.inject(clazz);\n    }\n\n    /**\n     * @param obj object to inject internal\n     * @return the object\n     */\n    protected Object injectInternalBeans(Object obj) {\n        if (obj != null && container != null) {\n            LOG.debug(\"Injecting internal beans into [{}]\", obj.getClass().getSimpleName());\n            container.inject(obj);\n        }\n        return obj;\n    }\n\n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n        return buildBean(className, extraContext, true);\n    }\n    \n    /**\n     * Build a generic Java object of the given type.\n     *\n     * @param className the type of Object to build\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @param injectInternal true if inject internal beans\n     * @return object for the given type\n     * @throws Exception in case of any error\n     */\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n        Class clazz = getClassInstance(className);\n        return buildBean(clazz, extraContext);\n    }\n\n    /**\n     * Builds an Interceptor from the InterceptorConfig and the Map of\n     * parameters from the interceptor reference. Implementations of this method\n     * should ensure that the Interceptor is parametrized with both the\n     * parameters from the Interceptor config and the interceptor ref Map (the\n     * interceptor ref params take precedence), and that the Interceptor.init()\n     * method is called on the Interceptor instance before it is returned.\n     *\n     * @param interceptorConfig    the InterceptorConfig from the configuration\n     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n     *                             Action mapping or InterceptorStack definition\n     * @return interceptor\n     */\n    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n        return interceptorFactory.buildInterceptor(interceptorConfig, interceptorRefParams);\n    }\n\n    /**\n     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n     *\n     * @param resultConfig the ResultConfig found for the action with the result code returned\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return result\n     * @throws Exception in case of any error\n     */\n    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n        return resultFactory.buildResult(resultConfig, extraContext);\n    }\n\n    /**\n     * Build a Validator of the given type and set the parameters on it\n     *\n     * @param className the type of Validator to build\n     * @param params    property name -&gt; value Map to set onto the Validator instance\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     *\n     * @return validator of the given type\n     * @throws Exception in case of any error\n     */\n    public Validator buildValidator(String className, Map<String, Object> params, Map<String, Object> extraContext) throws Exception {\n        return validatorFactory.buildValidator(className, params, extraContext);\n    }\n\n    /**\n     * Build converter of given type\n     *\n     * @param converterClass to instantiate\n     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n     * @return instance of converterClass with inject dependencies\n     * @throws Exception in case of any error\n     */\n    public TypeConverter buildConverter(Class<? extends TypeConverter> converterClass, Map<String, Object> extraContext) throws Exception {\n        return converterFactory.buildConverter(converterClass, extraContext);\n    }\n\n    /**\n     * Builds unknown handler\n     *\n     * @param unknownHandlerName the unknown handler name\n     * @param extraContext extra context\n     * @return a unknown handler\n     * @throws Exception in case of any error\n     */\n    public UnknownHandler buildUnknownHandler(String unknownHandlerName, Map<String, Object> extraContext) throws Exception {\n        return unknownHandlerFactory.buildUnknownHandler(unknownHandlerName, extraContext);\n    }\n    \n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.TextProviderSupport.getTexts() may expose internal representation by returning TextProviderSupport.bundle",
        "fileName": "com/opensymphony/xwork2/TextProviderSupport.java",
        "methodStartLineNumber": 324,
        "methodEndLineNumber": 329,
        "warning_type": "EI_EXPOSE_REP",
        "codeSnippet": "    public ResourceBundle getTexts() {\n        if (clazz != null) {\n            return getTexts(clazz.getName());\n        }\n        return bundle;\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 329,
        "classCode": "     */\n    public TextProviderSupport(Class clazz, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.clazz = clazz;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param bundle   the resource bundle.\n     * @param provider a locale provider.\n     */\n    public TextProviderSupport(ResourceBundle bundle, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.bundle = bundle;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * @param bundle the resource bundle.\n     */\n    @Override\n    public void setBundle(ResourceBundle bundle) {\n        this.bundle = bundle;\n    }\n\n    /**\n     * @param clazz a clazz to use for reading the resource bundle.\n     */\n    @Override\n    public void setClazz(Class clazz) {\n        this.clazz = clazz;\n    }\n\n    /**\n     * @param localeProvider a locale provider.\n     */\n    @Override\n    public void setLocaleProvider(LocaleProvider localeProvider) {\n        this.localeProvider = localeProvider;\n    }\n\n    @Inject\n    public void setLocaleProviderFactory(LocaleProviderFactory localeProviderFactory) {\n        this.localeProvider = localeProviderFactory.createLocaleProvider();\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * Checks if a key is available in the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class.\n     */\n    public boolean hasKey(String key) {\n    \tString message;\n    \tif (clazz != null) {\n            message = localizedTextProvider.findText(clazz, key, getLocale(), null, new Object[0] );\n        } else {\n            message = localizedTextProvider.findText(bundle, key, getLocale(), null, new Object[0]);\n        }\n    \treturn message != null;\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class.\n     *\n     * @param key name of text to be found\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key) {\n        return getText(key, key, Collections.emptyList());\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue) {\n        return getText(key, defaultValue, Collections.emptyList());\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, String arg) {\n        List<Object> args = new ArrayList<>();\n        args.add(arg);\n        return getText(key, defaultValue, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key name of text to be found\n     * @param args      a List of args to be used in a MessageFormat message\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key, List<?> args) {\n        return getText(key, key, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key name of text to be found\n     * @param args      an array of args to be used in a MessageFormat message\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key, String[] args) {\n        return getText(key, key, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @param args         a List of args to be used in a MessageFormat message\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, List<?> args) {\n        Object[] argsArray = ((args != null && !args.equals(Collections.emptyList())) ? args.toArray() : null);\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, getLocale(), defaultValue, argsArray);\n        } else {\n            return localizedTextProvider.findText(bundle, key, getLocale(), defaultValue, argsArray);\n        }\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key          name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @param args         an array of args to be used in a MessageFormat message\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, String[] args) {\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, getLocale(), defaultValue, args);\n        } else {\n            return localizedTextProvider.findText(bundle, key, getLocale(), defaultValue, args);\n        }\n    }\n\n    /**\n     * Gets a message based on a key using the supplied args, as defined in\n     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n     * default value is returned. Instead of using the value stack in the ActionContext\n     * this version of the getText() method uses the provided value stack.\n     *\n     * @param key    the resource bundle key that is to be searched for\n     * @param defaultValue the default value which will be returned if no message is found\n     * @param args         a list args to be used in a {@link java.text.MessageFormat} message\n     * @param stack        the value stack to use for finding the text\n     * @return the message as found in the resource bundle, or defaultValue if none is found\n     */\n    public String getText(String key, String defaultValue, List<?> args, ValueStack stack) {\n        Object[] argsArray = ((args != null) ? args.toArray() : null);\n        Locale locale;\n        if (stack == null){\n        \tlocale = getLocale();\n        }else{\n        \tlocale = stack.getActionContext().getLocale();\n        }\n        if (locale == null) {\n            locale = getLocale();\n        }\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, locale, defaultValue, argsArray, stack);\n        } else {\n            return localizedTextProvider.findText(bundle, key, locale, defaultValue, argsArray, stack);\n        }\n    }\n\n\n    /**\n     * Gets a message based on a key using the supplied args, as defined in\n     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n     * default value is returned. Instead of using the value stack in the ActionContext\n     * this version of the getText() method uses the provided value stack.\n     *\n     * @param key          the resource bundle key that is to be searched for\n     * @param defaultValue the default value which will be returned if no message is found\n     * @param args         an array args to be used in a {@link java.text.MessageFormat} message\n     * @param stack        the value stack to use for finding the text\n     * @return the message as found in the resource bundle, or defaultValue if none is found\n     */\n    public String getText(String key, String defaultValue, String[] args, ValueStack stack) {\n        Locale locale;\n        if (stack == null){\n        \tlocale = getLocale();\n        }else{\n        \tlocale = stack.getActionContext().getLocale();\n        }\n        if (locale == null) {\n            locale = getLocale();\n        }\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, locale, defaultValue, args, stack);\n        } else {\n            return localizedTextProvider.findText(bundle, key, locale, defaultValue, args, stack);\n        }\n\n    }\n\n    /**\n     * Get the named bundle.\n     *\n     * <p>\n     * You can override the getLocale() methodName to change the behaviour of how\n     * to choose locale for the bundles that are returned. Typically you would\n     * use the TextProvider interface to get the users configured locale, or use\n     * your own methodName to allow the user to select the locale and store it in\n     * the session (by using the SessionAware interface).\n     * </p>\n     *\n     * @param aBundleName bundle name\n     * @return a resource bundle\n     */\n    public ResourceBundle getTexts(String aBundleName) {\n        return localizedTextProvider.findResourceBundle(aBundleName, getLocale());\n    }\n\n    /**\n     * Get the resource bundle associated with this action.\n     * This will be based on the actual subclass that is used.\n     *\n     * @return resouce bundle\n     */\n    public ResourceBundle getTexts() {\n        if (clazz != null) {\n            return getTexts(clazz.getName());\n        }\n        return bundle;\n    }\n",
        "compositeId": "com.opensymphony.xwork2.TextProviderSupport.getTexts() may expose internal representation by returning TextProviderSupport.bundle-com/opensymphony/xwork2/TextProviderSupport.java",
        "classSize": 286
    },
    {
        "explanation": "new com.opensymphony.xwork2.TextProviderSupport(Class, LocaleProvider, LocalizedTextProvider) may expose internal representation by storing an externally mutable object into TextProviderSupport.localizedTextProvider",
        "fileName": "com/opensymphony/xwork2/TextProviderSupport.java",
        "methodStartLineNumber": 44,
        "methodEndLineNumber": 50,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "     */\n    public TextProviderSupport(Class clazz, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.clazz = clazz;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 329,
        "classCode": "     */\n    public TextProviderSupport(Class clazz, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.clazz = clazz;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param bundle   the resource bundle.\n     * @param provider a locale provider.\n     */\n    public TextProviderSupport(ResourceBundle bundle, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.bundle = bundle;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * @param bundle the resource bundle.\n     */\n    @Override\n    public void setBundle(ResourceBundle bundle) {\n        this.bundle = bundle;\n    }\n\n    /**\n     * @param clazz a clazz to use for reading the resource bundle.\n     */\n    @Override\n    public void setClazz(Class clazz) {\n        this.clazz = clazz;\n    }\n\n    /**\n     * @param localeProvider a locale provider.\n     */\n    @Override\n    public void setLocaleProvider(LocaleProvider localeProvider) {\n        this.localeProvider = localeProvider;\n    }\n\n    @Inject\n    public void setLocaleProviderFactory(LocaleProviderFactory localeProviderFactory) {\n        this.localeProvider = localeProviderFactory.createLocaleProvider();\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * Checks if a key is available in the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class.\n     */\n    public boolean hasKey(String key) {\n    \tString message;\n    \tif (clazz != null) {\n            message = localizedTextProvider.findText(clazz, key, getLocale(), null, new Object[0] );\n        } else {\n            message = localizedTextProvider.findText(bundle, key, getLocale(), null, new Object[0]);\n        }\n    \treturn message != null;\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class.\n     *\n     * @param key name of text to be found\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key) {\n        return getText(key, key, Collections.emptyList());\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue) {\n        return getText(key, defaultValue, Collections.emptyList());\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, String arg) {\n        List<Object> args = new ArrayList<>();\n        args.add(arg);\n        return getText(key, defaultValue, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key name of text to be found\n     * @param args      a List of args to be used in a MessageFormat message\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key, List<?> args) {\n        return getText(key, key, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key name of text to be found\n     * @param args      an array of args to be used in a MessageFormat message\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key, String[] args) {\n        return getText(key, key, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @param args         a List of args to be used in a MessageFormat message\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, List<?> args) {\n        Object[] argsArray = ((args != null && !args.equals(Collections.emptyList())) ? args.toArray() : null);\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, getLocale(), defaultValue, argsArray);\n        } else {\n            return localizedTextProvider.findText(bundle, key, getLocale(), defaultValue, argsArray);\n        }\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key          name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @param args         an array of args to be used in a MessageFormat message\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, String[] args) {\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, getLocale(), defaultValue, args);\n        } else {\n            return localizedTextProvider.findText(bundle, key, getLocale(), defaultValue, args);\n        }\n    }\n\n    /**\n     * Gets a message based on a key using the supplied args, as defined in\n     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n     * default value is returned. Instead of using the value stack in the ActionContext\n     * this version of the getText() method uses the provided value stack.\n     *\n     * @param key    the resource bundle key that is to be searched for\n     * @param defaultValue the default value which will be returned if no message is found\n     * @param args         a list args to be used in a {@link java.text.MessageFormat} message\n     * @param stack        the value stack to use for finding the text\n     * @return the message as found in the resource bundle, or defaultValue if none is found\n     */\n    public String getText(String key, String defaultValue, List<?> args, ValueStack stack) {\n        Object[] argsArray = ((args != null) ? args.toArray() : null);\n        Locale locale;\n        if (stack == null){\n        \tlocale = getLocale();\n        }else{\n        \tlocale = stack.getActionContext().getLocale();\n        }\n        if (locale == null) {\n            locale = getLocale();\n        }\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, locale, defaultValue, argsArray, stack);\n        } else {\n            return localizedTextProvider.findText(bundle, key, locale, defaultValue, argsArray, stack);\n        }\n    }\n\n\n    /**\n     * Gets a message based on a key using the supplied args, as defined in\n     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n     * default value is returned. Instead of using the value stack in the ActionContext\n     * this version of the getText() method uses the provided value stack.\n     *\n     * @param key          the resource bundle key that is to be searched for\n     * @param defaultValue the default value which will be returned if no message is found\n     * @param args         an array args to be used in a {@link java.text.MessageFormat} message\n     * @param stack        the value stack to use for finding the text\n     * @return the message as found in the resource bundle, or defaultValue if none is found\n     */\n    public String getText(String key, String defaultValue, String[] args, ValueStack stack) {\n        Locale locale;\n        if (stack == null){\n        \tlocale = getLocale();\n        }else{\n        \tlocale = stack.getActionContext().getLocale();\n        }\n        if (locale == null) {\n            locale = getLocale();\n        }\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, locale, defaultValue, args, stack);\n        } else {\n            return localizedTextProvider.findText(bundle, key, locale, defaultValue, args, stack);\n        }\n\n    }\n\n    /**\n     * Get the named bundle.\n     *\n     * <p>\n     * You can override the getLocale() methodName to change the behaviour of how\n     * to choose locale for the bundles that are returned. Typically you would\n     * use the TextProvider interface to get the users configured locale, or use\n     * your own methodName to allow the user to select the locale and store it in\n     * the session (by using the SessionAware interface).\n     * </p>\n     *\n     * @param aBundleName bundle name\n     * @return a resource bundle\n     */\n    public ResourceBundle getTexts(String aBundleName) {\n        return localizedTextProvider.findResourceBundle(aBundleName, getLocale());\n    }\n\n    /**\n     * Get the resource bundle associated with this action.\n     * This will be based on the actual subclass that is used.\n     *\n     * @return resouce bundle\n     */\n    public ResourceBundle getTexts() {\n        if (clazz != null) {\n            return getTexts(clazz.getName());\n        }\n        return bundle;\n    }\n",
        "compositeId": "new com.opensymphony.xwork2.TextProviderSupport(Class, LocaleProvider, LocalizedTextProvider) may expose internal representation by storing an externally mutable object into TextProviderSupport.localizedTextProvider-com/opensymphony/xwork2/TextProviderSupport.java",
        "classSize": 286
    },
    {
        "explanation": "new com.opensymphony.xwork2.TextProviderSupport(ResourceBundle, LocaleProvider, LocalizedTextProvider) may expose internal representation by storing an externally mutable object into TextProviderSupport.bundle",
        "fileName": "com/opensymphony/xwork2/TextProviderSupport.java",
        "methodStartLineNumber": 56,
        "methodEndLineNumber": 62,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "     */\n    public TextProviderSupport(ResourceBundle bundle, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.bundle = bundle;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 329,
        "classCode": "     */\n    public TextProviderSupport(Class clazz, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.clazz = clazz;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param bundle   the resource bundle.\n     * @param provider a locale provider.\n     */\n    public TextProviderSupport(ResourceBundle bundle, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.bundle = bundle;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * @param bundle the resource bundle.\n     */\n    @Override\n    public void setBundle(ResourceBundle bundle) {\n        this.bundle = bundle;\n    }\n\n    /**\n     * @param clazz a clazz to use for reading the resource bundle.\n     */\n    @Override\n    public void setClazz(Class clazz) {\n        this.clazz = clazz;\n    }\n\n    /**\n     * @param localeProvider a locale provider.\n     */\n    @Override\n    public void setLocaleProvider(LocaleProvider localeProvider) {\n        this.localeProvider = localeProvider;\n    }\n\n    @Inject\n    public void setLocaleProviderFactory(LocaleProviderFactory localeProviderFactory) {\n        this.localeProvider = localeProviderFactory.createLocaleProvider();\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * Checks if a key is available in the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class.\n     */\n    public boolean hasKey(String key) {\n    \tString message;\n    \tif (clazz != null) {\n            message = localizedTextProvider.findText(clazz, key, getLocale(), null, new Object[0] );\n        } else {\n            message = localizedTextProvider.findText(bundle, key, getLocale(), null, new Object[0]);\n        }\n    \treturn message != null;\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class.\n     *\n     * @param key name of text to be found\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key) {\n        return getText(key, key, Collections.emptyList());\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue) {\n        return getText(key, defaultValue, Collections.emptyList());\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, String arg) {\n        List<Object> args = new ArrayList<>();\n        args.add(arg);\n        return getText(key, defaultValue, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key name of text to be found\n     * @param args      a List of args to be used in a MessageFormat message\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key, List<?> args) {\n        return getText(key, key, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key name of text to be found\n     * @param args      an array of args to be used in a MessageFormat message\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key, String[] args) {\n        return getText(key, key, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @param args         a List of args to be used in a MessageFormat message\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, List<?> args) {\n        Object[] argsArray = ((args != null && !args.equals(Collections.emptyList())) ? args.toArray() : null);\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, getLocale(), defaultValue, argsArray);\n        } else {\n            return localizedTextProvider.findText(bundle, key, getLocale(), defaultValue, argsArray);\n        }\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key          name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @param args         an array of args to be used in a MessageFormat message\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, String[] args) {\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, getLocale(), defaultValue, args);\n        } else {\n            return localizedTextProvider.findText(bundle, key, getLocale(), defaultValue, args);\n        }\n    }\n\n    /**\n     * Gets a message based on a key using the supplied args, as defined in\n     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n     * default value is returned. Instead of using the value stack in the ActionContext\n     * this version of the getText() method uses the provided value stack.\n     *\n     * @param key    the resource bundle key that is to be searched for\n     * @param defaultValue the default value which will be returned if no message is found\n     * @param args         a list args to be used in a {@link java.text.MessageFormat} message\n     * @param stack        the value stack to use for finding the text\n     * @return the message as found in the resource bundle, or defaultValue if none is found\n     */\n    public String getText(String key, String defaultValue, List<?> args, ValueStack stack) {\n        Object[] argsArray = ((args != null) ? args.toArray() : null);\n        Locale locale;\n        if (stack == null){\n        \tlocale = getLocale();\n        }else{\n        \tlocale = stack.getActionContext().getLocale();\n        }\n        if (locale == null) {\n            locale = getLocale();\n        }\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, locale, defaultValue, argsArray, stack);\n        } else {\n            return localizedTextProvider.findText(bundle, key, locale, defaultValue, argsArray, stack);\n        }\n    }\n\n\n    /**\n     * Gets a message based on a key using the supplied args, as defined in\n     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n     * default value is returned. Instead of using the value stack in the ActionContext\n     * this version of the getText() method uses the provided value stack.\n     *\n     * @param key          the resource bundle key that is to be searched for\n     * @param defaultValue the default value which will be returned if no message is found\n     * @param args         an array args to be used in a {@link java.text.MessageFormat} message\n     * @param stack        the value stack to use for finding the text\n     * @return the message as found in the resource bundle, or defaultValue if none is found\n     */\n    public String getText(String key, String defaultValue, String[] args, ValueStack stack) {\n        Locale locale;\n        if (stack == null){\n        \tlocale = getLocale();\n        }else{\n        \tlocale = stack.getActionContext().getLocale();\n        }\n        if (locale == null) {\n            locale = getLocale();\n        }\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, locale, defaultValue, args, stack);\n        } else {\n            return localizedTextProvider.findText(bundle, key, locale, defaultValue, args, stack);\n        }\n\n    }\n\n    /**\n     * Get the named bundle.\n     *\n     * <p>\n     * You can override the getLocale() methodName to change the behaviour of how\n     * to choose locale for the bundles that are returned. Typically you would\n     * use the TextProvider interface to get the users configured locale, or use\n     * your own methodName to allow the user to select the locale and store it in\n     * the session (by using the SessionAware interface).\n     * </p>\n     *\n     * @param aBundleName bundle name\n     * @return a resource bundle\n     */\n    public ResourceBundle getTexts(String aBundleName) {\n        return localizedTextProvider.findResourceBundle(aBundleName, getLocale());\n    }\n\n    /**\n     * Get the resource bundle associated with this action.\n     * This will be based on the actual subclass that is used.\n     *\n     * @return resouce bundle\n     */\n    public ResourceBundle getTexts() {\n        if (clazz != null) {\n            return getTexts(clazz.getName());\n        }\n        return bundle;\n    }\n",
        "compositeId": "new com.opensymphony.xwork2.TextProviderSupport(ResourceBundle, LocaleProvider, LocalizedTextProvider) may expose internal representation by storing an externally mutable object into TextProviderSupport.bundle-com/opensymphony/xwork2/TextProviderSupport.java",
        "classSize": 286
    },
    {
        "explanation": "new com.opensymphony.xwork2.TextProviderSupport(ResourceBundle, LocaleProvider, LocalizedTextProvider) may expose internal representation by storing an externally mutable object into TextProviderSupport.localizedTextProvider",
        "fileName": "com/opensymphony/xwork2/TextProviderSupport.java",
        "methodStartLineNumber": 56,
        "methodEndLineNumber": 62,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "     */\n    public TextProviderSupport(ResourceBundle bundle, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.bundle = bundle;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 329,
        "classCode": "     */\n    public TextProviderSupport(Class clazz, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.clazz = clazz;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param bundle   the resource bundle.\n     * @param provider a locale provider.\n     */\n    public TextProviderSupport(ResourceBundle bundle, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.bundle = bundle;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * @param bundle the resource bundle.\n     */\n    @Override\n    public void setBundle(ResourceBundle bundle) {\n        this.bundle = bundle;\n    }\n\n    /**\n     * @param clazz a clazz to use for reading the resource bundle.\n     */\n    @Override\n    public void setClazz(Class clazz) {\n        this.clazz = clazz;\n    }\n\n    /**\n     * @param localeProvider a locale provider.\n     */\n    @Override\n    public void setLocaleProvider(LocaleProvider localeProvider) {\n        this.localeProvider = localeProvider;\n    }\n\n    @Inject\n    public void setLocaleProviderFactory(LocaleProviderFactory localeProviderFactory) {\n        this.localeProvider = localeProviderFactory.createLocaleProvider();\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * Checks if a key is available in the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class.\n     */\n    public boolean hasKey(String key) {\n    \tString message;\n    \tif (clazz != null) {\n            message = localizedTextProvider.findText(clazz, key, getLocale(), null, new Object[0] );\n        } else {\n            message = localizedTextProvider.findText(bundle, key, getLocale(), null, new Object[0]);\n        }\n    \treturn message != null;\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class.\n     *\n     * @param key name of text to be found\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key) {\n        return getText(key, key, Collections.emptyList());\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue) {\n        return getText(key, defaultValue, Collections.emptyList());\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, String arg) {\n        List<Object> args = new ArrayList<>();\n        args.add(arg);\n        return getText(key, defaultValue, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key name of text to be found\n     * @param args      a List of args to be used in a MessageFormat message\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key, List<?> args) {\n        return getText(key, key, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key name of text to be found\n     * @param args      an array of args to be used in a MessageFormat message\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key, String[] args) {\n        return getText(key, key, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @param args         a List of args to be used in a MessageFormat message\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, List<?> args) {\n        Object[] argsArray = ((args != null && !args.equals(Collections.emptyList())) ? args.toArray() : null);\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, getLocale(), defaultValue, argsArray);\n        } else {\n            return localizedTextProvider.findText(bundle, key, getLocale(), defaultValue, argsArray);\n        }\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key          name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @param args         an array of args to be used in a MessageFormat message\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, String[] args) {\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, getLocale(), defaultValue, args);\n        } else {\n            return localizedTextProvider.findText(bundle, key, getLocale(), defaultValue, args);\n        }\n    }\n\n    /**\n     * Gets a message based on a key using the supplied args, as defined in\n     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n     * default value is returned. Instead of using the value stack in the ActionContext\n     * this version of the getText() method uses the provided value stack.\n     *\n     * @param key    the resource bundle key that is to be searched for\n     * @param defaultValue the default value which will be returned if no message is found\n     * @param args         a list args to be used in a {@link java.text.MessageFormat} message\n     * @param stack        the value stack to use for finding the text\n     * @return the message as found in the resource bundle, or defaultValue if none is found\n     */\n    public String getText(String key, String defaultValue, List<?> args, ValueStack stack) {\n        Object[] argsArray = ((args != null) ? args.toArray() : null);\n        Locale locale;\n        if (stack == null){\n        \tlocale = getLocale();\n        }else{\n        \tlocale = stack.getActionContext().getLocale();\n        }\n        if (locale == null) {\n            locale = getLocale();\n        }\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, locale, defaultValue, argsArray, stack);\n        } else {\n            return localizedTextProvider.findText(bundle, key, locale, defaultValue, argsArray, stack);\n        }\n    }\n\n\n    /**\n     * Gets a message based on a key using the supplied args, as defined in\n     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n     * default value is returned. Instead of using the value stack in the ActionContext\n     * this version of the getText() method uses the provided value stack.\n     *\n     * @param key          the resource bundle key that is to be searched for\n     * @param defaultValue the default value which will be returned if no message is found\n     * @param args         an array args to be used in a {@link java.text.MessageFormat} message\n     * @param stack        the value stack to use for finding the text\n     * @return the message as found in the resource bundle, or defaultValue if none is found\n     */\n    public String getText(String key, String defaultValue, String[] args, ValueStack stack) {\n        Locale locale;\n        if (stack == null){\n        \tlocale = getLocale();\n        }else{\n        \tlocale = stack.getActionContext().getLocale();\n        }\n        if (locale == null) {\n            locale = getLocale();\n        }\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, locale, defaultValue, args, stack);\n        } else {\n            return localizedTextProvider.findText(bundle, key, locale, defaultValue, args, stack);\n        }\n\n    }\n\n    /**\n     * Get the named bundle.\n     *\n     * <p>\n     * You can override the getLocale() methodName to change the behaviour of how\n     * to choose locale for the bundles that are returned. Typically you would\n     * use the TextProvider interface to get the users configured locale, or use\n     * your own methodName to allow the user to select the locale and store it in\n     * the session (by using the SessionAware interface).\n     * </p>\n     *\n     * @param aBundleName bundle name\n     * @return a resource bundle\n     */\n    public ResourceBundle getTexts(String aBundleName) {\n        return localizedTextProvider.findResourceBundle(aBundleName, getLocale());\n    }\n\n    /**\n     * Get the resource bundle associated with this action.\n     * This will be based on the actual subclass that is used.\n     *\n     * @return resouce bundle\n     */\n    public ResourceBundle getTexts() {\n        if (clazz != null) {\n            return getTexts(clazz.getName());\n        }\n        return bundle;\n    }\n",
        "compositeId": "new com.opensymphony.xwork2.TextProviderSupport(ResourceBundle, LocaleProvider, LocalizedTextProvider) may expose internal representation by storing an externally mutable object into TextProviderSupport.localizedTextProvider-com/opensymphony/xwork2/TextProviderSupport.java",
        "classSize": 286
    },
    {
        "explanation": "com.opensymphony.xwork2.TextProviderSupport.setBundle(ResourceBundle) may expose internal representation by storing an externally mutable object into TextProviderSupport.bundle",
        "fileName": "com/opensymphony/xwork2/TextProviderSupport.java",
        "methodStartLineNumber": 67,
        "methodEndLineNumber": 70,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setBundle(ResourceBundle bundle) {\n        this.bundle = bundle;\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 329,
        "classCode": "     */\n    public TextProviderSupport(Class clazz, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.clazz = clazz;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param bundle   the resource bundle.\n     * @param provider a locale provider.\n     */\n    public TextProviderSupport(ResourceBundle bundle, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.bundle = bundle;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * @param bundle the resource bundle.\n     */\n    @Override\n    public void setBundle(ResourceBundle bundle) {\n        this.bundle = bundle;\n    }\n\n    /**\n     * @param clazz a clazz to use for reading the resource bundle.\n     */\n    @Override\n    public void setClazz(Class clazz) {\n        this.clazz = clazz;\n    }\n\n    /**\n     * @param localeProvider a locale provider.\n     */\n    @Override\n    public void setLocaleProvider(LocaleProvider localeProvider) {\n        this.localeProvider = localeProvider;\n    }\n\n    @Inject\n    public void setLocaleProviderFactory(LocaleProviderFactory localeProviderFactory) {\n        this.localeProvider = localeProviderFactory.createLocaleProvider();\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * Checks if a key is available in the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class.\n     */\n    public boolean hasKey(String key) {\n    \tString message;\n    \tif (clazz != null) {\n            message = localizedTextProvider.findText(clazz, key, getLocale(), null, new Object[0] );\n        } else {\n            message = localizedTextProvider.findText(bundle, key, getLocale(), null, new Object[0]);\n        }\n    \treturn message != null;\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class.\n     *\n     * @param key name of text to be found\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key) {\n        return getText(key, key, Collections.emptyList());\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue) {\n        return getText(key, defaultValue, Collections.emptyList());\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, String arg) {\n        List<Object> args = new ArrayList<>();\n        args.add(arg);\n        return getText(key, defaultValue, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key name of text to be found\n     * @param args      a List of args to be used in a MessageFormat message\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key, List<?> args) {\n        return getText(key, key, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key name of text to be found\n     * @param args      an array of args to be used in a MessageFormat message\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key, String[] args) {\n        return getText(key, key, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @param args         a List of args to be used in a MessageFormat message\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, List<?> args) {\n        Object[] argsArray = ((args != null && !args.equals(Collections.emptyList())) ? args.toArray() : null);\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, getLocale(), defaultValue, argsArray);\n        } else {\n            return localizedTextProvider.findText(bundle, key, getLocale(), defaultValue, argsArray);\n        }\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key          name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @param args         an array of args to be used in a MessageFormat message\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, String[] args) {\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, getLocale(), defaultValue, args);\n        } else {\n            return localizedTextProvider.findText(bundle, key, getLocale(), defaultValue, args);\n        }\n    }\n\n    /**\n     * Gets a message based on a key using the supplied args, as defined in\n     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n     * default value is returned. Instead of using the value stack in the ActionContext\n     * this version of the getText() method uses the provided value stack.\n     *\n     * @param key    the resource bundle key that is to be searched for\n     * @param defaultValue the default value which will be returned if no message is found\n     * @param args         a list args to be used in a {@link java.text.MessageFormat} message\n     * @param stack        the value stack to use for finding the text\n     * @return the message as found in the resource bundle, or defaultValue if none is found\n     */\n    public String getText(String key, String defaultValue, List<?> args, ValueStack stack) {\n        Object[] argsArray = ((args != null) ? args.toArray() : null);\n        Locale locale;\n        if (stack == null){\n        \tlocale = getLocale();\n        }else{\n        \tlocale = stack.getActionContext().getLocale();\n        }\n        if (locale == null) {\n            locale = getLocale();\n        }\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, locale, defaultValue, argsArray, stack);\n        } else {\n            return localizedTextProvider.findText(bundle, key, locale, defaultValue, argsArray, stack);\n        }\n    }\n\n\n    /**\n     * Gets a message based on a key using the supplied args, as defined in\n     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n     * default value is returned. Instead of using the value stack in the ActionContext\n     * this version of the getText() method uses the provided value stack.\n     *\n     * @param key          the resource bundle key that is to be searched for\n     * @param defaultValue the default value which will be returned if no message is found\n     * @param args         an array args to be used in a {@link java.text.MessageFormat} message\n     * @param stack        the value stack to use for finding the text\n     * @return the message as found in the resource bundle, or defaultValue if none is found\n     */\n    public String getText(String key, String defaultValue, String[] args, ValueStack stack) {\n        Locale locale;\n        if (stack == null){\n        \tlocale = getLocale();\n        }else{\n        \tlocale = stack.getActionContext().getLocale();\n        }\n        if (locale == null) {\n            locale = getLocale();\n        }\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, locale, defaultValue, args, stack);\n        } else {\n            return localizedTextProvider.findText(bundle, key, locale, defaultValue, args, stack);\n        }\n\n    }\n\n    /**\n     * Get the named bundle.\n     *\n     * <p>\n     * You can override the getLocale() methodName to change the behaviour of how\n     * to choose locale for the bundles that are returned. Typically you would\n     * use the TextProvider interface to get the users configured locale, or use\n     * your own methodName to allow the user to select the locale and store it in\n     * the session (by using the SessionAware interface).\n     * </p>\n     *\n     * @param aBundleName bundle name\n     * @return a resource bundle\n     */\n    public ResourceBundle getTexts(String aBundleName) {\n        return localizedTextProvider.findResourceBundle(aBundleName, getLocale());\n    }\n\n    /**\n     * Get the resource bundle associated with this action.\n     * This will be based on the actual subclass that is used.\n     *\n     * @return resouce bundle\n     */\n    public ResourceBundle getTexts() {\n        if (clazz != null) {\n            return getTexts(clazz.getName());\n        }\n        return bundle;\n    }\n",
        "compositeId": "com.opensymphony.xwork2.TextProviderSupport.setBundle(ResourceBundle) may expose internal representation by storing an externally mutable object into TextProviderSupport.bundle-com/opensymphony/xwork2/TextProviderSupport.java",
        "classSize": 286
    },
    {
        "explanation": "com.opensymphony.xwork2.TextProviderSupport.setLocalizedTextProvider(LocalizedTextProvider) may expose internal representation by storing an externally mutable object into TextProviderSupport.localizedTextProvider",
        "fileName": "com/opensymphony/xwork2/TextProviderSupport.java",
        "methodStartLineNumber": 93,
        "methodEndLineNumber": 96,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 329,
        "classCode": "     */\n    public TextProviderSupport(Class clazz, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.clazz = clazz;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param bundle   the resource bundle.\n     * @param provider a locale provider.\n     */\n    public TextProviderSupport(ResourceBundle bundle, LocaleProvider provider, LocalizedTextProvider localizedTextProvider) {\n        this.bundle = bundle;\n        this.localeProvider = provider;\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * @param bundle the resource bundle.\n     */\n    @Override\n    public void setBundle(ResourceBundle bundle) {\n        this.bundle = bundle;\n    }\n\n    /**\n     * @param clazz a clazz to use for reading the resource bundle.\n     */\n    @Override\n    public void setClazz(Class clazz) {\n        this.clazz = clazz;\n    }\n\n    /**\n     * @param localeProvider a locale provider.\n     */\n    @Override\n    public void setLocaleProvider(LocaleProvider localeProvider) {\n        this.localeProvider = localeProvider;\n    }\n\n    @Inject\n    public void setLocaleProviderFactory(LocaleProviderFactory localeProviderFactory) {\n        this.localeProvider = localeProviderFactory.createLocaleProvider();\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    /**\n     * Checks if a key is available in the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class.\n     */\n    public boolean hasKey(String key) {\n    \tString message;\n    \tif (clazz != null) {\n            message = localizedTextProvider.findText(clazz, key, getLocale(), null, new Object[0] );\n        } else {\n            message = localizedTextProvider.findText(bundle, key, getLocale(), null, new Object[0]);\n        }\n    \treturn message != null;\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class.\n     *\n     * @param key name of text to be found\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key) {\n        return getText(key, key, Collections.emptyList());\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue) {\n        return getText(key, defaultValue, Collections.emptyList());\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, String arg) {\n        List<Object> args = new ArrayList<>();\n        args.add(arg);\n        return getText(key, defaultValue, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key name of text to be found\n     * @param args      a List of args to be used in a MessageFormat message\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key, List<?> args) {\n        return getText(key, key, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key name of text to be found\n     * @param args      an array of args to be used in a MessageFormat message\n     * @return value of named text or the provided key if no value is found\n     */\n    public String getText(String key, String[] args) {\n        return getText(key, key, args);\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key    name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @param args         a List of args to be used in a MessageFormat message\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, List<?> args) {\n        Object[] argsArray = ((args != null && !args.equals(Collections.emptyList())) ? args.toArray() : null);\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, getLocale(), defaultValue, argsArray);\n        } else {\n            return localizedTextProvider.findText(bundle, key, getLocale(), defaultValue, argsArray);\n        }\n    }\n\n    /**\n     * Get a text from the resource bundles associated with this action.\n     * The resource bundles are searched, starting with the one associated\n     * with this particular action, and testing all its superclasses' bundles.\n     * It will stop once a bundle is found that contains the given text. This gives\n     * a cascading style that allow global texts to be defined for an application base\n     * class. If no text is found for this text name, the default value is returned.\n     *\n     * @param key          name of text to be found\n     * @param defaultValue the default value which will be returned if no text is found\n     * @param args         an array of args to be used in a MessageFormat message\n     * @return value of named text or the provided defaultValue if no value is found\n     */\n    public String getText(String key, String defaultValue, String[] args) {\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, getLocale(), defaultValue, args);\n        } else {\n            return localizedTextProvider.findText(bundle, key, getLocale(), defaultValue, args);\n        }\n    }\n\n    /**\n     * Gets a message based on a key using the supplied args, as defined in\n     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n     * default value is returned. Instead of using the value stack in the ActionContext\n     * this version of the getText() method uses the provided value stack.\n     *\n     * @param key    the resource bundle key that is to be searched for\n     * @param defaultValue the default value which will be returned if no message is found\n     * @param args         a list args to be used in a {@link java.text.MessageFormat} message\n     * @param stack        the value stack to use for finding the text\n     * @return the message as found in the resource bundle, or defaultValue if none is found\n     */\n    public String getText(String key, String defaultValue, List<?> args, ValueStack stack) {\n        Object[] argsArray = ((args != null) ? args.toArray() : null);\n        Locale locale;\n        if (stack == null){\n        \tlocale = getLocale();\n        }else{\n        \tlocale = stack.getActionContext().getLocale();\n        }\n        if (locale == null) {\n            locale = getLocale();\n        }\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, locale, defaultValue, argsArray, stack);\n        } else {\n            return localizedTextProvider.findText(bundle, key, locale, defaultValue, argsArray, stack);\n        }\n    }\n\n\n    /**\n     * Gets a message based on a key using the supplied args, as defined in\n     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n     * default value is returned. Instead of using the value stack in the ActionContext\n     * this version of the getText() method uses the provided value stack.\n     *\n     * @param key          the resource bundle key that is to be searched for\n     * @param defaultValue the default value which will be returned if no message is found\n     * @param args         an array args to be used in a {@link java.text.MessageFormat} message\n     * @param stack        the value stack to use for finding the text\n     * @return the message as found in the resource bundle, or defaultValue if none is found\n     */\n    public String getText(String key, String defaultValue, String[] args, ValueStack stack) {\n        Locale locale;\n        if (stack == null){\n        \tlocale = getLocale();\n        }else{\n        \tlocale = stack.getActionContext().getLocale();\n        }\n        if (locale == null) {\n            locale = getLocale();\n        }\n        if (clazz != null) {\n            return localizedTextProvider.findText(clazz, key, locale, defaultValue, args, stack);\n        } else {\n            return localizedTextProvider.findText(bundle, key, locale, defaultValue, args, stack);\n        }\n\n    }\n\n    /**\n     * Get the named bundle.\n     *\n     * <p>\n     * You can override the getLocale() methodName to change the behaviour of how\n     * to choose locale for the bundles that are returned. Typically you would\n     * use the TextProvider interface to get the users configured locale, or use\n     * your own methodName to allow the user to select the locale and store it in\n     * the session (by using the SessionAware interface).\n     * </p>\n     *\n     * @param aBundleName bundle name\n     * @return a resource bundle\n     */\n    public ResourceBundle getTexts(String aBundleName) {\n        return localizedTextProvider.findResourceBundle(aBundleName, getLocale());\n    }\n\n    /**\n     * Get the resource bundle associated with this action.\n     * This will be based on the actual subclass that is used.\n     *\n     * @return resouce bundle\n     */\n    public ResourceBundle getTexts() {\n        if (clazz != null) {\n            return getTexts(clazz.getName());\n        }\n        return bundle;\n    }\n",
        "compositeId": "com.opensymphony.xwork2.TextProviderSupport.setLocalizedTextProvider(LocalizedTextProvider) may expose internal representation by storing an externally mutable object into TextProviderSupport.localizedTextProvider-com/opensymphony/xwork2/TextProviderSupport.java",
        "classSize": 286
    },
    {
        "explanation": "com.opensymphony.xwork2.config.impl.MockConfiguration.getContainer() may expose internal representation by returning MockConfiguration.container",
        "fileName": "com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "methodStartLineNumber": 103,
        "methodEndLineNumber": 105,
        "warning_type": "EI_EXPOSE_REP",
        "codeSnippet": "    public Container getContainer() {\n        return container;\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 125,
        "classCode": "public class MockConfiguration implements Configuration {\n\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    protected List<UnknownHandlerConfig> unknownHandlerStack;\n    private ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.config.impl.MockConfiguration.getContainer() may expose internal representation by returning MockConfiguration.container-com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "classSize": 82
    },
    {
        "explanation": "com.opensymphony.xwork2.config.impl.MockConfiguration.getLoadedFileNames() may expose internal representation by returning MockConfiguration.loadedFiles",
        "fileName": "com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "methodStartLineNumber": 107,
        "methodEndLineNumber": 109,
        "warning_type": "EI_EXPOSE_REP",
        "codeSnippet": "    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 125,
        "classCode": "public class MockConfiguration implements Configuration {\n\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    protected List<UnknownHandlerConfig> unknownHandlerStack;\n    private ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.config.impl.MockConfiguration.getLoadedFileNames() may expose internal representation by returning MockConfiguration.loadedFiles-com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "classSize": 82
    },
    {
        "explanation": "com.opensymphony.xwork2.config.impl.MockConfiguration.getPackageConfigs() may expose internal representation by returning MockConfiguration.packages",
        "fileName": "com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "methodStartLineNumber": 75,
        "methodEndLineNumber": 77,
        "warning_type": "EI_EXPOSE_REP",
        "codeSnippet": "    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 125,
        "classCode": "public class MockConfiguration implements Configuration {\n\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    protected List<UnknownHandlerConfig> unknownHandlerStack;\n    private ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.config.impl.MockConfiguration.getPackageConfigs() may expose internal representation by returning MockConfiguration.packages-com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "classSize": 82,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.config.impl;\n\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.ContainerProvider;\nimport com.opensymphony.xwork2.config.PackageProvider;\nimport com.opensymphony.xwork2.config.RuntimeConfiguration;\nimport com.opensymphony.xwork2.config.entities.PackageConfig;\nimport com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\nimport com.opensymphony.xwork2.config.providers.StrutsDefaultConfigurationProvider;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.ContainerBuilder;\nimport com.opensymphony.xwork2.inject.Scope;\nimport com.opensymphony.xwork2.util.location.LocatableProperties;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\n/**\n * Simple configuration used for unit testing\n */\npublic class MockConfiguration implements Configuration {\n\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    protected List<UnknownHandlerConfig> unknownHandlerStack;\n    private ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return new HashMap<>(packages);\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.config.impl.MockConfiguration.getUnknownHandlerStack() may expose internal representation by returning MockConfiguration.unknownHandlerStack",
        "fileName": "com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "methodStartLineNumber": 117,
        "methodEndLineNumber": 119,
        "warning_type": "EI_EXPOSE_REP",
        "codeSnippet": "    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 125,
        "classCode": "public class MockConfiguration implements Configuration {\n\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    protected List<UnknownHandlerConfig> unknownHandlerStack;\n    private ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.config.impl.MockConfiguration.getUnknownHandlerStack() may expose internal representation by returning MockConfiguration.unknownHandlerStack-com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "classSize": 82
    },
    {
        "explanation": "com.opensymphony.xwork2.config.impl.MockConfiguration.setUnknownHandlerStack(List) may expose internal representation by storing an externally mutable object into MockConfiguration.unknownHandlerStack",
        "fileName": "com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "methodStartLineNumber": 121,
        "methodEndLineNumber": 124,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 125,
        "classCode": "public class MockConfiguration implements Configuration {\n\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    protected List<UnknownHandlerConfig> unknownHandlerStack;\n    private ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.config.impl.MockConfiguration.setUnknownHandlerStack(List) may expose internal representation by storing an externally mutable object into MockConfiguration.unknownHandlerStack-com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "classSize": 82
    },
    {
        "explanation": "Class com.opensymphony.xwork2.config.impl.MockConfiguration defines non-transient non-serializable instance field builder",
        "fileName": "com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "methodStartLineNumber": 45,
        "methodEndLineNumber": 124,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    protected List<UnknownHandlerConfig> unknownHandlerStack;\n    private ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 125,
        "classCode": "public class MockConfiguration implements Configuration {\n\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    protected List<UnknownHandlerConfig> unknownHandlerStack;\n    private ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n\n}\n",
        "compositeId": "Class com.opensymphony.xwork2.config.impl.MockConfiguration defines non-transient non-serializable instance field builder-com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "classSize": 82,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.config.impl;\n\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.ContainerProvider;\nimport com.opensymphony.xwork2.config.PackageProvider;\nimport com.opensymphony.xwork2.config.RuntimeConfiguration;\nimport com.opensymphony.xwork2.config.entities.PackageConfig;\nimport com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\nimport com.opensymphony.xwork2.config.providers.StrutsDefaultConfigurationProvider;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.ContainerBuilder;\nimport com.opensymphony.xwork2.inject.Scope;\nimport com.opensymphony.xwork2.util.location.LocatableProperties;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\n/**\n * Simple configuration used for unit testing\n */\npublic class MockConfiguration implements Configuration {\n\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    protected List<UnknownHandlerConfig> unknownHandlerStack;\n    private transient ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n\n}\n"
    },
    {
        "explanation": "Class com.opensymphony.xwork2.config.impl.MockConfiguration defines non-transient non-serializable instance field unknownHandlerStack",
        "fileName": "com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "methodStartLineNumber": 45,
        "methodEndLineNumber": 124,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    protected List<UnknownHandlerConfig> unknownHandlerStack;\n    private ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 125,
        "classCode": "public class MockConfiguration implements Configuration {\n\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    protected List<UnknownHandlerConfig> unknownHandlerStack;\n    private ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n\n}\n",
        "compositeId": "Class com.opensymphony.xwork2.config.impl.MockConfiguration defines non-transient non-serializable instance field unknownHandlerStack-com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "classSize": 82,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.config.impl;\n\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.ContainerProvider;\nimport com.opensymphony.xwork2.config.PackageProvider;\nimport com.opensymphony.xwork2.config.RuntimeConfiguration;\nimport com.opensymphony.xwork2.config.entities.PackageConfig;\nimport com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\nimport com.opensymphony.xwork2.config.providers.StrutsDefaultConfigurationProvider;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.ContainerBuilder;\nimport com.opensymphony.xwork2.inject.Scope;\nimport com.opensymphony.xwork2.util.location.LocatableProperties;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\n/**\n * Simple configuration used for unit testing\n */\npublic class MockConfiguration implements Configuration {\n\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    private transient List<UnknownHandlerConfig> unknownHandlerStack;\n    private ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.config.impl.MockConfiguration is Serializable; consider declaring a serialVersionUID",
        "fileName": "com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "methodStartLineNumber": 45,
        "methodEndLineNumber": 124,
        "warning_type": "SE_NO_SERIALVERSIONID",
        "codeSnippet": "\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    protected List<UnknownHandlerConfig> unknownHandlerStack;\n    private ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 125,
        "classCode": "public class MockConfiguration implements Configuration {\n\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    protected List<UnknownHandlerConfig> unknownHandlerStack;\n    private ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.config.impl.MockConfiguration is Serializable; consider declaring a serialVersionUID-com/opensymphony/xwork2/config/impl/MockConfiguration.java",
        "classSize": 82,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.config.impl;\n\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.ContainerProvider;\nimport com.opensymphony.xwork2.config.PackageProvider;\nimport com.opensymphony.xwork2.config.RuntimeConfiguration;\nimport com.opensymphony.xwork2.config.entities.PackageConfig;\nimport com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\nimport com.opensymphony.xwork2.config.providers.StrutsDefaultConfigurationProvider;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.ContainerBuilder;\nimport com.opensymphony.xwork2.inject.Scope;\nimport com.opensymphony.xwork2.util.location.LocatableProperties;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\n/**\n * Simple configuration used for unit testing\n */\npublic class MockConfiguration implements Configuration, java.io.Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private Map<String, PackageConfig> packages = new HashMap<>();\n    private Set<String> loadedFiles = new HashSet<>();\n    private Container container;\n    protected List<UnknownHandlerConfig> unknownHandlerStack;\n    private ContainerBuilder builder;\n\n    public MockConfiguration() {\n        builder = new ContainerBuilder();\n    }\n\n    public void selfRegister() {\n        //this cannot be done in the constructor, as it causes an infinite loop\n        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n        LocatableProperties props = new LocatableProperties();\n        new StrutsDefaultConfigurationProvider().register(builder, props);\n        for (Map.Entry<String, Object> entry : DefaultConfiguration.BOOTSTRAP_CONSTANTS.entrySet()) {\n            builder.constant(entry.getKey(), String.valueOf(entry.getValue()));\n        }\n        container = builder.create(true);\n    }\n\n    public PackageConfig getPackageConfig(String name) {\n        return packages.get(name);\n    }\n\n    public Set<String> getPackageConfigNames() {\n        return packages.keySet();\n    }\n\n    public Map<String, PackageConfig> getPackageConfigs() {\n        return packages;\n    }\n\n    public RuntimeConfiguration getRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void addPackageConfig(String name, PackageConfig packageContext) {\n        packages.put(name, packageContext);\n    }\n\n    public void buildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException();\n    }\n\n    public void rebuildRuntimeConfiguration() {\n        throw new UnsupportedOperationException();\n    }\n\n    public PackageConfig removePackageConfig(String name) {\n        return packages.remove(name);\n    }\n\n    public Container getContainer() {\n        return container;\n    }\n\n    public Set<String> getLoadedFileNames() {\n        return loadedFiles;\n    }\n\n    public List<PackageProvider> reloadContainer(\n            List<ContainerProvider> containerProviders)\n            throws ConfigurationException {\n        throw new UnsupportedOperationException();\n    }\n\n    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n        return unknownHandlerStack;\n    }\n\n    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n        this.unknownHandlerStack = unknownHandlerStack;\n    }\n\n}\n"
    },
    {
        "explanation": "Exception thrown in class com.opensymphony.xwork2.inject.ContainerImpl$ConstructorInjector at new com.opensymphony.xwork2.inject.ContainerImpl$ConstructorInjector(ContainerImpl, Class) will leave the constructor. The object under construction remains partially initialized and may be vulnerable to Finalizer attacks.",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 322,
        "methodEndLineNumber": 359,
        "warning_type": "CT_CONSTRUCTOR_THROW",
        "codeSnippet": "\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n",
        "classStartLineNumber": 316,
        "classEndLineNumber": 445,
        "classCode": "    static class ConstructorInjector<T> {\n\n        final Class<T> implementation;\n        final List<Injector> injectors;\n        final Constructor<T> constructor;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n\n        ParameterInjector<?>[] constructParameterInjector(\n            Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n            return constructor.getParameterTypes().length == 0\n                ? null // default constructor.\n                : container.getParametersInjectors(\n                constructor,\n                constructor.getParameterAnnotations(),\n                constructor.getParameterTypes(),\n                inject.value()\n            );\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Constructor<T> findConstructorIn(Class<T> implementation) {\n            Constructor<T> found = null;\n            final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n            for (Constructor<T> constructor : declaredConstructors) {\n                if (constructor.getAnnotation(Inject.class) != null) {\n                    if (found != null) {\n                        throw new DependencyException(\"More than one constructor annotated\"\n                            + \" with @Inject found in \" + implementation + \".\");\n                    }\n                    found = constructor;\n                }\n            }\n            if (found != null) {\n                return found;\n            }\n\n            // If no annotated constructor is found, look for a no-arg constructor\n            // instead.\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n            }\n        }\n\n        /**\n         * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n         */\n        Object construct(InternalContext context, Class<? super T> expectedType) {\n            final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n            // We have a circular reference between constructors. Return a proxy.\n            if (constructionContext.isConstructing()) {\n                // TODO (crazybob): if we can't proxy this object, can we proxy the\n                // other object?\n                return constructionContext.createProxy(expectedType);\n            }\n\n            // If we're re-entering this factory while injecting fields or methods,\n            // return the same instance. This prevents infinite loops.\n            T t = constructionContext.getCurrentReference();\n            if (t != null) {\n                return t;\n            }\n\n            try {\n                // First time through...\n                constructionContext.startConstruction();\n                try {\n                    final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                    t = constructor.newInstance(parameters);\n                    constructionContext.setProxyDelegates(t);\n                } finally {\n                    constructionContext.finishConstruction();\n                }\n\n                // Store reference. If an injector re-enters this factory, they'll\n                // get the same reference.\n                constructionContext.setCurrentReference(t);\n\n                // Inject fields and methods.\n                for (Injector injector : injectors) {\n                    injector.inject(context, t);\n                }\n\n                return t;\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } finally {\n                constructionContext.removeCurrentReference();\n            }\n        }\n    }\n",
        "compositeId": "Exception thrown in class com.opensymphony.xwork2.inject.ContainerImpl$ConstructorInjector at new com.opensymphony.xwork2.inject.ContainerImpl$ConstructorInjector(ContainerImpl, Class) will leave the constructor. The object under construction remains partially initialized and may be vulnerable to Finalizer attacks.-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 130
    },
    {
        "explanation": "Unread field: com.opensymphony.xwork2.inject.ContainerImpl$ConstructorInjector.implementation",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 322,
        "methodEndLineNumber": 444,
        "warning_type": "URF_UNREAD_FIELD",
        "codeSnippet": "\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n\n        ParameterInjector<?>[] constructParameterInjector(\n            Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n            return constructor.getParameterTypes().length == 0\n                ? null // default constructor.\n                : container.getParametersInjectors(\n                constructor,\n                constructor.getParameterAnnotations(),\n                constructor.getParameterTypes(),\n                inject.value()\n            );\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Constructor<T> findConstructorIn(Class<T> implementation) {\n            Constructor<T> found = null;\n            final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n            for (Constructor<T> constructor : declaredConstructors) {\n                if (constructor.getAnnotation(Inject.class) != null) {\n                    if (found != null) {\n                        throw new DependencyException(\"More than one constructor annotated\"\n                            + \" with @Inject found in \" + implementation + \".\");\n                    }\n                    found = constructor;\n                }\n            }\n            if (found != null) {\n                return found;\n            }\n\n            // If no annotated constructor is found, look for a no-arg constructor\n            // instead.\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n            }\n        }\n\n        /**\n         * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n         */\n        Object construct(InternalContext context, Class<? super T> expectedType) {\n            final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n            // We have a circular reference between constructors. Return a proxy.\n            if (constructionContext.isConstructing()) {\n                // TODO (crazybob): if we can't proxy this object, can we proxy the\n                // other object?\n                return constructionContext.createProxy(expectedType);\n            }\n\n            // If we're re-entering this factory while injecting fields or methods,\n            // return the same instance. This prevents infinite loops.\n            T t = constructionContext.getCurrentReference();\n            if (t != null) {\n                return t;\n            }\n\n            try {\n                // First time through...\n                constructionContext.startConstruction();\n                try {\n                    final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                    t = constructor.newInstance(parameters);\n                    constructionContext.setProxyDelegates(t);\n                } finally {\n                    constructionContext.finishConstruction();\n                }\n\n                // Store reference. If an injector re-enters this factory, they'll\n                // get the same reference.\n                constructionContext.setCurrentReference(t);\n\n                // Inject fields and methods.\n                for (Injector injector : injectors) {\n                    injector.inject(context, t);\n                }\n\n                return t;\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } finally {\n                constructionContext.removeCurrentReference();\n            }\n",
        "classStartLineNumber": 316,
        "classEndLineNumber": 445,
        "classCode": "    static class ConstructorInjector<T> {\n\n        final Class<T> implementation;\n        final List<Injector> injectors;\n        final Constructor<T> constructor;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n\n        ParameterInjector<?>[] constructParameterInjector(\n            Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n            return constructor.getParameterTypes().length == 0\n                ? null // default constructor.\n                : container.getParametersInjectors(\n                constructor,\n                constructor.getParameterAnnotations(),\n                constructor.getParameterTypes(),\n                inject.value()\n            );\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Constructor<T> findConstructorIn(Class<T> implementation) {\n            Constructor<T> found = null;\n            final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n            for (Constructor<T> constructor : declaredConstructors) {\n                if (constructor.getAnnotation(Inject.class) != null) {\n                    if (found != null) {\n                        throw new DependencyException(\"More than one constructor annotated\"\n                            + \" with @Inject found in \" + implementation + \".\");\n                    }\n                    found = constructor;\n                }\n            }\n            if (found != null) {\n                return found;\n            }\n\n            // If no annotated constructor is found, look for a no-arg constructor\n            // instead.\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n            }\n        }\n\n        /**\n         * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n         */\n        Object construct(InternalContext context, Class<? super T> expectedType) {\n            final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n            // We have a circular reference between constructors. Return a proxy.\n            if (constructionContext.isConstructing()) {\n                // TODO (crazybob): if we can't proxy this object, can we proxy the\n                // other object?\n                return constructionContext.createProxy(expectedType);\n            }\n\n            // If we're re-entering this factory while injecting fields or methods,\n            // return the same instance. This prevents infinite loops.\n            T t = constructionContext.getCurrentReference();\n            if (t != null) {\n                return t;\n            }\n\n            try {\n                // First time through...\n                constructionContext.startConstruction();\n                try {\n                    final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                    t = constructor.newInstance(parameters);\n                    constructionContext.setProxyDelegates(t);\n                } finally {\n                    constructionContext.finishConstruction();\n                }\n\n                // Store reference. If an injector re-enters this factory, they'll\n                // get the same reference.\n                constructionContext.setCurrentReference(t);\n\n                // Inject fields and methods.\n                for (Injector injector : injectors) {\n                    injector.inject(context, t);\n                }\n\n                return t;\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } finally {\n                constructionContext.removeCurrentReference();\n            }\n        }\n    }\n",
        "compositeId": "Unread field: com.opensymphony.xwork2.inject.ContainerImpl$ConstructorInjector.implementation-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 130
    },
    {
        "explanation": "The method 'new com.opensymphony.xwork2.inject.ContainerImpl$ConstructorInjector(ContainerImpl, Class)' performs security check by using 'SecurityManager.checkPermission(Permission)' method of Security Manager Class, but is overrideable. Declare the method final or private in order to resolve the issue.",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 322,
        "methodEndLineNumber": 359,
        "warning_type": "VSC_VULNERABLE_SECURITY_CHECK_METHODS",
        "codeSnippet": "\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n",
        "classStartLineNumber": 316,
        "classEndLineNumber": 445,
        "classCode": "    static class ConstructorInjector<T> {\n\n        final Class<T> implementation;\n        final List<Injector> injectors;\n        final Constructor<T> constructor;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n\n        ParameterInjector<?>[] constructParameterInjector(\n            Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n            return constructor.getParameterTypes().length == 0\n                ? null // default constructor.\n                : container.getParametersInjectors(\n                constructor,\n                constructor.getParameterAnnotations(),\n                constructor.getParameterTypes(),\n                inject.value()\n            );\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Constructor<T> findConstructorIn(Class<T> implementation) {\n            Constructor<T> found = null;\n            final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n            for (Constructor<T> constructor : declaredConstructors) {\n                if (constructor.getAnnotation(Inject.class) != null) {\n                    if (found != null) {\n                        throw new DependencyException(\"More than one constructor annotated\"\n                            + \" with @Inject found in \" + implementation + \".\");\n                    }\n                    found = constructor;\n                }\n            }\n            if (found != null) {\n                return found;\n            }\n\n            // If no annotated constructor is found, look for a no-arg constructor\n            // instead.\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n            }\n        }\n\n        /**\n         * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n         */\n        Object construct(InternalContext context, Class<? super T> expectedType) {\n            final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n            // We have a circular reference between constructors. Return a proxy.\n            if (constructionContext.isConstructing()) {\n                // TODO (crazybob): if we can't proxy this object, can we proxy the\n                // other object?\n                return constructionContext.createProxy(expectedType);\n            }\n\n            // If we're re-entering this factory while injecting fields or methods,\n            // return the same instance. This prevents infinite loops.\n            T t = constructionContext.getCurrentReference();\n            if (t != null) {\n                return t;\n            }\n\n            try {\n                // First time through...\n                constructionContext.startConstruction();\n                try {\n                    final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                    t = constructor.newInstance(parameters);\n                    constructionContext.setProxyDelegates(t);\n                } finally {\n                    constructionContext.finishConstruction();\n                }\n\n                // Store reference. If an injector re-enters this factory, they'll\n                // get the same reference.\n                constructionContext.setCurrentReference(t);\n\n                // Inject fields and methods.\n                for (Injector injector : injectors) {\n                    injector.inject(context, t);\n                }\n\n                return t;\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } finally {\n                constructionContext.removeCurrentReference();\n            }\n        }\n    }\n",
        "compositeId": "The method 'new com.opensymphony.xwork2.inject.ContainerImpl$ConstructorInjector(ContainerImpl, Class)' performs security check by using 'SecurityManager.checkPermission(Permission)' method of Security Manager Class, but is overrideable. Declare the method final or private in order to resolve the issue.-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 130,
        "status": "solved",
        "newClassCode": "/*\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.inject;\n\nimport com.opensymphony.xwork2.inject.util.ReferenceCache;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ReflectPermission;\nimport java.security.AccessControlException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n * Default {@link Container} implementation.\n *\n * @author crazybob@google.com (Bob Lee)\n * @see ContainerBuilder\n */\nclass ContainerImpl implements Container {\n\n    final Map<Key<?>, InternalFactory<?>> factories;\n    final Map<Class<?>, Set<String>> factoryNamesByType;\n\n    ContainerImpl(Map<Key<?>, InternalFactory<?>> factories) {\n        this.factories = factories;\n        final Map<Class<?>, Set<String>> map = new HashMap<>();\n        for (Key<?> key : factories.keySet()) {\n            Set<String> names = map.computeIfAbsent(key.getType(), k -> new HashSet<>());\n            names.add(key.getName());\n        }\n\n        for (Entry<Class<?>, Set<String>> entry : map.entrySet()) {\n            entry.setValue(Collections.unmodifiableSet(entry.getValue()));\n        }\n\n        this.factoryNamesByType = Collections.unmodifiableMap(map);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> InternalFactory<? extends T> getFactory(Key<T> key) {\n        return (InternalFactory<T>) factories.get(key);\n    }\n\n    /**\n     * Field and method injectors.\n     */\n    final Map<Class<?>, List<Injector>> injectors =\n        new ReferenceCache<Class<?>, List<Injector>>() {\n            @Override\n            protected List<Injector> create(Class<?> key) {\n                List<Injector> injectors = new ArrayList<>();\n                addInjectors(key, injectors);\n                return injectors;\n            }\n        };\n\n    /**\n     * Recursively adds injectors for fields and methods from the given class to the given list. Injects parent classes\n     * before sub classes.\n     */\n    void addInjectors(Class<?> clazz, List<Injector> injectors) {\n        if (clazz == Object.class) {\n            return;\n        }\n\n        // Add injectors for superclass first.\n        addInjectors(clazz.getSuperclass(), injectors);\n\n        // TODO (crazybob): Filter out overridden members.\n        addInjectorsForFields(clazz.getDeclaredFields(), false, injectors);\n        addInjectorsForMethods(clazz.getDeclaredMethods(), false, injectors);\n    }\n\n    void injectStatics(List<Class<?>> staticInjections) {\n        final List<Injector> injectors = new ArrayList<>();\n\n        for (Class<?> clazz : staticInjections) {\n            addInjectorsForFields(clazz.getDeclaredFields(), true, injectors);\n            addInjectorsForMethods(clazz.getDeclaredMethods(), true, injectors);\n        }\n\n        callInContext((ContextualCallable<Void>) context -> {\n            for (Injector injector : injectors) {\n                injector.inject(context, null);\n            }\n            return null;\n        });\n    }\n\n    void addInjectorsForMethods(Method[] methods, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(methods), statics, injectors, MethodInjector::new);\n    }\n\n    void addInjectorsForFields(Field[] fields, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(fields), statics, injectors, FieldInjector::new);\n    }\n\n    <M extends Member & AnnotatedElement> void addInjectorsForMembers(\n        List<M> members, boolean statics, List<Injector> injectors, InjectorFactory<M> injectorFactory) {\n        for (M member : members) {\n            if (isStatic(member) == statics) {\n                Inject inject = member.getAnnotation(Inject.class);\n                if (inject != null) {\n                    try {\n                        injectors.add(injectorFactory.create(this, member, inject.value()));\n                    } catch (MissingDependencyException e) {\n                        if (inject.required()) {\n                            throw new DependencyException(e);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    interface InjectorFactory<M extends Member & AnnotatedElement> {\n\n        Injector create(ContainerImpl container, M member, String name)\n            throws MissingDependencyException;\n    }\n\n    /**\n     * Determines if a given {@link Member} is static or not.\n     *\n     * @param member checked for the static modifier.\n     * @return true if member is static, false otherwise.\n     */\n    private static boolean isStatic(Member member) {\n        return Modifier.isStatic(member.getModifiers());\n    }\n\n    /**\n     * Determines if a given {@link Member} is considered to be public for reflection usage or not.\n     *\n     * @param member checked to see if it is public for reflection usage.\n     * @return true if member is public for reflection usage, false otherwise.\n     */\n    private static boolean isPublicForReflection(Member member) {\n        return Modifier.isPublic(member.getModifiers()) &&\n            Modifier.isPublic(member.getDeclaringClass().getModifiers());\n    }\n\n    static class FieldInjector implements Injector {\n\n        final Field field;\n        final InternalFactory<?> factory;\n        final ExternalContext<?> externalContext;\n\n        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    /**\n     * Gets parameter injectors.\n     *\n     * @param member         to which the parameters belong\n     * @param annotations    on the parameters\n     * @param parameterTypes parameter types\n     * @return injections\n     */\n    <M extends AccessibleObject & Member> ParameterInjector<?>[] getParametersInjectors(\n        M member,\n        Annotation[][] annotations,\n        Class<?>[] parameterTypes,\n        String defaultName\n    ) throws MissingDependencyException {\n        final List<ParameterInjector<?>> parameterInjectors = new ArrayList<>();\n\n        final Iterator<Annotation[]> annotationsIterator = Arrays.asList(annotations).iterator();\n        for (Class<?> parameterType : parameterTypes) {\n            Inject annotation = findInject(annotationsIterator.next());\n            String name = annotation == null ? defaultName : annotation.value();\n            Key<?> key = Key.newInstance(parameterType, name);\n            parameterInjectors.add(createParameterInjector(key, member));\n        }\n\n        return toArray(parameterInjectors);\n    }\n\n    <T> ParameterInjector<T> createParameterInjector(Key<T> key, Member member) throws MissingDependencyException {\n        final InternalFactory<? extends T> factory = getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + member + \".\");\n        }\n\n        final ExternalContext<T> externalContext = ExternalContext.newInstance(member, key, this);\n        return new ParameterInjector<>(externalContext, factory);\n    }\n\n    private ParameterInjector<?>[] toArray(List<ParameterInjector<?>> parameterInjections) {\n        return parameterInjections.toArray(new ParameterInjector[0]);\n    }\n\n    /**\n     * Finds the {@link Inject} annotation in an array of annotations.\n     */\n    Inject findInject(Annotation[] annotations) {\n        for (Annotation annotation : annotations) {\n            if (annotation.annotationType() == Inject.class) {\n                return (Inject) annotation;\n            }\n        }\n        return null;\n    }\n\n    static class MethodInjector implements Injector {\n\n        final Method method;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    Map<Class<?>, ConstructorInjector<?>> constructors = new ReferenceCache<Class<?>, ConstructorInjector<?>>() {\n        @Override\n        protected ConstructorInjector<?> create(Class<?> implementation) {\n            return new ConstructorInjector<>(ContainerImpl.this, implementation);\n        }\n    };\n\nstatic class ConstructorInjector<T> {\n\n    final Class<T> implementation;\n    final List<Injector> injectors;\n    final Constructor<T> constructor;\n    final ParameterInjector<?>[] parameterInjectors;\n\n    private ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n        this.implementation = implementation;\n\n        constructor = findConstructorIn(implementation);\n        if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n            final SecurityManager sm = System.getSecurityManager();\n            try {\n                if (sm != null) {\n                    sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                }\n                constructor.setAccessible(true);\n            } catch (AccessControlException e) {\n                throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                    + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n            }\n        }\n\n        MissingDependencyException exception = null;\n        Inject inject = null;\n        ParameterInjector<?>[] parameters = null;\n\n        try {\n            inject = constructor.getAnnotation(Inject.class);\n            parameters = constructParameterInjector(inject, container, constructor);\n        } catch (MissingDependencyException e) {\n            exception = e;\n        }\n        parameterInjectors = parameters;\n\n        if (exception != null) {\n            if (inject != null && inject.required()) {\n                throw new DependencyException(exception);\n            }\n        }\n        injectors = container.injectors.get(implementation);\n    }\n\n    ParameterInjector<?>[] constructParameterInjector(\n        Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n        return constructor.getParameterTypes().length == 0\n            ? null // default constructor.\n            : container.getParametersInjectors(\n            constructor,\n            constructor.getParameterAnnotations(),\n            constructor.getParameterTypes(),\n            inject.value()\n        );\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Constructor<T> findConstructorIn(Class<T> implementation) {\n        Constructor<T> found = null;\n        final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n        for (Constructor<T> constructor : declaredConstructors) {\n            if (constructor.getAnnotation(Inject.class) != null) {\n                if (found != null) {\n                    throw new DependencyException(\"More than one constructor annotated\"\n                        + \" with @Inject found in \" + implementation + \".\");\n                }\n                found = constructor;\n            }\n        }\n        if (found != null) {\n            return found;\n        }\n\n        // If no annotated constructor is found, look for a no-arg constructor\n        // instead.\n        try {\n            return implementation.getDeclaredConstructor();\n        } catch (NoSuchMethodException e) {\n            throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n        }\n    }\n\n    /**\n     * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n     */\n    Object construct(InternalContext context, Class<? super T> expectedType) {\n        final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n        // We have a circular reference between constructors. Return a proxy.\n        if (constructionContext.isConstructing()) {\n            // TODO (crazybob): if we can't proxy this object, can we proxy the\n            // other object?\n            return constructionContext.createProxy(expectedType);\n        }\n\n        // If we're re-entering this factory while injecting fields or methods,\n        // return the same instance. This prevents infinite loops.\n        T t = constructionContext.getCurrentReference();\n        if (t != null) {\n            return t;\n        }\n\n        try {\n            // First time through...\n            constructionContext.startConstruction();\n            try {\n                final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                t = constructor.newInstance(parameters);\n                constructionContext.setProxyDelegates(t);\n            } finally {\n                constructionContext.finishConstruction();\n            }\n\n            // Store reference. If an injector re-enters this factory, they'll\n            // get the same reference.\n            constructionContext.setCurrentReference(t);\n\n            // Inject fields and methods.\n            for (Injector injector : injectors) {\n                injector.inject(context, t);\n            }\n\n            return t;\n        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n            throw new RuntimeException(e);\n        } finally {\n            constructionContext.removeCurrentReference();\n        }\n    }\n}\n\n    static class ParameterInjector<T> {\n\n        final ExternalContext<T> externalContext;\n        final InternalFactory<? extends T> factory;\n\n        public ParameterInjector(ExternalContext<T> externalContext, InternalFactory<? extends T> factory) {\n            this.externalContext = externalContext;\n            this.factory = factory;\n        }\n\n        T inject(Member member, InternalContext context) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                return factory.create(context);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    private static Object[] getParameters(Member member, InternalContext context, ParameterInjector<?>[] parameterInjectors) {\n        if (parameterInjectors == null) {\n            return null;\n        }\n\n        final Object[] parameters = new Object[parameterInjectors.length];\n        for (int i = 0; i < parameters.length; i++) {\n            parameters[i] = parameterInjectors[i].inject(member, context);\n        }\n        return parameters;\n    }\n\n    void inject(Object o, InternalContext context) {\n        final List<Injector> injectors = this.injectors.get(o.getClass());\n        for (Injector injector : injectors) {\n            injector.inject(context, o);\n        }\n    }\n\n    <T> T inject(Class<T> implementation, InternalContext context) {\n        try {\n            final ConstructorInjector<T> constructor = getConstructor(implementation);\n            return implementation.cast(constructor.construct(context, implementation));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, String name, InternalContext context) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        final Key<T> key = Key.newInstance(type, name);\n        context.setExternalContext(ExternalContext.newInstance(null, key, this));\n        try {\n            final InternalFactory<? extends T> o = getFactory(key);\n            if (o != null) {\n                return getFactory(key).create(context);\n            } else {\n                return null;\n            }\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, InternalContext context) {\n        return getInstance(type, DEFAULT_NAME, context);\n    }\n\n    @Override\n    public void inject(final Object o) {\n        callInContext((ContextualCallable<Void>) context -> {\n            inject(o, context);\n            return null;\n        });\n    }\n\n    @Override\n    public <T> T inject(final Class<T> implementation) {\n        return callInContext(context -> inject(implementation, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type, final String name) {\n        return callInContext(context -> getInstance(type, name, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type) {\n        return callInContext(context -> getInstance(type, context));\n    }\n\n    @Override\n    public Set<String> getInstanceNames(final Class<?> type) {\n        Set<String> names = factoryNamesByType.get(type);\n        if (names == null) {\n            names = Collections.emptySet();\n        }\n        return names;\n    }\n\n    ThreadLocal<Object[]> localContext = ThreadLocal.withInitial(() -> new Object[1]);\n\n    /**\n     * Looks up thread local context. Creates (and removes) a new context if necessary.\n     */\n    <T> T callInContext(ContextualCallable<T> callable) {\n        final Object[] reference = localContext.get();\n        if (reference[0] == null) {\n            reference[0] = new InternalContext(this);\n            try {\n                return callable.call((InternalContext) reference[0]);\n            } finally {\n                // Only remove the context if this call created it.\n                reference[0] = null;\n                // WW-3768: ThreadLocal was not removed\n                localContext.remove();\n            }\n        } else {\n            // Someone else will clean up this context.\n            return callable.call((InternalContext) reference[0]);\n        }\n    }\n\n    interface ContextualCallable<T> {\n        T call(InternalContext context);\n    }\n\n    /**\n     * Gets a constructor function for a given implementation class.\n     */\n    @SuppressWarnings(\"unchecked\")\n    <T> ConstructorInjector<T> getConstructor(Class<T> implementation) {\n        return (ConstructorInjector<T>) constructors.get(implementation);\n    }\n\n    final ThreadLocal<Object> localScopeStrategy = new ThreadLocal<>();\n\n    @Override\n    public void setScopeStrategy(Scope.Strategy scopeStrategy) {\n        this.localScopeStrategy.set(scopeStrategy);\n    }\n\n    @Override\n    public void removeScopeStrategy() {\n        this.localScopeStrategy.remove();\n    }\n\n    /**\n     * Injects a field or method in a given object.\n     */\n    interface Injector extends Serializable {\n        void inject(InternalContext context, Object o);\n    }\n\n    static class MissingDependencyException extends Exception {\n        MissingDependencyException(String message) {\n            super(message);\n        }\n    }\n}\n"
    },
    {
        "explanation": "Exception thrown in class com.opensymphony.xwork2.inject.ContainerImpl$FieldInjector at new com.opensymphony.xwork2.inject.ContainerImpl$FieldInjector(ContainerImpl, Field, String) will leave the constructor. The object under construction remains partially initialized and may be vulnerable to Finalizer attacks.",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 179,
        "methodEndLineNumber": 203,
        "warning_type": "CT_CONSTRUCTOR_THROW",
        "codeSnippet": "        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n",
        "classStartLineNumber": 173,
        "classEndLineNumber": 216,
        "classCode": "    static class FieldInjector implements Injector {\n\n        final Field field;\n        final InternalFactory<?> factory;\n        final ExternalContext<?> externalContext;\n\n        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n",
        "compositeId": "Exception thrown in class com.opensymphony.xwork2.inject.ContainerImpl$FieldInjector at new com.opensymphony.xwork2.inject.ContainerImpl$FieldInjector(ContainerImpl, Field, String) will leave the constructor. The object under construction remains partially initialized and may be vulnerable to Finalizer attacks.-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 44
    },
    {
        "explanation": "Invocation of reflect.Field.setAccessible(boolean), which should be invoked from within a doPrivileged block, in new com.opensymphony.xwork2.inject.ContainerImpl$FieldInjector(ContainerImpl, Field, String)",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 179,
        "methodEndLineNumber": 203,
        "warning_type": "DP_DO_INSIDE_DO_PRIVILEGED",
        "codeSnippet": "        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n",
        "classStartLineNumber": 173,
        "classEndLineNumber": 216,
        "classCode": "    static class FieldInjector implements Injector {\n\n        final Field field;\n        final InternalFactory<?> factory;\n        final ExternalContext<?> externalContext;\n\n        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n",
        "compositeId": "Invocation of reflect.Field.setAccessible(boolean), which should be invoked from within a doPrivileged block, in new com.opensymphony.xwork2.inject.ContainerImpl$FieldInjector(ContainerImpl, Field, String)-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 44,
        "status": "solved",
        "newClassCode": "/*\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.inject;\n\nimport com.opensymphony.xwork2.inject.util.ReferenceCache;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ReflectPermission;\nimport java.security.AccessControlException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n * Default {@link Container} implementation.\n *\n * @author crazybob@google.com (Bob Lee)\n * @see ContainerBuilder\n */\nclass ContainerImpl implements Container {\n\n    final Map<Key<?>, InternalFactory<?>> factories;\n    final Map<Class<?>, Set<String>> factoryNamesByType;\n\n    ContainerImpl(Map<Key<?>, InternalFactory<?>> factories) {\n        this.factories = factories;\n        final Map<Class<?>, Set<String>> map = new HashMap<>();\n        for (Key<?> key : factories.keySet()) {\n            Set<String> names = map.computeIfAbsent(key.getType(), k -> new HashSet<>());\n            names.add(key.getName());\n        }\n\n        for (Entry<Class<?>, Set<String>> entry : map.entrySet()) {\n            entry.setValue(Collections.unmodifiableSet(entry.getValue()));\n        }\n\n        this.factoryNamesByType = Collections.unmodifiableMap(map);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> InternalFactory<? extends T> getFactory(Key<T> key) {\n        return (InternalFactory<T>) factories.get(key);\n    }\n\n    /**\n     * Field and method injectors.\n     */\n    final Map<Class<?>, List<Injector>> injectors =\n        new ReferenceCache<Class<?>, List<Injector>>() {\n            @Override\n            protected List<Injector> create(Class<?> key) {\n                List<Injector> injectors = new ArrayList<>();\n                addInjectors(key, injectors);\n                return injectors;\n            }\n        };\n\n    /**\n     * Recursively adds injectors for fields and methods from the given class to the given list. Injects parent classes\n     * before sub classes.\n     */\n    void addInjectors(Class<?> clazz, List<Injector> injectors) {\n        if (clazz == Object.class) {\n            return;\n        }\n\n        // Add injectors for superclass first.\n        addInjectors(clazz.getSuperclass(), injectors);\n\n        // TODO (crazybob): Filter out overridden members.\n        addInjectorsForFields(clazz.getDeclaredFields(), false, injectors);\n        addInjectorsForMethods(clazz.getDeclaredMethods(), false, injectors);\n    }\n\n    void injectStatics(List<Class<?>> staticInjections) {\n        final List<Injector> injectors = new ArrayList<>();\n\n        for (Class<?> clazz : staticInjections) {\n            addInjectorsForFields(clazz.getDeclaredFields(), true, injectors);\n            addInjectorsForMethods(clazz.getDeclaredMethods(), true, injectors);\n        }\n\n        callInContext((ContextualCallable<Void>) context -> {\n            for (Injector injector : injectors) {\n                injector.inject(context, null);\n            }\n            return null;\n        });\n    }\n\n    void addInjectorsForMethods(Method[] methods, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(methods), statics, injectors, MethodInjector::new);\n    }\n\n    void addInjectorsForFields(Field[] fields, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(fields), statics, injectors, FieldInjector::new);\n    }\n\n    <M extends Member & AnnotatedElement> void addInjectorsForMembers(\n        List<M> members, boolean statics, List<Injector> injectors, InjectorFactory<M> injectorFactory) {\n        for (M member : members) {\n            if (isStatic(member) == statics) {\n                Inject inject = member.getAnnotation(Inject.class);\n                if (inject != null) {\n                    try {\n                        injectors.add(injectorFactory.create(this, member, inject.value()));\n                    } catch (MissingDependencyException e) {\n                        if (inject.required()) {\n                            throw new DependencyException(e);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    interface InjectorFactory<M extends Member & AnnotatedElement> {\n\n        Injector create(ContainerImpl container, M member, String name)\n            throws MissingDependencyException;\n    }\n\n    /**\n     * Determines if a given {@link Member} is static or not.\n     *\n     * @param member checked for the static modifier.\n     * @return true if member is static, false otherwise.\n     */\n    private static boolean isStatic(Member member) {\n        return Modifier.isStatic(member.getModifiers());\n    }\n\n    /**\n     * Determines if a given {@link Member} is considered to be public for reflection usage or not.\n     *\n     * @param member checked to see if it is public for reflection usage.\n     * @return true if member is public for reflection usage, false otherwise.\n     */\n    private static boolean isPublicForReflection(Member member) {\n        return Modifier.isPublic(member.getModifiers()) &&\n            Modifier.isPublic(member.getDeclaringClass().getModifiers());\n    }\n\nstatic class FieldInjector implements Injector {\n\n    final Field field;\n    final InternalFactory<?> factory;\n    final ExternalContext<?> externalContext;\n\n    private FieldInjector(ContainerImpl container, Field field, String name)\n        throws MissingDependencyException {\n        this.field = field;\n        if (!isPublicForReflection(field) && !field.isAccessible()) {\n            SecurityManager sm = System.getSecurityManager();\n            try {\n                if (sm != null) {\n                    sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                }\n                field.setAccessible(true);\n            } catch (AccessControlException e) {\n                throw new DependencyException(\"Security manager in use, could not access field: \"\n                    + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n            }\n        }\n\n        final Key<?> key = Key.newInstance(field.getType(), name);\n        factory = container.getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n        }\n\n        this.externalContext = ExternalContext.newInstance(field, key, container);\n    }\n\n    @Override\n    public void inject(InternalContext context, Object o) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        context.setExternalContext(externalContext);\n        try {\n            field.set(o, factory.create(context));\n        } catch (IllegalAccessException e) {\n            throw new AssertionError(e);\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n}\n\n    /**\n     * Gets parameter injectors.\n     *\n     * @param member         to which the parameters belong\n     * @param annotations    on the parameters\n     * @param parameterTypes parameter types\n     * @return injections\n     */\n    <M extends AccessibleObject & Member> ParameterInjector<?>[] getParametersInjectors(\n        M member,\n        Annotation[][] annotations,\n        Class<?>[] parameterTypes,\n        String defaultName\n    ) throws MissingDependencyException {\n        final List<ParameterInjector<?>> parameterInjectors = new ArrayList<>();\n\n        final Iterator<Annotation[]> annotationsIterator = Arrays.asList(annotations).iterator();\n        for (Class<?> parameterType : parameterTypes) {\n            Inject annotation = findInject(annotationsIterator.next());\n            String name = annotation == null ? defaultName : annotation.value();\n            Key<?> key = Key.newInstance(parameterType, name);\n            parameterInjectors.add(createParameterInjector(key, member));\n        }\n\n        return toArray(parameterInjectors);\n    }\n\n    <T> ParameterInjector<T> createParameterInjector(Key<T> key, Member member) throws MissingDependencyException {\n        final InternalFactory<? extends T> factory = getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + member + \".\");\n        }\n\n        final ExternalContext<T> externalContext = ExternalContext.newInstance(member, key, this);\n        return new ParameterInjector<>(externalContext, factory);\n    }\n\n    private ParameterInjector<?>[] toArray(List<ParameterInjector<?>> parameterInjections) {\n        return parameterInjections.toArray(new ParameterInjector[0]);\n    }\n\n    /**\n     * Finds the {@link Inject} annotation in an array of annotations.\n     */\n    Inject findInject(Annotation[] annotations) {\n        for (Annotation annotation : annotations) {\n            if (annotation.annotationType() == Inject.class) {\n                return (Inject) annotation;\n            }\n        }\n        return null;\n    }\n\n    static class MethodInjector implements Injector {\n\n        final Method method;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    Map<Class<?>, ConstructorInjector<?>> constructors = new ReferenceCache<Class<?>, ConstructorInjector<?>>() {\n        @Override\n        protected ConstructorInjector<?> create(Class<?> implementation) {\n            return new ConstructorInjector<>(ContainerImpl.this, implementation);\n        }\n    };\n\n    static class ConstructorInjector<T> {\n\n        final Class<T> implementation;\n        final List<Injector> injectors;\n        final Constructor<T> constructor;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n\n        ParameterInjector<?>[] constructParameterInjector(\n            Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n            return constructor.getParameterTypes().length == 0\n                ? null // default constructor.\n                : container.getParametersInjectors(\n                constructor,\n                constructor.getParameterAnnotations(),\n                constructor.getParameterTypes(),\n                inject.value()\n            );\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Constructor<T> findConstructorIn(Class<T> implementation) {\n            Constructor<T> found = null;\n            final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n            for (Constructor<T> constructor : declaredConstructors) {\n                if (constructor.getAnnotation(Inject.class) != null) {\n                    if (found != null) {\n                        throw new DependencyException(\"More than one constructor annotated\"\n                            + \" with @Inject found in \" + implementation + \".\");\n                    }\n                    found = constructor;\n                }\n            }\n            if (found != null) {\n                return found;\n            }\n\n            // If no annotated constructor is found, look for a no-arg constructor\n            // instead.\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n            }\n        }\n\n        /**\n         * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n         */\n        Object construct(InternalContext context, Class<? super T> expectedType) {\n            final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n            // We have a circular reference between constructors. Return a proxy.\n            if (constructionContext.isConstructing()) {\n                // TODO (crazybob): if we can't proxy this object, can we proxy the\n                // other object?\n                return constructionContext.createProxy(expectedType);\n            }\n\n            // If we're re-entering this factory while injecting fields or methods,\n            // return the same instance. This prevents infinite loops.\n            T t = constructionContext.getCurrentReference();\n            if (t != null) {\n                return t;\n            }\n\n            try {\n                // First time through...\n                constructionContext.startConstruction();\n                try {\n                    final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                    t = constructor.newInstance(parameters);\n                    constructionContext.setProxyDelegates(t);\n                } finally {\n                    constructionContext.finishConstruction();\n                }\n\n                // Store reference. If an injector re-enters this factory, they'll\n                // get the same reference.\n                constructionContext.setCurrentReference(t);\n\n                // Inject fields and methods.\n                for (Injector injector : injectors) {\n                    injector.inject(context, t);\n                }\n\n                return t;\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } finally {\n                constructionContext.removeCurrentReference();\n            }\n        }\n    }\n\n    static class ParameterInjector<T> {\n\n        final ExternalContext<T> externalContext;\n        final InternalFactory<? extends T> factory;\n\n        public ParameterInjector(ExternalContext<T> externalContext, InternalFactory<? extends T> factory) {\n            this.externalContext = externalContext;\n            this.factory = factory;\n        }\n\n        T inject(Member member, InternalContext context) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                return factory.create(context);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    private static Object[] getParameters(Member member, InternalContext context, ParameterInjector<?>[] parameterInjectors) {\n        if (parameterInjectors == null) {\n            return null;\n        }\n\n        final Object[] parameters = new Object[parameterInjectors.length];\n        for (int i = 0; i < parameters.length; i++) {\n            parameters[i] = parameterInjectors[i].inject(member, context);\n        }\n        return parameters;\n    }\n\n    void inject(Object o, InternalContext context) {\n        final List<Injector> injectors = this.injectors.get(o.getClass());\n        for (Injector injector : injectors) {\n            injector.inject(context, o);\n        }\n    }\n\n    <T> T inject(Class<T> implementation, InternalContext context) {\n        try {\n            final ConstructorInjector<T> constructor = getConstructor(implementation);\n            return implementation.cast(constructor.construct(context, implementation));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, String name, InternalContext context) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        final Key<T> key = Key.newInstance(type, name);\n        context.setExternalContext(ExternalContext.newInstance(null, key, this));\n        try {\n            final InternalFactory<? extends T> o = getFactory(key);\n            if (o != null) {\n                return getFactory(key).create(context);\n            } else {\n                return null;\n            }\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, InternalContext context) {\n        return getInstance(type, DEFAULT_NAME, context);\n    }\n\n    @Override\n    public void inject(final Object o) {\n        callInContext((ContextualCallable<Void>) context -> {\n            inject(o, context);\n            return null;\n        });\n    }\n\n    @Override\n    public <T> T inject(final Class<T> implementation) {\n        return callInContext(context -> inject(implementation, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type, final String name) {\n        return callInContext(context -> getInstance(type, name, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type) {\n        return callInContext(context -> getInstance(type, context));\n    }\n\n    @Override\n    public Set<String> getInstanceNames(final Class<?> type) {\n        Set<String> names = factoryNamesByType.get(type);\n        if (names == null) {\n            names = Collections.emptySet();\n        }\n        return names;\n    }\n\n    ThreadLocal<Object[]> localContext = ThreadLocal.withInitial(() -> new Object[1]);\n\n    /**\n     * Looks up thread local context. Creates (and removes) a new context if necessary.\n     */\n    <T> T callInContext(ContextualCallable<T> callable) {\n        final Object[] reference = localContext.get();\n        if (reference[0] == null) {\n            reference[0] = new InternalContext(this);\n            try {\n                return callable.call((InternalContext) reference[0]);\n            } finally {\n                // Only remove the context if this call created it.\n                reference[0] = null;\n                // WW-3768: ThreadLocal was not removed\n                localContext.remove();\n            }\n        } else {\n            // Someone else will clean up this context.\n            return callable.call((InternalContext) reference[0]);\n        }\n    }\n\n    interface ContextualCallable<T> {\n        T call(InternalContext context);\n    }\n\n    /**\n     * Gets a constructor function for a given implementation class.\n     */\n    @SuppressWarnings(\"unchecked\")\n    <T> ConstructorInjector<T> getConstructor(Class<T> implementation) {\n        return (ConstructorInjector<T>) constructors.get(implementation);\n    }\n\n    final ThreadLocal<Object> localScopeStrategy = new ThreadLocal<>();\n\n    @Override\n    public void setScopeStrategy(Scope.Strategy scopeStrategy) {\n        this.localScopeStrategy.set(scopeStrategy);\n    }\n\n    @Override\n    public void removeScopeStrategy() {\n        this.localScopeStrategy.remove();\n    }\n\n    /**\n     * Injects a field or method in a given object.\n     */\n    interface Injector extends Serializable {\n        void inject(InternalContext context, Object o);\n    }\n\n    static class MissingDependencyException extends Exception {\n        MissingDependencyException(String message) {\n            super(message);\n        }\n    }\n}\n"
    },
    {
        "explanation": "Class com.opensymphony.xwork2.inject.ContainerImpl$FieldInjector defines non-transient non-serializable instance field externalContext",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 179,
        "methodEndLineNumber": 216,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n",
        "classStartLineNumber": 173,
        "classEndLineNumber": 216,
        "classCode": "    static class FieldInjector implements Injector {\n\n        final Field field;\n        final InternalFactory<?> factory;\n        final ExternalContext<?> externalContext;\n\n        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n",
        "compositeId": "Class com.opensymphony.xwork2.inject.ContainerImpl$FieldInjector defines non-transient non-serializable instance field externalContext-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 44,
        "status": "solved",
        "newClassCode": "/*\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.inject;\n\nimport com.opensymphony.xwork2.inject.util.ReferenceCache;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ReflectPermission;\nimport java.security.AccessControlException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n * Default {@link Container} implementation.\n *\n * @author crazybob@google.com (Bob Lee)\n * @see ContainerBuilder\n */\nclass ContainerImpl implements Container {\n\n    final Map<Key<?>, InternalFactory<?>> factories;\n    final Map<Class<?>, Set<String>> factoryNamesByType;\n\n    ContainerImpl(Map<Key<?>, InternalFactory<?>> factories) {\n        this.factories = factories;\n        final Map<Class<?>, Set<String>> map = new HashMap<>();\n        for (Key<?> key : factories.keySet()) {\n            Set<String> names = map.computeIfAbsent(key.getType(), k -> new HashSet<>());\n            names.add(key.getName());\n        }\n\n        for (Entry<Class<?>, Set<String>> entry : map.entrySet()) {\n            entry.setValue(Collections.unmodifiableSet(entry.getValue()));\n        }\n\n        this.factoryNamesByType = Collections.unmodifiableMap(map);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> InternalFactory<? extends T> getFactory(Key<T> key) {\n        return (InternalFactory<T>) factories.get(key);\n    }\n\n    /**\n     * Field and method injectors.\n     */\n    final Map<Class<?>, List<Injector>> injectors =\n        new ReferenceCache<Class<?>, List<Injector>>() {\n            @Override\n            protected List<Injector> create(Class<?> key) {\n                List<Injector> injectors = new ArrayList<>();\n                addInjectors(key, injectors);\n                return injectors;\n            }\n        };\n\n    /**\n     * Recursively adds injectors for fields and methods from the given class to the given list. Injects parent classes\n     * before sub classes.\n     */\n    void addInjectors(Class<?> clazz, List<Injector> injectors) {\n        if (clazz == Object.class) {\n            return;\n        }\n\n        // Add injectors for superclass first.\n        addInjectors(clazz.getSuperclass(), injectors);\n\n        // TODO (crazybob): Filter out overridden members.\n        addInjectorsForFields(clazz.getDeclaredFields(), false, injectors);\n        addInjectorsForMethods(clazz.getDeclaredMethods(), false, injectors);\n    }\n\n    void injectStatics(List<Class<?>> staticInjections) {\n        final List<Injector> injectors = new ArrayList<>();\n\n        for (Class<?> clazz : staticInjections) {\n            addInjectorsForFields(clazz.getDeclaredFields(), true, injectors);\n            addInjectorsForMethods(clazz.getDeclaredMethods(), true, injectors);\n        }\n\n        callInContext((ContextualCallable<Void>) context -> {\n            for (Injector injector : injectors) {\n                injector.inject(context, null);\n            }\n            return null;\n        });\n    }\n\n    void addInjectorsForMethods(Method[] methods, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(methods), statics, injectors, MethodInjector::new);\n    }\n\n    void addInjectorsForFields(Field[] fields, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(fields), statics, injectors, FieldInjector::new);\n    }\n\n    <M extends Member & AnnotatedElement> void addInjectorsForMembers(\n        List<M> members, boolean statics, List<Injector> injectors, InjectorFactory<M> injectorFactory) {\n        for (M member : members) {\n            if (isStatic(member) == statics) {\n                Inject inject = member.getAnnotation(Inject.class);\n                if (inject != null) {\n                    try {\n                        injectors.add(injectorFactory.create(this, member, inject.value()));\n                    } catch (MissingDependencyException e) {\n                        if (inject.required()) {\n                            throw new DependencyException(e);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    interface InjectorFactory<M extends Member & AnnotatedElement> {\n\n        Injector create(ContainerImpl container, M member, String name)\n            throws MissingDependencyException;\n    }\n\n    /**\n     * Determines if a given {@link Member} is static or not.\n     *\n     * @param member checked for the static modifier.\n     * @return true if member is static, false otherwise.\n     */\n    private static boolean isStatic(Member member) {\n        return Modifier.isStatic(member.getModifiers());\n    }\n\n    /**\n     * Determines if a given {@link Member} is considered to be public for reflection usage or not.\n     *\n     * @param member checked to see if it is public for reflection usage.\n     * @return true if member is public for reflection usage, false otherwise.\n     */\n    private static boolean isPublicForReflection(Member member) {\n        return Modifier.isPublic(member.getModifiers()) &&\n            Modifier.isPublic(member.getDeclaringClass().getModifiers());\n    }\n\nstatic class FieldInjector implements Injector {\n\n    final Field field;\n    final InternalFactory<?> factory;\n    transient final ExternalContext<?> externalContext;\n\n    public FieldInjector(ContainerImpl container, Field field, String name)\n        throws MissingDependencyException {\n        this.field = field;\n        if (!isPublicForReflection(field) && !field.isAccessible()) {\n            SecurityManager sm = System.getSecurityManager();\n            try {\n                if (sm != null) {\n                    sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                }\n                field.setAccessible(true);\n            } catch (AccessControlException e) {\n                throw new DependencyException(\"Security manager in use, could not access field: \"\n                    + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n            }\n        }\n\n        final Key<?> key = Key.newInstance(field.getType(), name);\n        factory = container.getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n        }\n\n        this.externalContext = ExternalContext.newInstance(field, key, container);\n    }\n\n    @Override\n    public void inject(InternalContext context, Object o) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        context.setExternalContext(externalContext);\n        try {\n            field.set(o, factory.create(context));\n        } catch (IllegalAccessException e) {\n            throw new AssertionError(e);\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n}\n\n    /**\n     * Gets parameter injectors.\n     *\n     * @param member         to which the parameters belong\n     * @param annotations    on the parameters\n     * @param parameterTypes parameter types\n     * @return injections\n     */\n    <M extends AccessibleObject & Member> ParameterInjector<?>[] getParametersInjectors(\n        M member,\n        Annotation[][] annotations,\n        Class<?>[] parameterTypes,\n        String defaultName\n    ) throws MissingDependencyException {\n        final List<ParameterInjector<?>> parameterInjectors = new ArrayList<>();\n\n        final Iterator<Annotation[]> annotationsIterator = Arrays.asList(annotations).iterator();\n        for (Class<?> parameterType : parameterTypes) {\n            Inject annotation = findInject(annotationsIterator.next());\n            String name = annotation == null ? defaultName : annotation.value();\n            Key<?> key = Key.newInstance(parameterType, name);\n            parameterInjectors.add(createParameterInjector(key, member));\n        }\n\n        return toArray(parameterInjectors);\n    }\n\n    <T> ParameterInjector<T> createParameterInjector(Key<T> key, Member member) throws MissingDependencyException {\n        final InternalFactory<? extends T> factory = getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + member + \".\");\n        }\n\n        final ExternalContext<T> externalContext = ExternalContext.newInstance(member, key, this);\n        return new ParameterInjector<>(externalContext, factory);\n    }\n\n    private ParameterInjector<?>[] toArray(List<ParameterInjector<?>> parameterInjections) {\n        return parameterInjections.toArray(new ParameterInjector[0]);\n    }\n\n    /**\n     * Finds the {@link Inject} annotation in an array of annotations.\n     */\n    Inject findInject(Annotation[] annotations) {\n        for (Annotation annotation : annotations) {\n            if (annotation.annotationType() == Inject.class) {\n                return (Inject) annotation;\n            }\n        }\n        return null;\n    }\n\n    static class MethodInjector implements Injector {\n\n        final Method method;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    Map<Class<?>, ConstructorInjector<?>> constructors = new ReferenceCache<Class<?>, ConstructorInjector<?>>() {\n        @Override\n        protected ConstructorInjector<?> create(Class<?> implementation) {\n            return new ConstructorInjector<>(ContainerImpl.this, implementation);\n        }\n    };\n\n    static class ConstructorInjector<T> {\n\n        final Class<T> implementation;\n        final List<Injector> injectors;\n        final Constructor<T> constructor;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n\n        ParameterInjector<?>[] constructParameterInjector(\n            Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n            return constructor.getParameterTypes().length == 0\n                ? null // default constructor.\n                : container.getParametersInjectors(\n                constructor,\n                constructor.getParameterAnnotations(),\n                constructor.getParameterTypes(),\n                inject.value()\n            );\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Constructor<T> findConstructorIn(Class<T> implementation) {\n            Constructor<T> found = null;\n            final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n            for (Constructor<T> constructor : declaredConstructors) {\n                if (constructor.getAnnotation(Inject.class) != null) {\n                    if (found != null) {\n                        throw new DependencyException(\"More than one constructor annotated\"\n                            + \" with @Inject found in \" + implementation + \".\");\n                    }\n                    found = constructor;\n                }\n            }\n            if (found != null) {\n                return found;\n            }\n\n            // If no annotated constructor is found, look for a no-arg constructor\n            // instead.\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n            }\n        }\n\n        /**\n         * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n         */\n        Object construct(InternalContext context, Class<? super T> expectedType) {\n            final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n            // We have a circular reference between constructors. Return a proxy.\n            if (constructionContext.isConstructing()) {\n                // TODO (crazybob): if we can't proxy this object, can we proxy the\n                // other object?\n                return constructionContext.createProxy(expectedType);\n            }\n\n            // If we're re-entering this factory while injecting fields or methods,\n            // return the same instance. This prevents infinite loops.\n            T t = constructionContext.getCurrentReference();\n            if (t != null) {\n                return t;\n            }\n\n            try {\n                // First time through...\n                constructionContext.startConstruction();\n                try {\n                    final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                    t = constructor.newInstance(parameters);\n                    constructionContext.setProxyDelegates(t);\n                } finally {\n                    constructionContext.finishConstruction();\n                }\n\n                // Store reference. If an injector re-enters this factory, they'll\n                // get the same reference.\n                constructionContext.setCurrentReference(t);\n\n                // Inject fields and methods.\n                for (Injector injector : injectors) {\n                    injector.inject(context, t);\n                }\n\n                return t;\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } finally {\n                constructionContext.removeCurrentReference();\n            }\n        }\n    }\n\n    static class ParameterInjector<T> {\n\n        final ExternalContext<T> externalContext;\n        final InternalFactory<? extends T> factory;\n\n        public ParameterInjector(ExternalContext<T> externalContext, InternalFactory<? extends T> factory) {\n            this.externalContext = externalContext;\n            this.factory = factory;\n        }\n\n        T inject(Member member, InternalContext context) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                return factory.create(context);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    private static Object[] getParameters(Member member, InternalContext context, ParameterInjector<?>[] parameterInjectors) {\n        if (parameterInjectors == null) {\n            return null;\n        }\n\n        final Object[] parameters = new Object[parameterInjectors.length];\n        for (int i = 0; i < parameters.length; i++) {\n            parameters[i] = parameterInjectors[i].inject(member, context);\n        }\n        return parameters;\n    }\n\n    void inject(Object o, InternalContext context) {\n        final List<Injector> injectors = this.injectors.get(o.getClass());\n        for (Injector injector : injectors) {\n            injector.inject(context, o);\n        }\n    }\n\n    <T> T inject(Class<T> implementation, InternalContext context) {\n        try {\n            final ConstructorInjector<T> constructor = getConstructor(implementation);\n            return implementation.cast(constructor.construct(context, implementation));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, String name, InternalContext context) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        final Key<T> key = Key.newInstance(type, name);\n        context.setExternalContext(ExternalContext.newInstance(null, key, this));\n        try {\n            final InternalFactory<? extends T> o = getFactory(key);\n            if (o != null) {\n                return getFactory(key).create(context);\n            } else {\n                return null;\n            }\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, InternalContext context) {\n        return getInstance(type, DEFAULT_NAME, context);\n    }\n\n    @Override\n    public void inject(final Object o) {\n        callInContext((ContextualCallable<Void>) context -> {\n            inject(o, context);\n            return null;\n        });\n    }\n\n    @Override\n    public <T> T inject(final Class<T> implementation) {\n        return callInContext(context -> inject(implementation, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type, final String name) {\n        return callInContext(context -> getInstance(type, name, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type) {\n        return callInContext(context -> getInstance(type, context));\n    }\n\n    @Override\n    public Set<String> getInstanceNames(final Class<?> type) {\n        Set<String> names = factoryNamesByType.get(type);\n        if (names == null) {\n            names = Collections.emptySet();\n        }\n        return names;\n    }\n\n    ThreadLocal<Object[]> localContext = ThreadLocal.withInitial(() -> new Object[1]);\n\n    /**\n     * Looks up thread local context. Creates (and removes) a new context if necessary.\n     */\n    <T> T callInContext(ContextualCallable<T> callable) {\n        final Object[] reference = localContext.get();\n        if (reference[0] == null) {\n            reference[0] = new InternalContext(this);\n            try {\n                return callable.call((InternalContext) reference[0]);\n            } finally {\n                // Only remove the context if this call created it.\n                reference[0] = null;\n                // WW-3768: ThreadLocal was not removed\n                localContext.remove();\n            }\n        } else {\n            // Someone else will clean up this context.\n            return callable.call((InternalContext) reference[0]);\n        }\n    }\n\n    interface ContextualCallable<T> {\n        T call(InternalContext context);\n    }\n\n    /**\n     * Gets a constructor function for a given implementation class.\n     */\n    @SuppressWarnings(\"unchecked\")\n    <T> ConstructorInjector<T> getConstructor(Class<T> implementation) {\n        return (ConstructorInjector<T>) constructors.get(implementation);\n    }\n\n    final ThreadLocal<Object> localScopeStrategy = new ThreadLocal<>();\n\n    @Override\n    public void setScopeStrategy(Scope.Strategy scopeStrategy) {\n        this.localScopeStrategy.set(scopeStrategy);\n    }\n\n    @Override\n    public void removeScopeStrategy() {\n        this.localScopeStrategy.remove();\n    }\n\n    /**\n     * Injects a field or method in a given object.\n     */\n    interface Injector extends Serializable {\n        void inject(InternalContext context, Object o);\n    }\n\n    static class MissingDependencyException extends Exception {\n        MissingDependencyException(String message) {\n            super(message);\n        }\n    }\n}\n"
    },
    {
        "explanation": "Class com.opensymphony.xwork2.inject.ContainerImpl$FieldInjector defines non-transient non-serializable instance field field",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 179,
        "methodEndLineNumber": 216,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n",
        "classStartLineNumber": 173,
        "classEndLineNumber": 216,
        "classCode": "    static class FieldInjector implements Injector {\n\n        final Field field;\n        final InternalFactory<?> factory;\n        final ExternalContext<?> externalContext;\n\n        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n",
        "compositeId": "Class com.opensymphony.xwork2.inject.ContainerImpl$FieldInjector defines non-transient non-serializable instance field field-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 44,
        "status": "solved",
        "newClassCode": "/*\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.inject;\n\nimport com.opensymphony.xwork2.inject.util.ReferenceCache;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ReflectPermission;\nimport java.security.AccessControlException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n * Default {@link Container} implementation.\n *\n * @author crazybob@google.com (Bob Lee)\n * @see ContainerBuilder\n */\nclass ContainerImpl implements Container {\n\n    final Map<Key<?>, InternalFactory<?>> factories;\n    final Map<Class<?>, Set<String>> factoryNamesByType;\n\n    ContainerImpl(Map<Key<?>, InternalFactory<?>> factories) {\n        this.factories = factories;\n        final Map<Class<?>, Set<String>> map = new HashMap<>();\n        for (Key<?> key : factories.keySet()) {\n            Set<String> names = map.computeIfAbsent(key.getType(), k -> new HashSet<>());\n            names.add(key.getName());\n        }\n\n        for (Entry<Class<?>, Set<String>> entry : map.entrySet()) {\n            entry.setValue(Collections.unmodifiableSet(entry.getValue()));\n        }\n\n        this.factoryNamesByType = Collections.unmodifiableMap(map);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> InternalFactory<? extends T> getFactory(Key<T> key) {\n        return (InternalFactory<T>) factories.get(key);\n    }\n\n    /**\n     * Field and method injectors.\n     */\n    final Map<Class<?>, List<Injector>> injectors =\n        new ReferenceCache<Class<?>, List<Injector>>() {\n            @Override\n            protected List<Injector> create(Class<?> key) {\n                List<Injector> injectors = new ArrayList<>();\n                addInjectors(key, injectors);\n                return injectors;\n            }\n        };\n\n    /**\n     * Recursively adds injectors for fields and methods from the given class to the given list. Injects parent classes\n     * before sub classes.\n     */\n    void addInjectors(Class<?> clazz, List<Injector> injectors) {\n        if (clazz == Object.class) {\n            return;\n        }\n\n        // Add injectors for superclass first.\n        addInjectors(clazz.getSuperclass(), injectors);\n\n        // TODO (crazybob): Filter out overridden members.\n        addInjectorsForFields(clazz.getDeclaredFields(), false, injectors);\n        addInjectorsForMethods(clazz.getDeclaredMethods(), false, injectors);\n    }\n\n    void injectStatics(List<Class<?>> staticInjections) {\n        final List<Injector> injectors = new ArrayList<>();\n\n        for (Class<?> clazz : staticInjections) {\n            addInjectorsForFields(clazz.getDeclaredFields(), true, injectors);\n            addInjectorsForMethods(clazz.getDeclaredMethods(), true, injectors);\n        }\n\n        callInContext((ContextualCallable<Void>) context -> {\n            for (Injector injector : injectors) {\n                injector.inject(context, null);\n            }\n            return null;\n        });\n    }\n\n    void addInjectorsForMethods(Method[] methods, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(methods), statics, injectors, MethodInjector::new);\n    }\n\n    void addInjectorsForFields(Field[] fields, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(fields), statics, injectors, FieldInjector::new);\n    }\n\n    <M extends Member & AnnotatedElement> void addInjectorsForMembers(\n        List<M> members, boolean statics, List<Injector> injectors, InjectorFactory<M> injectorFactory) {\n        for (M member : members) {\n            if (isStatic(member) == statics) {\n                Inject inject = member.getAnnotation(Inject.class);\n                if (inject != null) {\n                    try {\n                        injectors.add(injectorFactory.create(this, member, inject.value()));\n                    } catch (MissingDependencyException e) {\n                        if (inject.required()) {\n                            throw new DependencyException(e);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    interface InjectorFactory<M extends Member & AnnotatedElement> {\n\n        Injector create(ContainerImpl container, M member, String name)\n            throws MissingDependencyException;\n    }\n\n    /**\n     * Determines if a given {@link Member} is static or not.\n     *\n     * @param member checked for the static modifier.\n     * @return true if member is static, false otherwise.\n     */\n    private static boolean isStatic(Member member) {\n        return Modifier.isStatic(member.getModifiers());\n    }\n\n    /**\n     * Determines if a given {@link Member} is considered to be public for reflection usage or not.\n     *\n     * @param member checked to see if it is public for reflection usage.\n     * @return true if member is public for reflection usage, false otherwise.\n     */\n    private static boolean isPublicForReflection(Member member) {\n        return Modifier.isPublic(member.getModifiers()) &&\n            Modifier.isPublic(member.getDeclaringClass().getModifiers());\n    }\n\nstatic class FieldInjector implements Injector {\n\n    final transient Field field;\n    final InternalFactory<?> factory;\n    final ExternalContext<?> externalContext;\n\n    public FieldInjector(ContainerImpl container, Field field, String name)\n        throws MissingDependencyException {\n        this.field = field;\n        if (!isPublicForReflection(field) && !field.isAccessible()) {\n            SecurityManager sm = System.getSecurityManager();\n            try {\n                if (sm != null) {\n                    sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                }\n                field.setAccessible(true);\n            } catch (AccessControlException e) {\n                throw new DependencyException(\"Security manager in use, could not access field: \"\n                    + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n            }\n        }\n\n        final Key<?> key = Key.newInstance(field.getType(), name);\n        factory = container.getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n        }\n\n        this.externalContext = ExternalContext.newInstance(field, key, container);\n    }\n\n    @Override\n    public void inject(InternalContext context, Object o) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        context.setExternalContext(externalContext);\n        try {\n            field.set(o, factory.create(context));\n        } catch (IllegalAccessException e) {\n            throw new AssertionError(e);\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n}\n\n    /**\n     * Gets parameter injectors.\n     *\n     * @param member         to which the parameters belong\n     * @param annotations    on the parameters\n     * @param parameterTypes parameter types\n     * @return injections\n     */\n    <M extends AccessibleObject & Member> ParameterInjector<?>[] getParametersInjectors(\n        M member,\n        Annotation[][] annotations,\n        Class<?>[] parameterTypes,\n        String defaultName\n    ) throws MissingDependencyException {\n        final List<ParameterInjector<?>> parameterInjectors = new ArrayList<>();\n\n        final Iterator<Annotation[]> annotationsIterator = Arrays.asList(annotations).iterator();\n        for (Class<?> parameterType : parameterTypes) {\n            Inject annotation = findInject(annotationsIterator.next());\n            String name = annotation == null ? defaultName : annotation.value();\n            Key<?> key = Key.newInstance(parameterType, name);\n            parameterInjectors.add(createParameterInjector(key, member));\n        }\n\n        return toArray(parameterInjectors);\n    }\n\n    <T> ParameterInjector<T> createParameterInjector(Key<T> key, Member member) throws MissingDependencyException {\n        final InternalFactory<? extends T> factory = getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + member + \".\");\n        }\n\n        final ExternalContext<T> externalContext = ExternalContext.newInstance(member, key, this);\n        return new ParameterInjector<>(externalContext, factory);\n    }\n\n    private ParameterInjector<?>[] toArray(List<ParameterInjector<?>> parameterInjections) {\n        return parameterInjections.toArray(new ParameterInjector[0]);\n    }\n\n    /**\n     * Finds the {@link Inject} annotation in an array of annotations.\n     */\n    Inject findInject(Annotation[] annotations) {\n        for (Annotation annotation : annotations) {\n            if (annotation.annotationType() == Inject.class) {\n                return (Inject) annotation;\n            }\n        }\n        return null;\n    }\n\n    static class MethodInjector implements Injector {\n\n        final Method method;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    Map<Class<?>, ConstructorInjector<?>> constructors = new ReferenceCache<Class<?>, ConstructorInjector<?>>() {\n        @Override\n        protected ConstructorInjector<?> create(Class<?> implementation) {\n            return new ConstructorInjector<>(ContainerImpl.this, implementation);\n        }\n    };\n\n    static class ConstructorInjector<T> {\n\n        final Class<T> implementation;\n        final List<Injector> injectors;\n        final Constructor<T> constructor;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n\n        ParameterInjector<?>[] constructParameterInjector(\n            Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n            return constructor.getParameterTypes().length == 0\n                ? null // default constructor.\n                : container.getParametersInjectors(\n                constructor,\n                constructor.getParameterAnnotations(),\n                constructor.getParameterTypes(),\n                inject.value()\n            );\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Constructor<T> findConstructorIn(Class<T> implementation) {\n            Constructor<T> found = null;\n            final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n            for (Constructor<T> constructor : declaredConstructors) {\n                if (constructor.getAnnotation(Inject.class) != null) {\n                    if (found != null) {\n                        throw new DependencyException(\"More than one constructor annotated\"\n                            + \" with @Inject found in \" + implementation + \".\");\n                    }\n                    found = constructor;\n                }\n            }\n            if (found != null) {\n                return found;\n            }\n\n            // If no annotated constructor is found, look for a no-arg constructor\n            // instead.\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n            }\n        }\n\n        /**\n         * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n         */\n        Object construct(InternalContext context, Class<? super T> expectedType) {\n            final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n            // We have a circular reference between constructors. Return a proxy.\n            if (constructionContext.isConstructing()) {\n                // TODO (crazybob): if we can't proxy this object, can we proxy the\n                // other object?\n                return constructionContext.createProxy(expectedType);\n            }\n\n            // If we're re-entering this factory while injecting fields or methods,\n            // return the same instance. This prevents infinite loops.\n            T t = constructionContext.getCurrentReference();\n            if (t != null) {\n                return t;\n            }\n\n            try {\n                // First time through...\n                constructionContext.startConstruction();\n                try {\n                    final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                    t = constructor.newInstance(parameters);\n                    constructionContext.setProxyDelegates(t);\n                } finally {\n                    constructionContext.finishConstruction();\n                }\n\n                // Store reference. If an injector re-enters this factory, they'll\n                // get the same reference.\n                constructionContext.setCurrentReference(t);\n\n                // Inject fields and methods.\n                for (Injector injector : injectors) {\n                    injector.inject(context, t);\n                }\n\n                return t;\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } finally {\n                constructionContext.removeCurrentReference();\n            }\n        }\n    }\n\n    static class ParameterInjector<T> {\n\n        final ExternalContext<T> externalContext;\n        final InternalFactory<? extends T> factory;\n\n        public ParameterInjector(ExternalContext<T> externalContext, InternalFactory<? extends T> factory) {\n            this.externalContext = externalContext;\n            this.factory = factory;\n        }\n\n        T inject(Member member, InternalContext context) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                return factory.create(context);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    private static Object[] getParameters(Member member, InternalContext context, ParameterInjector<?>[] parameterInjectors) {\n        if (parameterInjectors == null) {\n            return null;\n        }\n\n        final Object[] parameters = new Object[parameterInjectors.length];\n        for (int i = 0; i < parameters.length; i++) {\n            parameters[i] = parameterInjectors[i].inject(member, context);\n        }\n        return parameters;\n    }\n\n    void inject(Object o, InternalContext context) {\n        final List<Injector> injectors = this.injectors.get(o.getClass());\n        for (Injector injector : injectors) {\n            injector.inject(context, o);\n        }\n    }\n\n    <T> T inject(Class<T> implementation, InternalContext context) {\n        try {\n            final ConstructorInjector<T> constructor = getConstructor(implementation);\n            return implementation.cast(constructor.construct(context, implementation));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, String name, InternalContext context) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        final Key<T> key = Key.newInstance(type, name);\n        context.setExternalContext(ExternalContext.newInstance(null, key, this));\n        try {\n            final InternalFactory<? extends T> o = getFactory(key);\n            if (o != null) {\n                return getFactory(key).create(context);\n            } else {\n                return null;\n            }\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, InternalContext context) {\n        return getInstance(type, DEFAULT_NAME, context);\n    }\n\n    @Override\n    public void inject(final Object o) {\n        callInContext((ContextualCallable<Void>) context -> {\n            inject(o, context);\n            return null;\n        });\n    }\n\n    @Override\n    public <T> T inject(final Class<T> implementation) {\n        return callInContext(context -> inject(implementation, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type, final String name) {\n        return callInContext(context -> getInstance(type, name, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type) {\n        return callInContext(context -> getInstance(type, context));\n    }\n\n    @Override\n    public Set<String> getInstanceNames(final Class<?> type) {\n        Set<String> names = factoryNamesByType.get(type);\n        if (names == null) {\n            names = Collections.emptySet();\n        }\n        return names;\n    }\n\n    ThreadLocal<Object[]> localContext = ThreadLocal.withInitial(() -> new Object[1]);\n\n    /**\n     * Looks up thread local context. Creates (and removes) a new context if necessary.\n     */\n    <T> T callInContext(ContextualCallable<T> callable) {\n        final Object[] reference = localContext.get();\n        if (reference[0] == null) {\n            reference[0] = new InternalContext(this);\n            try {\n                return callable.call((InternalContext) reference[0]);\n            } finally {\n                // Only remove the context if this call created it.\n                reference[0] = null;\n                // WW-3768: ThreadLocal was not removed\n                localContext.remove();\n            }\n        } else {\n            // Someone else will clean up this context.\n            return callable.call((InternalContext) reference[0]);\n        }\n    }\n\n    interface ContextualCallable<T> {\n        T call(InternalContext context);\n    }\n\n    /**\n     * Gets a constructor function for a given implementation class.\n     */\n    @SuppressWarnings(\"unchecked\")\n    <T> ConstructorInjector<T> getConstructor(Class<T> implementation) {\n        return (ConstructorInjector<T>) constructors.get(implementation);\n    }\n\n    final ThreadLocal<Object> localScopeStrategy = new ThreadLocal<>();\n\n    @Override\n    public void setScopeStrategy(Scope.Strategy scopeStrategy) {\n        this.localScopeStrategy.set(scopeStrategy);\n    }\n\n    @Override\n    public void removeScopeStrategy() {\n        this.localScopeStrategy.remove();\n    }\n\n    /**\n     * Injects a field or method in a given object.\n     */\n    interface Injector extends Serializable {\n        void inject(InternalContext context, Object o);\n    }\n\n    static class MissingDependencyException extends Exception {\n        MissingDependencyException(String message) {\n            super(message);\n        }\n    }\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.inject.ContainerImpl$FieldInjector is Serializable; consider declaring a serialVersionUID",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 179,
        "methodEndLineNumber": 216,
        "warning_type": "SE_NO_SERIALVERSIONID",
        "codeSnippet": "        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n",
        "classStartLineNumber": 173,
        "classEndLineNumber": 216,
        "classCode": "    static class FieldInjector implements Injector {\n\n        final Field field;\n        final InternalFactory<?> factory;\n        final ExternalContext<?> externalContext;\n\n        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n",
        "compositeId": "com.opensymphony.xwork2.inject.ContainerImpl$FieldInjector is Serializable; consider declaring a serialVersionUID-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 44,
        "status": "solved",
        "newClassCode": "/*\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.inject;\n\nimport com.opensymphony.xwork2.inject.util.ReferenceCache;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ReflectPermission;\nimport java.security.AccessControlException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n * Default {@link Container} implementation.\n *\n * @author crazybob@google.com (Bob Lee)\n * @see ContainerBuilder\n */\nclass ContainerImpl implements Container {\n\n    final Map<Key<?>, InternalFactory<?>> factories;\n    final Map<Class<?>, Set<String>> factoryNamesByType;\n\n    ContainerImpl(Map<Key<?>, InternalFactory<?>> factories) {\n        this.factories = factories;\n        final Map<Class<?>, Set<String>> map = new HashMap<>();\n        for (Key<?> key : factories.keySet()) {\n            Set<String> names = map.computeIfAbsent(key.getType(), k -> new HashSet<>());\n            names.add(key.getName());\n        }\n\n        for (Entry<Class<?>, Set<String>> entry : map.entrySet()) {\n            entry.setValue(Collections.unmodifiableSet(entry.getValue()));\n        }\n\n        this.factoryNamesByType = Collections.unmodifiableMap(map);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> InternalFactory<? extends T> getFactory(Key<T> key) {\n        return (InternalFactory<T>) factories.get(key);\n    }\n\n    /**\n     * Field and method injectors.\n     */\n    final Map<Class<?>, List<Injector>> injectors =\n        new ReferenceCache<Class<?>, List<Injector>>() {\n            @Override\n            protected List<Injector> create(Class<?> key) {\n                List<Injector> injectors = new ArrayList<>();\n                addInjectors(key, injectors);\n                return injectors;\n            }\n        };\n\n    /**\n     * Recursively adds injectors for fields and methods from the given class to the given list. Injects parent classes\n     * before sub classes.\n     */\n    void addInjectors(Class<?> clazz, List<Injector> injectors) {\n        if (clazz == Object.class) {\n            return;\n        }\n\n        // Add injectors for superclass first.\n        addInjectors(clazz.getSuperclass(), injectors);\n\n        // TODO (crazybob): Filter out overridden members.\n        addInjectorsForFields(clazz.getDeclaredFields(), false, injectors);\n        addInjectorsForMethods(clazz.getDeclaredMethods(), false, injectors);\n    }\n\n    void injectStatics(List<Class<?>> staticInjections) {\n        final List<Injector> injectors = new ArrayList<>();\n\n        for (Class<?> clazz : staticInjections) {\n            addInjectorsForFields(clazz.getDeclaredFields(), true, injectors);\n            addInjectorsForMethods(clazz.getDeclaredMethods(), true, injectors);\n        }\n\n        callInContext((ContextualCallable<Void>) context -> {\n            for (Injector injector : injectors) {\n                injector.inject(context, null);\n            }\n            return null;\n        });\n    }\n\n    void addInjectorsForMethods(Method[] methods, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(methods), statics, injectors, MethodInjector::new);\n    }\n\n    void addInjectorsForFields(Field[] fields, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(fields), statics, injectors, FieldInjector::new);\n    }\n\n    <M extends Member & AnnotatedElement> void addInjectorsForMembers(\n        List<M> members, boolean statics, List<Injector> injectors, InjectorFactory<M> injectorFactory) {\n        for (M member : members) {\n            if (isStatic(member) == statics) {\n                Inject inject = member.getAnnotation(Inject.class);\n                if (inject != null) {\n                    try {\n                        injectors.add(injectorFactory.create(this, member, inject.value()));\n                    } catch (MissingDependencyException e) {\n                        if (inject.required()) {\n                            throw new DependencyException(e);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    interface InjectorFactory<M extends Member & AnnotatedElement> {\n\n        Injector create(ContainerImpl container, M member, String name)\n            throws MissingDependencyException;\n    }\n\n    /**\n     * Determines if a given {@link Member} is static or not.\n     *\n     * @param member checked for the static modifier.\n     * @return true if member is static, false otherwise.\n     */\n    private static boolean isStatic(Member member) {\n        return Modifier.isStatic(member.getModifiers());\n    }\n\n    /**\n     * Determines if a given {@link Member} is considered to be public for reflection usage or not.\n     *\n     * @param member checked to see if it is public for reflection usage.\n     * @return true if member is public for reflection usage, false otherwise.\n     */\n    private static boolean isPublicForReflection(Member member) {\n        return Modifier.isPublic(member.getModifiers()) &&\n            Modifier.isPublic(member.getDeclaringClass().getModifiers());\n    }\n\nstatic class FieldInjector implements Injector, Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    final Field field;\n    final InternalFactory<?> factory;\n    final ExternalContext<?> externalContext;\n\n    public FieldInjector(ContainerImpl container, Field field, String name)\n        throws MissingDependencyException {\n        this.field = field;\n        if (!isPublicForReflection(field) && !field.isAccessible()) {\n            SecurityManager sm = System.getSecurityManager();\n            try {\n                if (sm != null) {\n                    sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                }\n                field.setAccessible(true);\n            } catch (AccessControlException e) {\n                throw new DependencyException(\"Security manager in use, could not access field: \"\n                    + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n            }\n        }\n\n        final Key<?> key = Key.newInstance(field.getType(), name);\n        factory = container.getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n        }\n\n        this.externalContext = ExternalContext.newInstance(field, key, container);\n    }\n\n    @Override\n    public void inject(InternalContext context, Object o) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        context.setExternalContext(externalContext);\n        try {\n            field.set(o, factory.create(context));\n        } catch (IllegalAccessException e) {\n            throw new AssertionError(e);\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n}\n\n    /**\n     * Gets parameter injectors.\n     *\n     * @param member         to which the parameters belong\n     * @param annotations    on the parameters\n     * @param parameterTypes parameter types\n     * @return injections\n     */\n    <M extends AccessibleObject & Member> ParameterInjector<?>[] getParametersInjectors(\n        M member,\n        Annotation[][] annotations,\n        Class<?>[] parameterTypes,\n        String defaultName\n    ) throws MissingDependencyException {\n        final List<ParameterInjector<?>> parameterInjectors = new ArrayList<>();\n\n        final Iterator<Annotation[]> annotationsIterator = Arrays.asList(annotations).iterator();\n        for (Class<?> parameterType : parameterTypes) {\n            Inject annotation = findInject(annotationsIterator.next());\n            String name = annotation == null ? defaultName : annotation.value();\n            Key<?> key = Key.newInstance(parameterType, name);\n            parameterInjectors.add(createParameterInjector(key, member));\n        }\n\n        return toArray(parameterInjectors);\n    }\n\n    <T> ParameterInjector<T> createParameterInjector(Key<T> key, Member member) throws MissingDependencyException {\n        final InternalFactory<? extends T> factory = getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + member + \".\");\n        }\n\n        final ExternalContext<T> externalContext = ExternalContext.newInstance(member, key, this);\n        return new ParameterInjector<>(externalContext, factory);\n    }\n\n    private ParameterInjector<?>[] toArray(List<ParameterInjector<?>> parameterInjections) {\n        return parameterInjections.toArray(new ParameterInjector[0]);\n    }\n\n    /**\n     * Finds the {@link Inject} annotation in an array of annotations.\n     */\n    Inject findInject(Annotation[] annotations) {\n        for (Annotation annotation : annotations) {\n            if (annotation.annotationType() == Inject.class) {\n                return (Inject) annotation;\n            }\n        }\n        return null;\n    }\n\n    static class MethodInjector implements Injector {\n\n        final Method method;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    Map<Class<?>, ConstructorInjector<?>> constructors = new ReferenceCache<Class<?>, ConstructorInjector<?>>() {\n        @Override\n        protected ConstructorInjector<?> create(Class<?> implementation) {\n            return new ConstructorInjector<>(ContainerImpl.this, implementation);\n        }\n    };\n\n    static class ConstructorInjector<T> {\n\n        final Class<T> implementation;\n        final List<Injector> injectors;\n        final Constructor<T> constructor;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n\n        ParameterInjector<?>[] constructParameterInjector(\n            Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n            return constructor.getParameterTypes().length == 0\n                ? null // default constructor.\n                : container.getParametersInjectors(\n                constructor,\n                constructor.getParameterAnnotations(),\n                constructor.getParameterTypes(),\n                inject.value()\n            );\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Constructor<T> findConstructorIn(Class<T> implementation) {\n            Constructor<T> found = null;\n            final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n            for (Constructor<T> constructor : declaredConstructors) {\n                if (constructor.getAnnotation(Inject.class) != null) {\n                    if (found != null) {\n                        throw new DependencyException(\"More than one constructor annotated\"\n                            + \" with @Inject found in \" + implementation + \".\");\n                    }\n                    found = constructor;\n                }\n            }\n            if (found != null) {\n                return found;\n            }\n\n            // If no annotated constructor is found, look for a no-arg constructor\n            // instead.\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n            }\n        }\n\n        /**\n         * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n         */\n        Object construct(InternalContext context, Class<? super T> expectedType) {\n            final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n            // We have a circular reference between constructors. Return a proxy.\n            if (constructionContext.isConstructing()) {\n                // TODO (crazybob): if we can't proxy this object, can we proxy the\n                // other object?\n                return constructionContext.createProxy(expectedType);\n            }\n\n            // If we're re-entering this factory while injecting fields or methods,\n            // return the same instance. This prevents infinite loops.\n            T t = constructionContext.getCurrentReference();\n            if (t != null) {\n                return t;\n            }\n\n            try {\n                // First time through...\n                constructionContext.startConstruction();\n                try {\n                    final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                    t = constructor.newInstance(parameters);\n                    constructionContext.setProxyDelegates(t);\n                } finally {\n                    constructionContext.finishConstruction();\n                }\n\n                // Store reference. If an injector re-enters this factory, they'll\n                // get the same reference.\n                constructionContext.setCurrentReference(t);\n\n                // Inject fields and methods.\n                for (Injector injector : injectors) {\n                    injector.inject(context, t);\n                }\n\n                return t;\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } finally {\n                constructionContext.removeCurrentReference();\n            }\n        }\n    }\n\n    static class ParameterInjector<T> {\n\n        final ExternalContext<T> externalContext;\n        final InternalFactory<? extends T> factory;\n\n        public ParameterInjector(ExternalContext<T> externalContext, InternalFactory<? extends T> factory) {\n            this.externalContext = externalContext;\n            this.factory = factory;\n        }\n\n        T inject(Member member, InternalContext context) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                return factory.create(context);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    private static Object[] getParameters(Member member, InternalContext context, ParameterInjector<?>[] parameterInjectors) {\n        if (parameterInjectors == null) {\n            return null;\n        }\n\n        final Object[] parameters = new Object[parameterInjectors.length];\n        for (int i = 0; i < parameters.length; i++) {\n            parameters[i] = parameterInjectors[i].inject(member, context);\n        }\n        return parameters;\n    }\n\n    void inject(Object o, InternalContext context) {\n        final List<Injector> injectors = this.injectors.get(o.getClass());\n        for (Injector injector : injectors) {\n            injector.inject(context, o);\n        }\n    }\n\n    <T> T inject(Class<T> implementation, InternalContext context) {\n        try {\n            final ConstructorInjector<T> constructor = getConstructor(implementation);\n            return implementation.cast(constructor.construct(context, implementation));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, String name, InternalContext context) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        final Key<T> key = Key.newInstance(type, name);\n        context.setExternalContext(ExternalContext.newInstance(null, key, this));\n        try {\n            final InternalFactory<? extends T> o = getFactory(key);\n            if (o != null) {\n                return getFactory(key).create(context);\n            } else {\n                return null;\n            }\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, InternalContext context) {\n        return getInstance(type, DEFAULT_NAME, context);\n    }\n\n    @Override\n    public void inject(final Object o) {\n        callInContext((ContextualCallable<Void>) context -> {\n            inject(o, context);\n            return null;\n        });\n    }\n\n    @Override\n    public <T> T inject(final Class<T> implementation) {\n        return callInContext(context -> inject(implementation, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type, final String name) {\n        return callInContext(context -> getInstance(type, name, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type) {\n        return callInContext(context -> getInstance(type, context));\n    }\n\n    @Override\n    public Set<String> getInstanceNames(final Class<?> type) {\n        Set<String> names = factoryNamesByType.get(type);\n        if (names == null) {\n            names = Collections.emptySet();\n        }\n        return names;\n    }\n\n    ThreadLocal<Object[]> localContext = ThreadLocal.withInitial(() -> new Object[1]);\n\n    /**\n     * Looks up thread local context. Creates (and removes) a new context if necessary.\n     */\n    <T> T callInContext(ContextualCallable<T> callable) {\n        final Object[] reference = localContext.get();\n        if (reference[0] == null) {\n            reference[0] = new InternalContext(this);\n            try {\n                return callable.call((InternalContext) reference[0]);\n            } finally {\n                // Only remove the context if this call created it.\n                reference[0] = null;\n                // WW-3768: ThreadLocal was not removed\n                localContext.remove();\n            }\n        } else {\n            // Someone else will clean up this context.\n            return callable.call((InternalContext) reference[0]);\n        }\n    }\n\n    interface ContextualCallable<T> {\n        T call(InternalContext context);\n    }\n\n    /**\n     * Gets a constructor function for a given implementation class.\n     */\n    @SuppressWarnings(\"unchecked\")\n    <T> ConstructorInjector<T> getConstructor(Class<T> implementation) {\n        return (ConstructorInjector<T>) constructors.get(implementation);\n    }\n\n    final ThreadLocal<Object> localScopeStrategy = new ThreadLocal<>();\n\n    @Override\n    public void setScopeStrategy(Scope.Strategy scopeStrategy) {\n        this.localScopeStrategy.set(scopeStrategy);\n    }\n\n    @Override\n    public void removeScopeStrategy() {\n        this.localScopeStrategy.remove();\n    }\n\n    /**\n     * Injects a field or method in a given object.\n     */\n    interface Injector extends Serializable {\n        void inject(InternalContext context, Object o);\n    }\n\n    static class MissingDependencyException extends Exception {\n        MissingDependencyException(String message) {\n            super(message);\n        }\n    }\n}\n"
    },
    {
        "explanation": "The method 'new com.opensymphony.xwork2.inject.ContainerImpl$FieldInjector(ContainerImpl, Field, String)' performs security check by using 'SecurityManager.checkPermission(Permission)' method of Security Manager Class, but is overrideable. Declare the method final or private in order to resolve the issue.",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 179,
        "methodEndLineNumber": 203,
        "warning_type": "VSC_VULNERABLE_SECURITY_CHECK_METHODS",
        "codeSnippet": "        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n",
        "classStartLineNumber": 173,
        "classEndLineNumber": 216,
        "classCode": "    static class FieldInjector implements Injector {\n\n        final Field field;\n        final InternalFactory<?> factory;\n        final ExternalContext<?> externalContext;\n\n        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n",
        "compositeId": "The method 'new com.opensymphony.xwork2.inject.ContainerImpl$FieldInjector(ContainerImpl, Field, String)' performs security check by using 'SecurityManager.checkPermission(Permission)' method of Security Manager Class, but is overrideable. Declare the method final or private in order to resolve the issue.-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 44,
        "status": "solved",
        "newClassCode": "/*\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.inject;\n\nimport com.opensymphony.xwork2.inject.util.ReferenceCache;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ReflectPermission;\nimport java.security.AccessControlException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n * Default {@link Container} implementation.\n *\n * @author crazybob@google.com (Bob Lee)\n * @see ContainerBuilder\n */\nclass ContainerImpl implements Container {\n\n    final Map<Key<?>, InternalFactory<?>> factories;\n    final Map<Class<?>, Set<String>> factoryNamesByType;\n\n    ContainerImpl(Map<Key<?>, InternalFactory<?>> factories) {\n        this.factories = factories;\n        final Map<Class<?>, Set<String>> map = new HashMap<>();\n        for (Key<?> key : factories.keySet()) {\n            Set<String> names = map.computeIfAbsent(key.getType(), k -> new HashSet<>());\n            names.add(key.getName());\n        }\n\n        for (Entry<Class<?>, Set<String>> entry : map.entrySet()) {\n            entry.setValue(Collections.unmodifiableSet(entry.getValue()));\n        }\n\n        this.factoryNamesByType = Collections.unmodifiableMap(map);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> InternalFactory<? extends T> getFactory(Key<T> key) {\n        return (InternalFactory<T>) factories.get(key);\n    }\n\n    /**\n     * Field and method injectors.\n     */\n    final Map<Class<?>, List<Injector>> injectors =\n        new ReferenceCache<Class<?>, List<Injector>>() {\n            @Override\n            protected List<Injector> create(Class<?> key) {\n                List<Injector> injectors = new ArrayList<>();\n                addInjectors(key, injectors);\n                return injectors;\n            }\n        };\n\n    /**\n     * Recursively adds injectors for fields and methods from the given class to the given list. Injects parent classes\n     * before sub classes.\n     */\n    void addInjectors(Class<?> clazz, List<Injector> injectors) {\n        if (clazz == Object.class) {\n            return;\n        }\n\n        // Add injectors for superclass first.\n        addInjectors(clazz.getSuperclass(), injectors);\n\n        // TODO (crazybob): Filter out overridden members.\n        addInjectorsForFields(clazz.getDeclaredFields(), false, injectors);\n        addInjectorsForMethods(clazz.getDeclaredMethods(), false, injectors);\n    }\n\n    void injectStatics(List<Class<?>> staticInjections) {\n        final List<Injector> injectors = new ArrayList<>();\n\n        for (Class<?> clazz : staticInjections) {\n            addInjectorsForFields(clazz.getDeclaredFields(), true, injectors);\n            addInjectorsForMethods(clazz.getDeclaredMethods(), true, injectors);\n        }\n\n        callInContext((ContextualCallable<Void>) context -> {\n            for (Injector injector : injectors) {\n                injector.inject(context, null);\n            }\n            return null;\n        });\n    }\n\n    void addInjectorsForMethods(Method[] methods, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(methods), statics, injectors, MethodInjector::new);\n    }\n\n    void addInjectorsForFields(Field[] fields, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(fields), statics, injectors, FieldInjector::new);\n    }\n\n    <M extends Member & AnnotatedElement> void addInjectorsForMembers(\n        List<M> members, boolean statics, List<Injector> injectors, InjectorFactory<M> injectorFactory) {\n        for (M member : members) {\n            if (isStatic(member) == statics) {\n                Inject inject = member.getAnnotation(Inject.class);\n                if (inject != null) {\n                    try {\n                        injectors.add(injectorFactory.create(this, member, inject.value()));\n                    } catch (MissingDependencyException e) {\n                        if (inject.required()) {\n                            throw new DependencyException(e);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    interface InjectorFactory<M extends Member & AnnotatedElement> {\n\n        Injector create(ContainerImpl container, M member, String name)\n            throws MissingDependencyException;\n    }\n\n    /**\n     * Determines if a given {@link Member} is static or not.\n     *\n     * @param member checked for the static modifier.\n     * @return true if member is static, false otherwise.\n     */\n    private static boolean isStatic(Member member) {\n        return Modifier.isStatic(member.getModifiers());\n    }\n\n    /**\n     * Determines if a given {@link Member} is considered to be public for reflection usage or not.\n     *\n     * @param member checked to see if it is public for reflection usage.\n     * @return true if member is public for reflection usage, false otherwise.\n     */\n    private static boolean isPublicForReflection(Member member) {\n        return Modifier.isPublic(member.getModifiers()) &&\n            Modifier.isPublic(member.getDeclaringClass().getModifiers());\n    }\n\nstatic class FieldInjector implements Injector {\n\n    final Field field;\n    final InternalFactory<?> factory;\n    final ExternalContext<?> externalContext;\n\n    private FieldInjector(ContainerImpl container, Field field, String name)\n        throws MissingDependencyException {\n        this.field = field;\n        if (!isPublicForReflection(field) && !field.isAccessible()) {\n            SecurityManager sm = System.getSecurityManager();\n            try {\n                if (sm != null) {\n                    sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                }\n                field.setAccessible(true);\n            } catch (AccessControlException e) {\n                throw new DependencyException(\"Security manager in use, could not access field: \"\n                    + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n            }\n        }\n\n        final Key<?> key = Key.newInstance(field.getType(), name);\n        factory = container.getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n        }\n\n        this.externalContext = ExternalContext.newInstance(field, key, container);\n    }\n\n    @Override\n    public void inject(InternalContext context, Object o) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        context.setExternalContext(externalContext);\n        try {\n            field.set(o, factory.create(context));\n        } catch (IllegalAccessException e) {\n            throw new AssertionError(e);\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n}\n\n    /**\n     * Gets parameter injectors.\n     *\n     * @param member         to which the parameters belong\n     * @param annotations    on the parameters\n     * @param parameterTypes parameter types\n     * @return injections\n     */\n    <M extends AccessibleObject & Member> ParameterInjector<?>[] getParametersInjectors(\n        M member,\n        Annotation[][] annotations,\n        Class<?>[] parameterTypes,\n        String defaultName\n    ) throws MissingDependencyException {\n        final List<ParameterInjector<?>> parameterInjectors = new ArrayList<>();\n\n        final Iterator<Annotation[]> annotationsIterator = Arrays.asList(annotations).iterator();\n        for (Class<?> parameterType : parameterTypes) {\n            Inject annotation = findInject(annotationsIterator.next());\n            String name = annotation == null ? defaultName : annotation.value();\n            Key<?> key = Key.newInstance(parameterType, name);\n            parameterInjectors.add(createParameterInjector(key, member));\n        }\n\n        return toArray(parameterInjectors);\n    }\n\n    <T> ParameterInjector<T> createParameterInjector(Key<T> key, Member member) throws MissingDependencyException {\n        final InternalFactory<? extends T> factory = getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + member + \".\");\n        }\n\n        final ExternalContext<T> externalContext = ExternalContext.newInstance(member, key, this);\n        return new ParameterInjector<>(externalContext, factory);\n    }\n\n    private ParameterInjector<?>[] toArray(List<ParameterInjector<?>> parameterInjections) {\n        return parameterInjections.toArray(new ParameterInjector[0]);\n    }\n\n    /**\n     * Finds the {@link Inject} annotation in an array of annotations.\n     */\n    Inject findInject(Annotation[] annotations) {\n        for (Annotation annotation : annotations) {\n            if (annotation.annotationType() == Inject.class) {\n                return (Inject) annotation;\n            }\n        }\n        return null;\n    }\n\n    static class MethodInjector implements Injector {\n\n        final Method method;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    Map<Class<?>, ConstructorInjector<?>> constructors = new ReferenceCache<Class<?>, ConstructorInjector<?>>() {\n        @Override\n        protected ConstructorInjector<?> create(Class<?> implementation) {\n            return new ConstructorInjector<>(ContainerImpl.this, implementation);\n        }\n    };\n\n    static class ConstructorInjector<T> {\n\n        final Class<T> implementation;\n        final List<Injector> injectors;\n        final Constructor<T> constructor;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n\n        ParameterInjector<?>[] constructParameterInjector(\n            Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n            return constructor.getParameterTypes().length == 0\n                ? null // default constructor.\n                : container.getParametersInjectors(\n                constructor,\n                constructor.getParameterAnnotations(),\n                constructor.getParameterTypes(),\n                inject.value()\n            );\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Constructor<T> findConstructorIn(Class<T> implementation) {\n            Constructor<T> found = null;\n            final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n            for (Constructor<T> constructor : declaredConstructors) {\n                if (constructor.getAnnotation(Inject.class) != null) {\n                    if (found != null) {\n                        throw new DependencyException(\"More than one constructor annotated\"\n                            + \" with @Inject found in \" + implementation + \".\");\n                    }\n                    found = constructor;\n                }\n            }\n            if (found != null) {\n                return found;\n            }\n\n            // If no annotated constructor is found, look for a no-arg constructor\n            // instead.\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n            }\n        }\n\n        /**\n         * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n         */\n        Object construct(InternalContext context, Class<? super T> expectedType) {\n            final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n            // We have a circular reference between constructors. Return a proxy.\n            if (constructionContext.isConstructing()) {\n                // TODO (crazybob): if we can't proxy this object, can we proxy the\n                // other object?\n                return constructionContext.createProxy(expectedType);\n            }\n\n            // If we're re-entering this factory while injecting fields or methods,\n            // return the same instance. This prevents infinite loops.\n            T t = constructionContext.getCurrentReference();\n            if (t != null) {\n                return t;\n            }\n\n            try {\n                // First time through...\n                constructionContext.startConstruction();\n                try {\n                    final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                    t = constructor.newInstance(parameters);\n                    constructionContext.setProxyDelegates(t);\n                } finally {\n                    constructionContext.finishConstruction();\n                }\n\n                // Store reference. If an injector re-enters this factory, they'll\n                // get the same reference.\n                constructionContext.setCurrentReference(t);\n\n                // Inject fields and methods.\n                for (Injector injector : injectors) {\n                    injector.inject(context, t);\n                }\n\n                return t;\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } finally {\n                constructionContext.removeCurrentReference();\n            }\n        }\n    }\n\n    static class ParameterInjector<T> {\n\n        final ExternalContext<T> externalContext;\n        final InternalFactory<? extends T> factory;\n\n        public ParameterInjector(ExternalContext<T> externalContext, InternalFactory<? extends T> factory) {\n            this.externalContext = externalContext;\n            this.factory = factory;\n        }\n\n        T inject(Member member, InternalContext context) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                return factory.create(context);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    private static Object[] getParameters(Member member, InternalContext context, ParameterInjector<?>[] parameterInjectors) {\n        if (parameterInjectors == null) {\n            return null;\n        }\n\n        final Object[] parameters = new Object[parameterInjectors.length];\n        for (int i = 0; i < parameters.length; i++) {\n            parameters[i] = parameterInjectors[i].inject(member, context);\n        }\n        return parameters;\n    }\n\n    void inject(Object o, InternalContext context) {\n        final List<Injector> injectors = this.injectors.get(o.getClass());\n        for (Injector injector : injectors) {\n            injector.inject(context, o);\n        }\n    }\n\n    <T> T inject(Class<T> implementation, InternalContext context) {\n        try {\n            final ConstructorInjector<T> constructor = getConstructor(implementation);\n            return implementation.cast(constructor.construct(context, implementation));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, String name, InternalContext context) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        final Key<T> key = Key.newInstance(type, name);\n        context.setExternalContext(ExternalContext.newInstance(null, key, this));\n        try {\n            final InternalFactory<? extends T> o = getFactory(key);\n            if (o != null) {\n                return getFactory(key).create(context);\n            } else {\n                return null;\n            }\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, InternalContext context) {\n        return getInstance(type, DEFAULT_NAME, context);\n    }\n\n    @Override\n    public void inject(final Object o) {\n        callInContext((ContextualCallable<Void>) context -> {\n            inject(o, context);\n            return null;\n        });\n    }\n\n    @Override\n    public <T> T inject(final Class<T> implementation) {\n        return callInContext(context -> inject(implementation, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type, final String name) {\n        return callInContext(context -> getInstance(type, name, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type) {\n        return callInContext(context -> getInstance(type, context));\n    }\n\n    @Override\n    public Set<String> getInstanceNames(final Class<?> type) {\n        Set<String> names = factoryNamesByType.get(type);\n        if (names == null) {\n            names = Collections.emptySet();\n        }\n        return names;\n    }\n\n    ThreadLocal<Object[]> localContext = ThreadLocal.withInitial(() -> new Object[1]);\n\n    /**\n     * Looks up thread local context. Creates (and removes) a new context if necessary.\n     */\n    <T> T callInContext(ContextualCallable<T> callable) {\n        final Object[] reference = localContext.get();\n        if (reference[0] == null) {\n            reference[0] = new InternalContext(this);\n            try {\n                return callable.call((InternalContext) reference[0]);\n            } finally {\n                // Only remove the context if this call created it.\n                reference[0] = null;\n                // WW-3768: ThreadLocal was not removed\n                localContext.remove();\n            }\n        } else {\n            // Someone else will clean up this context.\n            return callable.call((InternalContext) reference[0]);\n        }\n    }\n\n    interface ContextualCallable<T> {\n        T call(InternalContext context);\n    }\n\n    /**\n     * Gets a constructor function for a given implementation class.\n     */\n    @SuppressWarnings(\"unchecked\")\n    <T> ConstructorInjector<T> getConstructor(Class<T> implementation) {\n        return (ConstructorInjector<T>) constructors.get(implementation);\n    }\n\n    final ThreadLocal<Object> localScopeStrategy = new ThreadLocal<>();\n\n    @Override\n    public void setScopeStrategy(Scope.Strategy scopeStrategy) {\n        this.localScopeStrategy.set(scopeStrategy);\n    }\n\n    @Override\n    public void removeScopeStrategy() {\n        this.localScopeStrategy.remove();\n    }\n\n    /**\n     * Injects a field or method in a given object.\n     */\n    interface Injector extends Serializable {\n        void inject(InternalContext context, Object o);\n    }\n\n    static class MissingDependencyException extends Exception {\n        MissingDependencyException(String message) {\n            super(message);\n        }\n    }\n}\n"
    },
    {
        "explanation": "Exception thrown in class com.opensymphony.xwork2.inject.ContainerImpl$MethodInjector at new com.opensymphony.xwork2.inject.ContainerImpl$MethodInjector(ContainerImpl, Method, String) will leave the constructor. The object under construction remains partially initialized and may be vulnerable to Finalizer attacks.",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 275,
        "methodEndLineNumber": 298,
        "warning_type": "CT_CONSTRUCTOR_THROW",
        "codeSnippet": "\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n",
        "classStartLineNumber": 271,
        "classEndLineNumber": 307,
        "classCode": "    static class MethodInjector implements Injector {\n\n        final Method method;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n",
        "compositeId": "Exception thrown in class com.opensymphony.xwork2.inject.ContainerImpl$MethodInjector at new com.opensymphony.xwork2.inject.ContainerImpl$MethodInjector(ContainerImpl, Method, String) will leave the constructor. The object under construction remains partially initialized and may be vulnerable to Finalizer attacks.-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 37
    },
    {
        "explanation": "Invocation of reflect.Method.setAccessible(boolean), which should be invoked from within a doPrivileged block, in new com.opensymphony.xwork2.inject.ContainerImpl$MethodInjector(ContainerImpl, Method, String)",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 275,
        "methodEndLineNumber": 298,
        "warning_type": "DP_DO_INSIDE_DO_PRIVILEGED",
        "codeSnippet": "\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n",
        "classStartLineNumber": 271,
        "classEndLineNumber": 307,
        "classCode": "    static class MethodInjector implements Injector {\n\n        final Method method;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n",
        "compositeId": "Invocation of reflect.Method.setAccessible(boolean), which should be invoked from within a doPrivileged block, in new com.opensymphony.xwork2.inject.ContainerImpl$MethodInjector(ContainerImpl, Method, String)-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 37,
        "status": "solved",
        "newClassCode": "/*\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.inject;\n\nimport com.opensymphony.xwork2.inject.util.ReferenceCache;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ReflectPermission;\nimport java.security.AccessControlException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n * Default {@link Container} implementation.\n *\n * @author crazybob@google.com (Bob Lee)\n * @see ContainerBuilder\n */\nclass ContainerImpl implements Container {\n\n    final Map<Key<?>, InternalFactory<?>> factories;\n    final Map<Class<?>, Set<String>> factoryNamesByType;\n\n    ContainerImpl(Map<Key<?>, InternalFactory<?>> factories) {\n        this.factories = factories;\n        final Map<Class<?>, Set<String>> map = new HashMap<>();\n        for (Key<?> key : factories.keySet()) {\n            Set<String> names = map.computeIfAbsent(key.getType(), k -> new HashSet<>());\n            names.add(key.getName());\n        }\n\n        for (Entry<Class<?>, Set<String>> entry : map.entrySet()) {\n            entry.setValue(Collections.unmodifiableSet(entry.getValue()));\n        }\n\n        this.factoryNamesByType = Collections.unmodifiableMap(map);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> InternalFactory<? extends T> getFactory(Key<T> key) {\n        return (InternalFactory<T>) factories.get(key);\n    }\n\n    /**\n     * Field and method injectors.\n     */\n    final Map<Class<?>, List<Injector>> injectors =\n        new ReferenceCache<Class<?>, List<Injector>>() {\n            @Override\n            protected List<Injector> create(Class<?> key) {\n                List<Injector> injectors = new ArrayList<>();\n                addInjectors(key, injectors);\n                return injectors;\n            }\n        };\n\n    /**\n     * Recursively adds injectors for fields and methods from the given class to the given list. Injects parent classes\n     * before sub classes.\n     */\n    void addInjectors(Class<?> clazz, List<Injector> injectors) {\n        if (clazz == Object.class) {\n            return;\n        }\n\n        // Add injectors for superclass first.\n        addInjectors(clazz.getSuperclass(), injectors);\n\n        // TODO (crazybob): Filter out overridden members.\n        addInjectorsForFields(clazz.getDeclaredFields(), false, injectors);\n        addInjectorsForMethods(clazz.getDeclaredMethods(), false, injectors);\n    }\n\n    void injectStatics(List<Class<?>> staticInjections) {\n        final List<Injector> injectors = new ArrayList<>();\n\n        for (Class<?> clazz : staticInjections) {\n            addInjectorsForFields(clazz.getDeclaredFields(), true, injectors);\n            addInjectorsForMethods(clazz.getDeclaredMethods(), true, injectors);\n        }\n\n        callInContext((ContextualCallable<Void>) context -> {\n            for (Injector injector : injectors) {\n                injector.inject(context, null);\n            }\n            return null;\n        });\n    }\n\n    void addInjectorsForMethods(Method[] methods, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(methods), statics, injectors, MethodInjector::new);\n    }\n\n    void addInjectorsForFields(Field[] fields, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(fields), statics, injectors, FieldInjector::new);\n    }\n\n    <M extends Member & AnnotatedElement> void addInjectorsForMembers(\n        List<M> members, boolean statics, List<Injector> injectors, InjectorFactory<M> injectorFactory) {\n        for (M member : members) {\n            if (isStatic(member) == statics) {\n                Inject inject = member.getAnnotation(Inject.class);\n                if (inject != null) {\n                    try {\n                        injectors.add(injectorFactory.create(this, member, inject.value()));\n                    } catch (MissingDependencyException e) {\n                        if (inject.required()) {\n                            throw new DependencyException(e);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    interface InjectorFactory<M extends Member & AnnotatedElement> {\n\n        Injector create(ContainerImpl container, M member, String name)\n            throws MissingDependencyException;\n    }\n\n    /**\n     * Determines if a given {@link Member} is static or not.\n     *\n     * @param member checked for the static modifier.\n     * @return true if member is static, false otherwise.\n     */\n    private static boolean isStatic(Member member) {\n        return Modifier.isStatic(member.getModifiers());\n    }\n\n    /**\n     * Determines if a given {@link Member} is considered to be public for reflection usage or not.\n     *\n     * @param member checked to see if it is public for reflection usage.\n     * @return true if member is public for reflection usage, false otherwise.\n     */\n    private static boolean isPublicForReflection(Member member) {\n        return Modifier.isPublic(member.getModifiers()) &&\n            Modifier.isPublic(member.getDeclaringClass().getModifiers());\n    }\n\n    static class FieldInjector implements Injector {\n\n        final Field field;\n        final InternalFactory<?> factory;\n        final ExternalContext<?> externalContext;\n\n        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    /**\n     * Gets parameter injectors.\n     *\n     * @param member         to which the parameters belong\n     * @param annotations    on the parameters\n     * @param parameterTypes parameter types\n     * @return injections\n     */\n    <M extends AccessibleObject & Member> ParameterInjector<?>[] getParametersInjectors(\n        M member,\n        Annotation[][] annotations,\n        Class<?>[] parameterTypes,\n        String defaultName\n    ) throws MissingDependencyException {\n        final List<ParameterInjector<?>> parameterInjectors = new ArrayList<>();\n\n        final Iterator<Annotation[]> annotationsIterator = Arrays.asList(annotations).iterator();\n        for (Class<?> parameterType : parameterTypes) {\n            Inject annotation = findInject(annotationsIterator.next());\n            String name = annotation == null ? defaultName : annotation.value();\n            Key<?> key = Key.newInstance(parameterType, name);\n            parameterInjectors.add(createParameterInjector(key, member));\n        }\n\n        return toArray(parameterInjectors);\n    }\n\n    <T> ParameterInjector<T> createParameterInjector(Key<T> key, Member member) throws MissingDependencyException {\n        final InternalFactory<? extends T> factory = getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + member + \".\");\n        }\n\n        final ExternalContext<T> externalContext = ExternalContext.newInstance(member, key, this);\n        return new ParameterInjector<>(externalContext, factory);\n    }\n\n    private ParameterInjector<?>[] toArray(List<ParameterInjector<?>> parameterInjections) {\n        return parameterInjections.toArray(new ParameterInjector[0]);\n    }\n\n    /**\n     * Finds the {@link Inject} annotation in an array of annotations.\n     */\n    Inject findInject(Annotation[] annotations) {\n        for (Annotation annotation : annotations) {\n            if (annotation.annotationType() == Inject.class) {\n                return (Inject) annotation;\n            }\n        }\n        return null;\n    }\n\nstatic class MethodInjector implements Injector {\n\n    final Method method;\n    final ParameterInjector<?>[] parameterInjectors;\n\n    private MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n        this.method = method;\n        if (!isPublicForReflection(method) && !method.isAccessible()) {\n            final SecurityManager sm = System.getSecurityManager();\n            try {\n                if (sm != null) {\n                    sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                }\n                method.setAccessible(true);\n            } catch (AccessControlException e) {\n                throw new DependencyException(\"Security manager in use, could not access method: \"\n                    + name + \"(\" + method.getName() + \")\", e);\n            }\n        }\n\n        final Class<?>[] parameterTypes = method.getParameterTypes();\n        if (parameterTypes.length == 0) {\n            throw new DependencyException(method + \" has no parameters to inject.\");\n        }\n        parameterInjectors = container.getParametersInjectors(\n            method, method.getParameterAnnotations(), parameterTypes, name);\n    }\n\n    @Override\n    public void inject(InternalContext context, Object o) {\n        try {\n            method.invoke(o, getParameters(method, context, parameterInjectors));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n    Map<Class<?>, ConstructorInjector<?>> constructors = new ReferenceCache<Class<?>, ConstructorInjector<?>>() {\n        @Override\n        protected ConstructorInjector<?> create(Class<?> implementation) {\n            return new ConstructorInjector<>(ContainerImpl.this, implementation);\n        }\n    };\n\n    static class ConstructorInjector<T> {\n\n        final Class<T> implementation;\n        final List<Injector> injectors;\n        final Constructor<T> constructor;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n\n        ParameterInjector<?>[] constructParameterInjector(\n            Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n            return constructor.getParameterTypes().length == 0\n                ? null // default constructor.\n                : container.getParametersInjectors(\n                constructor,\n                constructor.getParameterAnnotations(),\n                constructor.getParameterTypes(),\n                inject.value()\n            );\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Constructor<T> findConstructorIn(Class<T> implementation) {\n            Constructor<T> found = null;\n            final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n            for (Constructor<T> constructor : declaredConstructors) {\n                if (constructor.getAnnotation(Inject.class) != null) {\n                    if (found != null) {\n                        throw new DependencyException(\"More than one constructor annotated\"\n                            + \" with @Inject found in \" + implementation + \".\");\n                    }\n                    found = constructor;\n                }\n            }\n            if (found != null) {\n                return found;\n            }\n\n            // If no annotated constructor is found, look for a no-arg constructor\n            // instead.\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n            }\n        }\n\n        /**\n         * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n         */\n        Object construct(InternalContext context, Class<? super T> expectedType) {\n            final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n            // We have a circular reference between constructors. Return a proxy.\n            if (constructionContext.isConstructing()) {\n                // TODO (crazybob): if we can't proxy this object, can we proxy the\n                // other object?\n                return constructionContext.createProxy(expectedType);\n            }\n\n            // If we're re-entering this factory while injecting fields or methods,\n            // return the same instance. This prevents infinite loops.\n            T t = constructionContext.getCurrentReference();\n            if (t != null) {\n                return t;\n            }\n\n            try {\n                // First time through...\n                constructionContext.startConstruction();\n                try {\n                    final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                    t = constructor.newInstance(parameters);\n                    constructionContext.setProxyDelegates(t);\n                } finally {\n                    constructionContext.finishConstruction();\n                }\n\n                // Store reference. If an injector re-enters this factory, they'll\n                // get the same reference.\n                constructionContext.setCurrentReference(t);\n\n                // Inject fields and methods.\n                for (Injector injector : injectors) {\n                    injector.inject(context, t);\n                }\n\n                return t;\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } finally {\n                constructionContext.removeCurrentReference();\n            }\n        }\n    }\n\n    static class ParameterInjector<T> {\n\n        final ExternalContext<T> externalContext;\n        final InternalFactory<? extends T> factory;\n\n        public ParameterInjector(ExternalContext<T> externalContext, InternalFactory<? extends T> factory) {\n            this.externalContext = externalContext;\n            this.factory = factory;\n        }\n\n        T inject(Member member, InternalContext context) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                return factory.create(context);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    private static Object[] getParameters(Member member, InternalContext context, ParameterInjector<?>[] parameterInjectors) {\n        if (parameterInjectors == null) {\n            return null;\n        }\n\n        final Object[] parameters = new Object[parameterInjectors.length];\n        for (int i = 0; i < parameters.length; i++) {\n            parameters[i] = parameterInjectors[i].inject(member, context);\n        }\n        return parameters;\n    }\n\n    void inject(Object o, InternalContext context) {\n        final List<Injector> injectors = this.injectors.get(o.getClass());\n        for (Injector injector : injectors) {\n            injector.inject(context, o);\n        }\n    }\n\n    <T> T inject(Class<T> implementation, InternalContext context) {\n        try {\n            final ConstructorInjector<T> constructor = getConstructor(implementation);\n            return implementation.cast(constructor.construct(context, implementation));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, String name, InternalContext context) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        final Key<T> key = Key.newInstance(type, name);\n        context.setExternalContext(ExternalContext.newInstance(null, key, this));\n        try {\n            final InternalFactory<? extends T> o = getFactory(key);\n            if (o != null) {\n                return getFactory(key).create(context);\n            } else {\n                return null;\n            }\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, InternalContext context) {\n        return getInstance(type, DEFAULT_NAME, context);\n    }\n\n    @Override\n    public void inject(final Object o) {\n        callInContext((ContextualCallable<Void>) context -> {\n            inject(o, context);\n            return null;\n        });\n    }\n\n    @Override\n    public <T> T inject(final Class<T> implementation) {\n        return callInContext(context -> inject(implementation, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type, final String name) {\n        return callInContext(context -> getInstance(type, name, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type) {\n        return callInContext(context -> getInstance(type, context));\n    }\n\n    @Override\n    public Set<String> getInstanceNames(final Class<?> type) {\n        Set<String> names = factoryNamesByType.get(type);\n        if (names == null) {\n            names = Collections.emptySet();\n        }\n        return names;\n    }\n\n    ThreadLocal<Object[]> localContext = ThreadLocal.withInitial(() -> new Object[1]);\n\n    /**\n     * Looks up thread local context. Creates (and removes) a new context if necessary.\n     */\n    <T> T callInContext(ContextualCallable<T> callable) {\n        final Object[] reference = localContext.get();\n        if (reference[0] == null) {\n            reference[0] = new InternalContext(this);\n            try {\n                return callable.call((InternalContext) reference[0]);\n            } finally {\n                // Only remove the context if this call created it.\n                reference[0] = null;\n                // WW-3768: ThreadLocal was not removed\n                localContext.remove();\n            }\n        } else {\n            // Someone else will clean up this context.\n            return callable.call((InternalContext) reference[0]);\n        }\n    }\n\n    interface ContextualCallable<T> {\n        T call(InternalContext context);\n    }\n\n    /**\n     * Gets a constructor function for a given implementation class.\n     */\n    @SuppressWarnings(\"unchecked\")\n    <T> ConstructorInjector<T> getConstructor(Class<T> implementation) {\n        return (ConstructorInjector<T>) constructors.get(implementation);\n    }\n\n    final ThreadLocal<Object> localScopeStrategy = new ThreadLocal<>();\n\n    @Override\n    public void setScopeStrategy(Scope.Strategy scopeStrategy) {\n        this.localScopeStrategy.set(scopeStrategy);\n    }\n\n    @Override\n    public void removeScopeStrategy() {\n        this.localScopeStrategy.remove();\n    }\n\n    /**\n     * Injects a field or method in a given object.\n     */\n    interface Injector extends Serializable {\n        void inject(InternalContext context, Object o);\n    }\n\n    static class MissingDependencyException extends Exception {\n        MissingDependencyException(String message) {\n            super(message);\n        }\n    }\n}\n"
    },
    {
        "explanation": "Class com.opensymphony.xwork2.inject.ContainerImpl$MethodInjector defines non-transient non-serializable instance field method",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 275,
        "methodEndLineNumber": 307,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n",
        "classStartLineNumber": 271,
        "classEndLineNumber": 307,
        "classCode": "    static class MethodInjector implements Injector {\n\n        final Method method;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n",
        "compositeId": "Class com.opensymphony.xwork2.inject.ContainerImpl$MethodInjector defines non-transient non-serializable instance field method-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 37,
        "status": "solved",
        "newClassCode": "/*\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.inject;\n\nimport com.opensymphony.xwork2.inject.util.ReferenceCache;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ReflectPermission;\nimport java.security.AccessControlException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n * Default {@link Container} implementation.\n *\n * @author crazybob@google.com (Bob Lee)\n * @see ContainerBuilder\n */\nclass ContainerImpl implements Container {\n\n    final Map<Key<?>, InternalFactory<?>> factories;\n    final Map<Class<?>, Set<String>> factoryNamesByType;\n\n    ContainerImpl(Map<Key<?>, InternalFactory<?>> factories) {\n        this.factories = factories;\n        final Map<Class<?>, Set<String>> map = new HashMap<>();\n        for (Key<?> key : factories.keySet()) {\n            Set<String> names = map.computeIfAbsent(key.getType(), k -> new HashSet<>());\n            names.add(key.getName());\n        }\n\n        for (Entry<Class<?>, Set<String>> entry : map.entrySet()) {\n            entry.setValue(Collections.unmodifiableSet(entry.getValue()));\n        }\n\n        this.factoryNamesByType = Collections.unmodifiableMap(map);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> InternalFactory<? extends T> getFactory(Key<T> key) {\n        return (InternalFactory<T>) factories.get(key);\n    }\n\n    /**\n     * Field and method injectors.\n     */\n    final Map<Class<?>, List<Injector>> injectors =\n        new ReferenceCache<Class<?>, List<Injector>>() {\n            @Override\n            protected List<Injector> create(Class<?> key) {\n                List<Injector> injectors = new ArrayList<>();\n                addInjectors(key, injectors);\n                return injectors;\n            }\n        };\n\n    /**\n     * Recursively adds injectors for fields and methods from the given class to the given list. Injects parent classes\n     * before sub classes.\n     */\n    void addInjectors(Class<?> clazz, List<Injector> injectors) {\n        if (clazz == Object.class) {\n            return;\n        }\n\n        // Add injectors for superclass first.\n        addInjectors(clazz.getSuperclass(), injectors);\n\n        // TODO (crazybob): Filter out overridden members.\n        addInjectorsForFields(clazz.getDeclaredFields(), false, injectors);\n        addInjectorsForMethods(clazz.getDeclaredMethods(), false, injectors);\n    }\n\n    void injectStatics(List<Class<?>> staticInjections) {\n        final List<Injector> injectors = new ArrayList<>();\n\n        for (Class<?> clazz : staticInjections) {\n            addInjectorsForFields(clazz.getDeclaredFields(), true, injectors);\n            addInjectorsForMethods(clazz.getDeclaredMethods(), true, injectors);\n        }\n\n        callInContext((ContextualCallable<Void>) context -> {\n            for (Injector injector : injectors) {\n                injector.inject(context, null);\n            }\n            return null;\n        });\n    }\n\n    void addInjectorsForMethods(Method[] methods, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(methods), statics, injectors, MethodInjector::new);\n    }\n\n    void addInjectorsForFields(Field[] fields, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(fields), statics, injectors, FieldInjector::new);\n    }\n\n    <M extends Member & AnnotatedElement> void addInjectorsForMembers(\n        List<M> members, boolean statics, List<Injector> injectors, InjectorFactory<M> injectorFactory) {\n        for (M member : members) {\n            if (isStatic(member) == statics) {\n                Inject inject = member.getAnnotation(Inject.class);\n                if (inject != null) {\n                    try {\n                        injectors.add(injectorFactory.create(this, member, inject.value()));\n                    } catch (MissingDependencyException e) {\n                        if (inject.required()) {\n                            throw new DependencyException(e);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    interface InjectorFactory<M extends Member & AnnotatedElement> {\n\n        Injector create(ContainerImpl container, M member, String name)\n            throws MissingDependencyException;\n    }\n\n    /**\n     * Determines if a given {@link Member} is static or not.\n     *\n     * @param member checked for the static modifier.\n     * @return true if member is static, false otherwise.\n     */\n    private static boolean isStatic(Member member) {\n        return Modifier.isStatic(member.getModifiers());\n    }\n\n    /**\n     * Determines if a given {@link Member} is considered to be public for reflection usage or not.\n     *\n     * @param member checked to see if it is public for reflection usage.\n     * @return true if member is public for reflection usage, false otherwise.\n     */\n    private static boolean isPublicForReflection(Member member) {\n        return Modifier.isPublic(member.getModifiers()) &&\n            Modifier.isPublic(member.getDeclaringClass().getModifiers());\n    }\n\n    static class FieldInjector implements Injector {\n\n        final Field field;\n        final InternalFactory<?> factory;\n        final ExternalContext<?> externalContext;\n\n        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    /**\n     * Gets parameter injectors.\n     *\n     * @param member         to which the parameters belong\n     * @param annotations    on the parameters\n     * @param parameterTypes parameter types\n     * @return injections\n     */\n    <M extends AccessibleObject & Member> ParameterInjector<?>[] getParametersInjectors(\n        M member,\n        Annotation[][] annotations,\n        Class<?>[] parameterTypes,\n        String defaultName\n    ) throws MissingDependencyException {\n        final List<ParameterInjector<?>> parameterInjectors = new ArrayList<>();\n\n        final Iterator<Annotation[]> annotationsIterator = Arrays.asList(annotations).iterator();\n        for (Class<?> parameterType : parameterTypes) {\n            Inject annotation = findInject(annotationsIterator.next());\n            String name = annotation == null ? defaultName : annotation.value();\n            Key<?> key = Key.newInstance(parameterType, name);\n            parameterInjectors.add(createParameterInjector(key, member));\n        }\n\n        return toArray(parameterInjectors);\n    }\n\n    <T> ParameterInjector<T> createParameterInjector(Key<T> key, Member member) throws MissingDependencyException {\n        final InternalFactory<? extends T> factory = getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + member + \".\");\n        }\n\n        final ExternalContext<T> externalContext = ExternalContext.newInstance(member, key, this);\n        return new ParameterInjector<>(externalContext, factory);\n    }\n\n    private ParameterInjector<?>[] toArray(List<ParameterInjector<?>> parameterInjections) {\n        return parameterInjections.toArray(new ParameterInjector[0]);\n    }\n\n    /**\n     * Finds the {@link Inject} annotation in an array of annotations.\n     */\n    Inject findInject(Annotation[] annotations) {\n        for (Annotation annotation : annotations) {\n            if (annotation.annotationType() == Inject.class) {\n                return (Inject) annotation;\n            }\n        }\n        return null;\n    }\n\nstatic class MethodInjector implements Injector {\n\n    final transient Method method;\n    final ParameterInjector<?>[] parameterInjectors;\n\n    public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n        this.method = method;\n        if (!isPublicForReflection(method) && !method.isAccessible()) {\n            final SecurityManager sm = System.getSecurityManager();\n            try {\n                if (sm != null) {\n                    sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                }\n                method.setAccessible(true);\n            } catch (AccessControlException e) {\n                throw new DependencyException(\"Security manager in use, could not access method: \"\n                    + name + \"(\" + method.getName() + \")\", e);\n            }\n        }\n\n        final Class<?>[] parameterTypes = method.getParameterTypes();\n        if (parameterTypes.length == 0) {\n            throw new DependencyException(method + \" has no parameters to inject.\");\n        }\n        parameterInjectors = container.getParametersInjectors(\n            method, method.getParameterAnnotations(), parameterTypes, name);\n    }\n\n    @Override\n    public void inject(InternalContext context, Object o) {\n        try {\n            method.invoke(o, getParameters(method, context, parameterInjectors));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n    Map<Class<?>, ConstructorInjector<?>> constructors = new ReferenceCache<Class<?>, ConstructorInjector<?>>() {\n        @Override\n        protected ConstructorInjector<?> create(Class<?> implementation) {\n            return new ConstructorInjector<>(ContainerImpl.this, implementation);\n        }\n    };\n\n    static class ConstructorInjector<T> {\n\n        final Class<T> implementation;\n        final List<Injector> injectors;\n        final Constructor<T> constructor;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n\n        ParameterInjector<?>[] constructParameterInjector(\n            Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n            return constructor.getParameterTypes().length == 0\n                ? null // default constructor.\n                : container.getParametersInjectors(\n                constructor,\n                constructor.getParameterAnnotations(),\n                constructor.getParameterTypes(),\n                inject.value()\n            );\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Constructor<T> findConstructorIn(Class<T> implementation) {\n            Constructor<T> found = null;\n            final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n            for (Constructor<T> constructor : declaredConstructors) {\n                if (constructor.getAnnotation(Inject.class) != null) {\n                    if (found != null) {\n                        throw new DependencyException(\"More than one constructor annotated\"\n                            + \" with @Inject found in \" + implementation + \".\");\n                    }\n                    found = constructor;\n                }\n            }\n            if (found != null) {\n                return found;\n            }\n\n            // If no annotated constructor is found, look for a no-arg constructor\n            // instead.\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n            }\n        }\n\n        /**\n         * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n         */\n        Object construct(InternalContext context, Class<? super T> expectedType) {\n            final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n            // We have a circular reference between constructors. Return a proxy.\n            if (constructionContext.isConstructing()) {\n                // TODO (crazybob): if we can't proxy this object, can we proxy the\n                // other object?\n                return constructionContext.createProxy(expectedType);\n            }\n\n            // If we're re-entering this factory while injecting fields or methods,\n            // return the same instance. This prevents infinite loops.\n            T t = constructionContext.getCurrentReference();\n            if (t != null) {\n                return t;\n            }\n\n            try {\n                // First time through...\n                constructionContext.startConstruction();\n                try {\n                    final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                    t = constructor.newInstance(parameters);\n                    constructionContext.setProxyDelegates(t);\n                } finally {\n                    constructionContext.finishConstruction();\n                }\n\n                // Store reference. If an injector re-enters this factory, they'll\n                // get the same reference.\n                constructionContext.setCurrentReference(t);\n\n                // Inject fields and methods.\n                for (Injector injector : injectors) {\n                    injector.inject(context, t);\n                }\n\n                return t;\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } finally {\n                constructionContext.removeCurrentReference();\n            }\n        }\n    }\n\n    static class ParameterInjector<T> {\n\n        final ExternalContext<T> externalContext;\n        final InternalFactory<? extends T> factory;\n\n        public ParameterInjector(ExternalContext<T> externalContext, InternalFactory<? extends T> factory) {\n            this.externalContext = externalContext;\n            this.factory = factory;\n        }\n\n        T inject(Member member, InternalContext context) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                return factory.create(context);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    private static Object[] getParameters(Member member, InternalContext context, ParameterInjector<?>[] parameterInjectors) {\n        if (parameterInjectors == null) {\n            return null;\n        }\n\n        final Object[] parameters = new Object[parameterInjectors.length];\n        for (int i = 0; i < parameters.length; i++) {\n            parameters[i] = parameterInjectors[i].inject(member, context);\n        }\n        return parameters;\n    }\n\n    void inject(Object o, InternalContext context) {\n        final List<Injector> injectors = this.injectors.get(o.getClass());\n        for (Injector injector : injectors) {\n            injector.inject(context, o);\n        }\n    }\n\n    <T> T inject(Class<T> implementation, InternalContext context) {\n        try {\n            final ConstructorInjector<T> constructor = getConstructor(implementation);\n            return implementation.cast(constructor.construct(context, implementation));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, String name, InternalContext context) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        final Key<T> key = Key.newInstance(type, name);\n        context.setExternalContext(ExternalContext.newInstance(null, key, this));\n        try {\n            final InternalFactory<? extends T> o = getFactory(key);\n            if (o != null) {\n                return getFactory(key).create(context);\n            } else {\n                return null;\n            }\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, InternalContext context) {\n        return getInstance(type, DEFAULT_NAME, context);\n    }\n\n    @Override\n    public void inject(final Object o) {\n        callInContext((ContextualCallable<Void>) context -> {\n            inject(o, context);\n            return null;\n        });\n    }\n\n    @Override\n    public <T> T inject(final Class<T> implementation) {\n        return callInContext(context -> inject(implementation, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type, final String name) {\n        return callInContext(context -> getInstance(type, name, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type) {\n        return callInContext(context -> getInstance(type, context));\n    }\n\n    @Override\n    public Set<String> getInstanceNames(final Class<?> type) {\n        Set<String> names = factoryNamesByType.get(type);\n        if (names == null) {\n            names = Collections.emptySet();\n        }\n        return names;\n    }\n\n    ThreadLocal<Object[]> localContext = ThreadLocal.withInitial(() -> new Object[1]);\n\n    /**\n     * Looks up thread local context. Creates (and removes) a new context if necessary.\n     */\n    <T> T callInContext(ContextualCallable<T> callable) {\n        final Object[] reference = localContext.get();\n        if (reference[0] == null) {\n            reference[0] = new InternalContext(this);\n            try {\n                return callable.call((InternalContext) reference[0]);\n            } finally {\n                // Only remove the context if this call created it.\n                reference[0] = null;\n                // WW-3768: ThreadLocal was not removed\n                localContext.remove();\n            }\n        } else {\n            // Someone else will clean up this context.\n            return callable.call((InternalContext) reference[0]);\n        }\n    }\n\n    interface ContextualCallable<T> {\n        T call(InternalContext context);\n    }\n\n    /**\n     * Gets a constructor function for a given implementation class.\n     */\n    @SuppressWarnings(\"unchecked\")\n    <T> ConstructorInjector<T> getConstructor(Class<T> implementation) {\n        return (ConstructorInjector<T>) constructors.get(implementation);\n    }\n\n    final ThreadLocal<Object> localScopeStrategy = new ThreadLocal<>();\n\n    @Override\n    public void setScopeStrategy(Scope.Strategy scopeStrategy) {\n        this.localScopeStrategy.set(scopeStrategy);\n    }\n\n    @Override\n    public void removeScopeStrategy() {\n        this.localScopeStrategy.remove();\n    }\n\n    /**\n     * Injects a field or method in a given object.\n     */\n    interface Injector extends Serializable {\n        void inject(InternalContext context, Object o);\n    }\n\n    static class MissingDependencyException extends Exception {\n        MissingDependencyException(String message) {\n            super(message);\n        }\n    }\n}\n"
    },
    {
        "explanation": "Class com.opensymphony.xwork2.inject.ContainerImpl$MethodInjector defines non-transient non-serializable instance field parameterInjectors",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 275,
        "methodEndLineNumber": 307,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": "\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n",
        "classStartLineNumber": 271,
        "classEndLineNumber": 307,
        "classCode": "    static class MethodInjector implements Injector {\n\n        final Method method;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n",
        "compositeId": "Class com.opensymphony.xwork2.inject.ContainerImpl$MethodInjector defines non-transient non-serializable instance field parameterInjectors-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 37,
        "status": "solved",
        "newClassCode": "/*\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.inject;\n\nimport com.opensymphony.xwork2.inject.util.ReferenceCache;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ReflectPermission;\nimport java.security.AccessControlException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n * Default {@link Container} implementation.\n *\n * @author crazybob@google.com (Bob Lee)\n * @see ContainerBuilder\n */\nclass ContainerImpl implements Container {\n\n    final Map<Key<?>, InternalFactory<?>> factories;\n    final Map<Class<?>, Set<String>> factoryNamesByType;\n\n    ContainerImpl(Map<Key<?>, InternalFactory<?>> factories) {\n        this.factories = factories;\n        final Map<Class<?>, Set<String>> map = new HashMap<>();\n        for (Key<?> key : factories.keySet()) {\n            Set<String> names = map.computeIfAbsent(key.getType(), k -> new HashSet<>());\n            names.add(key.getName());\n        }\n\n        for (Entry<Class<?>, Set<String>> entry : map.entrySet()) {\n            entry.setValue(Collections.unmodifiableSet(entry.getValue()));\n        }\n\n        this.factoryNamesByType = Collections.unmodifiableMap(map);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> InternalFactory<? extends T> getFactory(Key<T> key) {\n        return (InternalFactory<T>) factories.get(key);\n    }\n\n    /**\n     * Field and method injectors.\n     */\n    final Map<Class<?>, List<Injector>> injectors =\n        new ReferenceCache<Class<?>, List<Injector>>() {\n            @Override\n            protected List<Injector> create(Class<?> key) {\n                List<Injector> injectors = new ArrayList<>();\n                addInjectors(key, injectors);\n                return injectors;\n            }\n        };\n\n    /**\n     * Recursively adds injectors for fields and methods from the given class to the given list. Injects parent classes\n     * before sub classes.\n     */\n    void addInjectors(Class<?> clazz, List<Injector> injectors) {\n        if (clazz == Object.class) {\n            return;\n        }\n\n        // Add injectors for superclass first.\n        addInjectors(clazz.getSuperclass(), injectors);\n\n        // TODO (crazybob): Filter out overridden members.\n        addInjectorsForFields(clazz.getDeclaredFields(), false, injectors);\n        addInjectorsForMethods(clazz.getDeclaredMethods(), false, injectors);\n    }\n\n    void injectStatics(List<Class<?>> staticInjections) {\n        final List<Injector> injectors = new ArrayList<>();\n\n        for (Class<?> clazz : staticInjections) {\n            addInjectorsForFields(clazz.getDeclaredFields(), true, injectors);\n            addInjectorsForMethods(clazz.getDeclaredMethods(), true, injectors);\n        }\n\n        callInContext((ContextualCallable<Void>) context -> {\n            for (Injector injector : injectors) {\n                injector.inject(context, null);\n            }\n            return null;\n        });\n    }\n\n    void addInjectorsForMethods(Method[] methods, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(methods), statics, injectors, MethodInjector::new);\n    }\n\n    void addInjectorsForFields(Field[] fields, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(fields), statics, injectors, FieldInjector::new);\n    }\n\n    <M extends Member & AnnotatedElement> void addInjectorsForMembers(\n        List<M> members, boolean statics, List<Injector> injectors, InjectorFactory<M> injectorFactory) {\n        for (M member : members) {\n            if (isStatic(member) == statics) {\n                Inject inject = member.getAnnotation(Inject.class);\n                if (inject != null) {\n                    try {\n                        injectors.add(injectorFactory.create(this, member, inject.value()));\n                    } catch (MissingDependencyException e) {\n                        if (inject.required()) {\n                            throw new DependencyException(e);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    interface InjectorFactory<M extends Member & AnnotatedElement> {\n\n        Injector create(ContainerImpl container, M member, String name)\n            throws MissingDependencyException;\n    }\n\n    /**\n     * Determines if a given {@link Member} is static or not.\n     *\n     * @param member checked for the static modifier.\n     * @return true if member is static, false otherwise.\n     */\n    private static boolean isStatic(Member member) {\n        return Modifier.isStatic(member.getModifiers());\n    }\n\n    /**\n     * Determines if a given {@link Member} is considered to be public for reflection usage or not.\n     *\n     * @param member checked to see if it is public for reflection usage.\n     * @return true if member is public for reflection usage, false otherwise.\n     */\n    private static boolean isPublicForReflection(Member member) {\n        return Modifier.isPublic(member.getModifiers()) &&\n            Modifier.isPublic(member.getDeclaringClass().getModifiers());\n    }\n\n    static class FieldInjector implements Injector {\n\n        final Field field;\n        final InternalFactory<?> factory;\n        final ExternalContext<?> externalContext;\n\n        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    /**\n     * Gets parameter injectors.\n     *\n     * @param member         to which the parameters belong\n     * @param annotations    on the parameters\n     * @param parameterTypes parameter types\n     * @return injections\n     */\n    <M extends AccessibleObject & Member> ParameterInjector<?>[] getParametersInjectors(\n        M member,\n        Annotation[][] annotations,\n        Class<?>[] parameterTypes,\n        String defaultName\n    ) throws MissingDependencyException {\n        final List<ParameterInjector<?>> parameterInjectors = new ArrayList<>();\n\n        final Iterator<Annotation[]> annotationsIterator = Arrays.asList(annotations).iterator();\n        for (Class<?> parameterType : parameterTypes) {\n            Inject annotation = findInject(annotationsIterator.next());\n            String name = annotation == null ? defaultName : annotation.value();\n            Key<?> key = Key.newInstance(parameterType, name);\n            parameterInjectors.add(createParameterInjector(key, member));\n        }\n\n        return toArray(parameterInjectors);\n    }\n\n    <T> ParameterInjector<T> createParameterInjector(Key<T> key, Member member) throws MissingDependencyException {\n        final InternalFactory<? extends T> factory = getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + member + \".\");\n        }\n\n        final ExternalContext<T> externalContext = ExternalContext.newInstance(member, key, this);\n        return new ParameterInjector<>(externalContext, factory);\n    }\n\n    private ParameterInjector<?>[] toArray(List<ParameterInjector<?>> parameterInjections) {\n        return parameterInjections.toArray(new ParameterInjector[0]);\n    }\n\n    /**\n     * Finds the {@link Inject} annotation in an array of annotations.\n     */\n    Inject findInject(Annotation[] annotations) {\n        for (Annotation annotation : annotations) {\n            if (annotation.annotationType() == Inject.class) {\n                return (Inject) annotation;\n            }\n        }\n        return null;\n    }\n\nstatic class MethodInjector implements Injector {\n\n    final Method method;\n    final transient ParameterInjector<?>[] parameterInjectors;\n\n    public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n        this.method = method;\n        if (!isPublicForReflection(method) && !method.isAccessible()) {\n            final SecurityManager sm = System.getSecurityManager();\n            try {\n                if (sm != null) {\n                    sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                }\n                method.setAccessible(true);\n            } catch (AccessControlException e) {\n                throw new DependencyException(\"Security manager in use, could not access method: \"\n                    + name + \"(\" + method.getName() + \")\", e);\n            }\n        }\n\n        final Class<?>[] parameterTypes = method.getParameterTypes();\n        if (parameterTypes.length == 0) {\n            throw new DependencyException(method + \" has no parameters to inject.\");\n        }\n        parameterInjectors = container.getParametersInjectors(\n            method, method.getParameterAnnotations(), parameterTypes, name);\n    }\n\n    @Override\n    public void inject(InternalContext context, Object o) {\n        try {\n            method.invoke(o, getParameters(method, context, parameterInjectors));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n    Map<Class<?>, ConstructorInjector<?>> constructors = new ReferenceCache<Class<?>, ConstructorInjector<?>>() {\n        @Override\n        protected ConstructorInjector<?> create(Class<?> implementation) {\n            return new ConstructorInjector<>(ContainerImpl.this, implementation);\n        }\n    };\n\n    static class ConstructorInjector<T> {\n\n        final Class<T> implementation;\n        final List<Injector> injectors;\n        final Constructor<T> constructor;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n\n        ParameterInjector<?>[] constructParameterInjector(\n            Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n            return constructor.getParameterTypes().length == 0\n                ? null // default constructor.\n                : container.getParametersInjectors(\n                constructor,\n                constructor.getParameterAnnotations(),\n                constructor.getParameterTypes(),\n                inject.value()\n            );\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Constructor<T> findConstructorIn(Class<T> implementation) {\n            Constructor<T> found = null;\n            final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n            for (Constructor<T> constructor : declaredConstructors) {\n                if (constructor.getAnnotation(Inject.class) != null) {\n                    if (found != null) {\n                        throw new DependencyException(\"More than one constructor annotated\"\n                            + \" with @Inject found in \" + implementation + \".\");\n                    }\n                    found = constructor;\n                }\n            }\n            if (found != null) {\n                return found;\n            }\n\n            // If no annotated constructor is found, look for a no-arg constructor\n            // instead.\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n            }\n        }\n\n        /**\n         * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n         */\n        Object construct(InternalContext context, Class<? super T> expectedType) {\n            final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n            // We have a circular reference between constructors. Return a proxy.\n            if (constructionContext.isConstructing()) {\n                // TODO (crazybob): if we can't proxy this object, can we proxy the\n                // other object?\n                return constructionContext.createProxy(expectedType);\n            }\n\n            // If we're re-entering this factory while injecting fields or methods,\n            // return the same instance. This prevents infinite loops.\n            T t = constructionContext.getCurrentReference();\n            if (t != null) {\n                return t;\n            }\n\n            try {\n                // First time through...\n                constructionContext.startConstruction();\n                try {\n                    final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                    t = constructor.newInstance(parameters);\n                    constructionContext.setProxyDelegates(t);\n                } finally {\n                    constructionContext.finishConstruction();\n                }\n\n                // Store reference. If an injector re-enters this factory, they'll\n                // get the same reference.\n                constructionContext.setCurrentReference(t);\n\n                // Inject fields and methods.\n                for (Injector injector : injectors) {\n                    injector.inject(context, t);\n                }\n\n                return t;\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } finally {\n                constructionContext.removeCurrentReference();\n            }\n        }\n    }\n\n    static class ParameterInjector<T> {\n\n        final ExternalContext<T> externalContext;\n        final InternalFactory<? extends T> factory;\n\n        public ParameterInjector(ExternalContext<T> externalContext, InternalFactory<? extends T> factory) {\n            this.externalContext = externalContext;\n            this.factory = factory;\n        }\n\n        T inject(Member member, InternalContext context) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                return factory.create(context);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    private static Object[] getParameters(Member member, InternalContext context, ParameterInjector<?>[] parameterInjectors) {\n        if (parameterInjectors == null) {\n            return null;\n        }\n\n        final Object[] parameters = new Object[parameterInjectors.length];\n        for (int i = 0; i < parameters.length; i++) {\n            parameters[i] = parameterInjectors[i].inject(member, context);\n        }\n        return parameters;\n    }\n\n    void inject(Object o, InternalContext context) {\n        final List<Injector> injectors = this.injectors.get(o.getClass());\n        for (Injector injector : injectors) {\n            injector.inject(context, o);\n        }\n    }\n\n    <T> T inject(Class<T> implementation, InternalContext context) {\n        try {\n            final ConstructorInjector<T> constructor = getConstructor(implementation);\n            return implementation.cast(constructor.construct(context, implementation));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, String name, InternalContext context) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        final Key<T> key = Key.newInstance(type, name);\n        context.setExternalContext(ExternalContext.newInstance(null, key, this));\n        try {\n            final InternalFactory<? extends T> o = getFactory(key);\n            if (o != null) {\n                return getFactory(key).create(context);\n            } else {\n                return null;\n            }\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, InternalContext context) {\n        return getInstance(type, DEFAULT_NAME, context);\n    }\n\n    @Override\n    public void inject(final Object o) {\n        callInContext((ContextualCallable<Void>) context -> {\n            inject(o, context);\n            return null;\n        });\n    }\n\n    @Override\n    public <T> T inject(final Class<T> implementation) {\n        return callInContext(context -> inject(implementation, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type, final String name) {\n        return callInContext(context -> getInstance(type, name, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type) {\n        return callInContext(context -> getInstance(type, context));\n    }\n\n    @Override\n    public Set<String> getInstanceNames(final Class<?> type) {\n        Set<String> names = factoryNamesByType.get(type);\n        if (names == null) {\n            names = Collections.emptySet();\n        }\n        return names;\n    }\n\n    ThreadLocal<Object[]> localContext = ThreadLocal.withInitial(() -> new Object[1]);\n\n    /**\n     * Looks up thread local context. Creates (and removes) a new context if necessary.\n     */\n    <T> T callInContext(ContextualCallable<T> callable) {\n        final Object[] reference = localContext.get();\n        if (reference[0] == null) {\n            reference[0] = new InternalContext(this);\n            try {\n                return callable.call((InternalContext) reference[0]);\n            } finally {\n                // Only remove the context if this call created it.\n                reference[0] = null;\n                // WW-3768: ThreadLocal was not removed\n                localContext.remove();\n            }\n        } else {\n            // Someone else will clean up this context.\n            return callable.call((InternalContext) reference[0]);\n        }\n    }\n\n    interface ContextualCallable<T> {\n        T call(InternalContext context);\n    }\n\n    /**\n     * Gets a constructor function for a given implementation class.\n     */\n    @SuppressWarnings(\"unchecked\")\n    <T> ConstructorInjector<T> getConstructor(Class<T> implementation) {\n        return (ConstructorInjector<T>) constructors.get(implementation);\n    }\n\n    final ThreadLocal<Object> localScopeStrategy = new ThreadLocal<>();\n\n    @Override\n    public void setScopeStrategy(Scope.Strategy scopeStrategy) {\n        this.localScopeStrategy.set(scopeStrategy);\n    }\n\n    @Override\n    public void removeScopeStrategy() {\n        this.localScopeStrategy.remove();\n    }\n\n    /**\n     * Injects a field or method in a given object.\n     */\n    interface Injector extends Serializable {\n        void inject(InternalContext context, Object o);\n    }\n\n    static class MissingDependencyException extends Exception {\n        MissingDependencyException(String message) {\n            super(message);\n        }\n    }\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.inject.ContainerImpl$MethodInjector is Serializable; consider declaring a serialVersionUID",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 275,
        "methodEndLineNumber": 307,
        "warning_type": "SE_NO_SERIALVERSIONID",
        "codeSnippet": "\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n",
        "classStartLineNumber": 271,
        "classEndLineNumber": 307,
        "classCode": "    static class MethodInjector implements Injector {\n\n        final Method method;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n",
        "compositeId": "com.opensymphony.xwork2.inject.ContainerImpl$MethodInjector is Serializable; consider declaring a serialVersionUID-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 37,
        "status": "solved",
        "newClassCode": "/*\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.inject;\n\nimport com.opensymphony.xwork2.inject.util.ReferenceCache;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ReflectPermission;\nimport java.security.AccessControlException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n * Default {@link Container} implementation.\n *\n * @author crazybob@google.com (Bob Lee)\n * @see ContainerBuilder\n */\nclass ContainerImpl implements Container {\n\n    final Map<Key<?>, InternalFactory<?>> factories;\n    final Map<Class<?>, Set<String>> factoryNamesByType;\n\n    ContainerImpl(Map<Key<?>, InternalFactory<?>> factories) {\n        this.factories = factories;\n        final Map<Class<?>, Set<String>> map = new HashMap<>();\n        for (Key<?> key : factories.keySet()) {\n            Set<String> names = map.computeIfAbsent(key.getType(), k -> new HashSet<>());\n            names.add(key.getName());\n        }\n\n        for (Entry<Class<?>, Set<String>> entry : map.entrySet()) {\n            entry.setValue(Collections.unmodifiableSet(entry.getValue()));\n        }\n\n        this.factoryNamesByType = Collections.unmodifiableMap(map);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> InternalFactory<? extends T> getFactory(Key<T> key) {\n        return (InternalFactory<T>) factories.get(key);\n    }\n\n    /**\n     * Field and method injectors.\n     */\n    final Map<Class<?>, List<Injector>> injectors =\n        new ReferenceCache<Class<?>, List<Injector>>() {\n            @Override\n            protected List<Injector> create(Class<?> key) {\n                List<Injector> injectors = new ArrayList<>();\n                addInjectors(key, injectors);\n                return injectors;\n            }\n        };\n\n    /**\n     * Recursively adds injectors for fields and methods from the given class to the given list. Injects parent classes\n     * before sub classes.\n     */\n    void addInjectors(Class<?> clazz, List<Injector> injectors) {\n        if (clazz == Object.class) {\n            return;\n        }\n\n        // Add injectors for superclass first.\n        addInjectors(clazz.getSuperclass(), injectors);\n\n        // TODO (crazybob): Filter out overridden members.\n        addInjectorsForFields(clazz.getDeclaredFields(), false, injectors);\n        addInjectorsForMethods(clazz.getDeclaredMethods(), false, injectors);\n    }\n\n    void injectStatics(List<Class<?>> staticInjections) {\n        final List<Injector> injectors = new ArrayList<>();\n\n        for (Class<?> clazz : staticInjections) {\n            addInjectorsForFields(clazz.getDeclaredFields(), true, injectors);\n            addInjectorsForMethods(clazz.getDeclaredMethods(), true, injectors);\n        }\n\n        callInContext((ContextualCallable<Void>) context -> {\n            for (Injector injector : injectors) {\n                injector.inject(context, null);\n            }\n            return null;\n        });\n    }\n\n    void addInjectorsForMethods(Method[] methods, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(methods), statics, injectors, MethodInjector::new);\n    }\n\n    void addInjectorsForFields(Field[] fields, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(fields), statics, injectors, FieldInjector::new);\n    }\n\n    <M extends Member & AnnotatedElement> void addInjectorsForMembers(\n        List<M> members, boolean statics, List<Injector> injectors, InjectorFactory<M> injectorFactory) {\n        for (M member : members) {\n            if (isStatic(member) == statics) {\n                Inject inject = member.getAnnotation(Inject.class);\n                if (inject != null) {\n                    try {\n                        injectors.add(injectorFactory.create(this, member, inject.value()));\n                    } catch (MissingDependencyException e) {\n                        if (inject.required()) {\n                            throw new DependencyException(e);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    interface InjectorFactory<M extends Member & AnnotatedElement> {\n\n        Injector create(ContainerImpl container, M member, String name)\n            throws MissingDependencyException;\n    }\n\n    /**\n     * Determines if a given {@link Member} is static or not.\n     *\n     * @param member checked for the static modifier.\n     * @return true if member is static, false otherwise.\n     */\n    private static boolean isStatic(Member member) {\n        return Modifier.isStatic(member.getModifiers());\n    }\n\n    /**\n     * Determines if a given {@link Member} is considered to be public for reflection usage or not.\n     *\n     * @param member checked to see if it is public for reflection usage.\n     * @return true if member is public for reflection usage, false otherwise.\n     */\n    private static boolean isPublicForReflection(Member member) {\n        return Modifier.isPublic(member.getModifiers()) &&\n            Modifier.isPublic(member.getDeclaringClass().getModifiers());\n    }\n\n    static class FieldInjector implements Injector {\n\n        final Field field;\n        final InternalFactory<?> factory;\n        final ExternalContext<?> externalContext;\n\n        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    /**\n     * Gets parameter injectors.\n     *\n     * @param member         to which the parameters belong\n     * @param annotations    on the parameters\n     * @param parameterTypes parameter types\n     * @return injections\n     */\n    <M extends AccessibleObject & Member> ParameterInjector<?>[] getParametersInjectors(\n        M member,\n        Annotation[][] annotations,\n        Class<?>[] parameterTypes,\n        String defaultName\n    ) throws MissingDependencyException {\n        final List<ParameterInjector<?>> parameterInjectors = new ArrayList<>();\n\n        final Iterator<Annotation[]> annotationsIterator = Arrays.asList(annotations).iterator();\n        for (Class<?> parameterType : parameterTypes) {\n            Inject annotation = findInject(annotationsIterator.next());\n            String name = annotation == null ? defaultName : annotation.value();\n            Key<?> key = Key.newInstance(parameterType, name);\n            parameterInjectors.add(createParameterInjector(key, member));\n        }\n\n        return toArray(parameterInjectors);\n    }\n\n    <T> ParameterInjector<T> createParameterInjector(Key<T> key, Member member) throws MissingDependencyException {\n        final InternalFactory<? extends T> factory = getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + member + \".\");\n        }\n\n        final ExternalContext<T> externalContext = ExternalContext.newInstance(member, key, this);\n        return new ParameterInjector<>(externalContext, factory);\n    }\n\n    private ParameterInjector<?>[] toArray(List<ParameterInjector<?>> parameterInjections) {\n        return parameterInjections.toArray(new ParameterInjector[0]);\n    }\n\n    /**\n     * Finds the {@link Inject} annotation in an array of annotations.\n     */\n    Inject findInject(Annotation[] annotations) {\n        for (Annotation annotation : annotations) {\n            if (annotation.annotationType() == Inject.class) {\n                return (Inject) annotation;\n            }\n        }\n        return null;\n    }\n\nstatic class MethodInjector implements Injector, Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    final Method method;\n    final ParameterInjector<?>[] parameterInjectors;\n\n    public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n        this.method = method;\n        if (!isPublicForReflection(method) && !method.isAccessible()) {\n            final SecurityManager sm = System.getSecurityManager();\n            try {\n                if (sm != null) {\n                    sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                }\n                method.setAccessible(true);\n            } catch (AccessControlException e) {\n                throw new DependencyException(\"Security manager in use, could not access method: \"\n                    + name + \"(\" + method.getName() + \")\", e);\n            }\n        }\n\n        final Class<?>[] parameterTypes = method.getParameterTypes();\n        if (parameterTypes.length == 0) {\n            throw new DependencyException(method + \" has no parameters to inject.\");\n        }\n        parameterInjectors = container.getParametersInjectors(\n            method, method.getParameterAnnotations(), parameterTypes, name);\n    }\n\n    @Override\n    public void inject(InternalContext context, Object o) {\n        try {\n            method.invoke(o, getParameters(method, context, parameterInjectors));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n    Map<Class<?>, ConstructorInjector<?>> constructors = new ReferenceCache<Class<?>, ConstructorInjector<?>>() {\n        @Override\n        protected ConstructorInjector<?> create(Class<?> implementation) {\n            return new ConstructorInjector<>(ContainerImpl.this, implementation);\n        }\n    };\n\n    static class ConstructorInjector<T> {\n\n        final Class<T> implementation;\n        final List<Injector> injectors;\n        final Constructor<T> constructor;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n\n        ParameterInjector<?>[] constructParameterInjector(\n            Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n            return constructor.getParameterTypes().length == 0\n                ? null // default constructor.\n                : container.getParametersInjectors(\n                constructor,\n                constructor.getParameterAnnotations(),\n                constructor.getParameterTypes(),\n                inject.value()\n            );\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Constructor<T> findConstructorIn(Class<T> implementation) {\n            Constructor<T> found = null;\n            final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n            for (Constructor<T> constructor : declaredConstructors) {\n                if (constructor.getAnnotation(Inject.class) != null) {\n                    if (found != null) {\n                        throw new DependencyException(\"More than one constructor annotated\"\n                            + \" with @Inject found in \" + implementation + \".\");\n                    }\n                    found = constructor;\n                }\n            }\n            if (found != null) {\n                return found;\n            }\n\n            // If no annotated constructor is found, look for a no-arg constructor\n            // instead.\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n            }\n        }\n\n        /**\n         * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n         */\n        Object construct(InternalContext context, Class<? super T> expectedType) {\n            final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n            // We have a circular reference between constructors. Return a proxy.\n            if (constructionContext.isConstructing()) {\n                // TODO (crazybob): if we can't proxy this object, can we proxy the\n                // other object?\n                return constructionContext.createProxy(expectedType);\n            }\n\n            // If we're re-entering this factory while injecting fields or methods,\n            // return the same instance. This prevents infinite loops.\n            T t = constructionContext.getCurrentReference();\n            if (t != null) {\n                return t;\n            }\n\n            try {\n                // First time through...\n                constructionContext.startConstruction();\n                try {\n                    final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                    t = constructor.newInstance(parameters);\n                    constructionContext.setProxyDelegates(t);\n                } finally {\n                    constructionContext.finishConstruction();\n                }\n\n                // Store reference. If an injector re-enters this factory, they'll\n                // get the same reference.\n                constructionContext.setCurrentReference(t);\n\n                // Inject fields and methods.\n                for (Injector injector : injectors) {\n                    injector.inject(context, t);\n                }\n\n                return t;\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } finally {\n                constructionContext.removeCurrentReference();\n            }\n        }\n    }\n\n    static class ParameterInjector<T> {\n\n        final ExternalContext<T> externalContext;\n        final InternalFactory<? extends T> factory;\n\n        public ParameterInjector(ExternalContext<T> externalContext, InternalFactory<? extends T> factory) {\n            this.externalContext = externalContext;\n            this.factory = factory;\n        }\n\n        T inject(Member member, InternalContext context) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                return factory.create(context);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    private static Object[] getParameters(Member member, InternalContext context, ParameterInjector<?>[] parameterInjectors) {\n        if (parameterInjectors == null) {\n            return null;\n        }\n\n        final Object[] parameters = new Object[parameterInjectors.length];\n        for (int i = 0; i < parameters.length; i++) {\n            parameters[i] = parameterInjectors[i].inject(member, context);\n        }\n        return parameters;\n    }\n\n    void inject(Object o, InternalContext context) {\n        final List<Injector> injectors = this.injectors.get(o.getClass());\n        for (Injector injector : injectors) {\n            injector.inject(context, o);\n        }\n    }\n\n    <T> T inject(Class<T> implementation, InternalContext context) {\n        try {\n            final ConstructorInjector<T> constructor = getConstructor(implementation);\n            return implementation.cast(constructor.construct(context, implementation));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, String name, InternalContext context) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        final Key<T> key = Key.newInstance(type, name);\n        context.setExternalContext(ExternalContext.newInstance(null, key, this));\n        try {\n            final InternalFactory<? extends T> o = getFactory(key);\n            if (o != null) {\n                return getFactory(key).create(context);\n            } else {\n                return null;\n            }\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, InternalContext context) {\n        return getInstance(type, DEFAULT_NAME, context);\n    }\n\n    @Override\n    public void inject(final Object o) {\n        callInContext((ContextualCallable<Void>) context -> {\n            inject(o, context);\n            return null;\n        });\n    }\n\n    @Override\n    public <T> T inject(final Class<T> implementation) {\n        return callInContext(context -> inject(implementation, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type, final String name) {\n        return callInContext(context -> getInstance(type, name, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type) {\n        return callInContext(context -> getInstance(type, context));\n    }\n\n    @Override\n    public Set<String> getInstanceNames(final Class<?> type) {\n        Set<String> names = factoryNamesByType.get(type);\n        if (names == null) {\n            names = Collections.emptySet();\n        }\n        return names;\n    }\n\n    ThreadLocal<Object[]> localContext = ThreadLocal.withInitial(() -> new Object[1]);\n\n    /**\n     * Looks up thread local context. Creates (and removes) a new context if necessary.\n     */\n    <T> T callInContext(ContextualCallable<T> callable) {\n        final Object[] reference = localContext.get();\n        if (reference[0] == null) {\n            reference[0] = new InternalContext(this);\n            try {\n                return callable.call((InternalContext) reference[0]);\n            } finally {\n                // Only remove the context if this call created it.\n                reference[0] = null;\n                // WW-3768: ThreadLocal was not removed\n                localContext.remove();\n            }\n        } else {\n            // Someone else will clean up this context.\n            return callable.call((InternalContext) reference[0]);\n        }\n    }\n\n    interface ContextualCallable<T> {\n        T call(InternalContext context);\n    }\n\n    /**\n     * Gets a constructor function for a given implementation class.\n     */\n    @SuppressWarnings(\"unchecked\")\n    <T> ConstructorInjector<T> getConstructor(Class<T> implementation) {\n        return (ConstructorInjector<T>) constructors.get(implementation);\n    }\n\n    final ThreadLocal<Object> localScopeStrategy = new ThreadLocal<>();\n\n    @Override\n    public void setScopeStrategy(Scope.Strategy scopeStrategy) {\n        this.localScopeStrategy.set(scopeStrategy);\n    }\n\n    @Override\n    public void removeScopeStrategy() {\n        this.localScopeStrategy.remove();\n    }\n\n    /**\n     * Injects a field or method in a given object.\n     */\n    interface Injector extends Serializable {\n        void inject(InternalContext context, Object o);\n    }\n\n    static class MissingDependencyException extends Exception {\n        MissingDependencyException(String message) {\n            super(message);\n        }\n    }\n}\n"
    },
    {
        "explanation": "The method 'new com.opensymphony.xwork2.inject.ContainerImpl$MethodInjector(ContainerImpl, Method, String)' performs security check by using 'SecurityManager.checkPermission(Permission)' method of Security Manager Class, but is overrideable. Declare the method final or private in order to resolve the issue.",
        "fileName": "com/opensymphony/xwork2/inject/ContainerImpl.java",
        "methodStartLineNumber": 275,
        "methodEndLineNumber": 298,
        "warning_type": "VSC_VULNERABLE_SECURITY_CHECK_METHODS",
        "codeSnippet": "\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n",
        "classStartLineNumber": 271,
        "classEndLineNumber": 307,
        "classCode": "    static class MethodInjector implements Injector {\n\n        final Method method;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        public MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n            this.method = method;\n            if (!isPublicForReflection(method) && !method.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    method.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access method: \"\n                        + name + \"(\" + method.getName() + \")\", e);\n                }\n            }\n\n            final Class<?>[] parameterTypes = method.getParameterTypes();\n            if (parameterTypes.length == 0) {\n                throw new DependencyException(method + \" has no parameters to inject.\");\n            }\n            parameterInjectors = container.getParametersInjectors(\n                method, method.getParameterAnnotations(), parameterTypes, name);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            try {\n                method.invoke(o, getParameters(method, context, parameterInjectors));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n",
        "compositeId": "The method 'new com.opensymphony.xwork2.inject.ContainerImpl$MethodInjector(ContainerImpl, Method, String)' performs security check by using 'SecurityManager.checkPermission(Permission)' method of Security Manager Class, but is overrideable. Declare the method final or private in order to resolve the issue.-com/opensymphony/xwork2/inject/ContainerImpl.java",
        "classSize": 37,
        "status": "solved",
        "newClassCode": "/*\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.inject;\n\nimport com.opensymphony.xwork2.inject.util.ReferenceCache;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ReflectPermission;\nimport java.security.AccessControlException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n * Default {@link Container} implementation.\n *\n * @author crazybob@google.com (Bob Lee)\n * @see ContainerBuilder\n */\nclass ContainerImpl implements Container {\n\n    final Map<Key<?>, InternalFactory<?>> factories;\n    final Map<Class<?>, Set<String>> factoryNamesByType;\n\n    ContainerImpl(Map<Key<?>, InternalFactory<?>> factories) {\n        this.factories = factories;\n        final Map<Class<?>, Set<String>> map = new HashMap<>();\n        for (Key<?> key : factories.keySet()) {\n            Set<String> names = map.computeIfAbsent(key.getType(), k -> new HashSet<>());\n            names.add(key.getName());\n        }\n\n        for (Entry<Class<?>, Set<String>> entry : map.entrySet()) {\n            entry.setValue(Collections.unmodifiableSet(entry.getValue()));\n        }\n\n        this.factoryNamesByType = Collections.unmodifiableMap(map);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> InternalFactory<? extends T> getFactory(Key<T> key) {\n        return (InternalFactory<T>) factories.get(key);\n    }\n\n    /**\n     * Field and method injectors.\n     */\n    final Map<Class<?>, List<Injector>> injectors =\n        new ReferenceCache<Class<?>, List<Injector>>() {\n            @Override\n            protected List<Injector> create(Class<?> key) {\n                List<Injector> injectors = new ArrayList<>();\n                addInjectors(key, injectors);\n                return injectors;\n            }\n        };\n\n    /**\n     * Recursively adds injectors for fields and methods from the given class to the given list. Injects parent classes\n     * before sub classes.\n     */\n    void addInjectors(Class<?> clazz, List<Injector> injectors) {\n        if (clazz == Object.class) {\n            return;\n        }\n\n        // Add injectors for superclass first.\n        addInjectors(clazz.getSuperclass(), injectors);\n\n        // TODO (crazybob): Filter out overridden members.\n        addInjectorsForFields(clazz.getDeclaredFields(), false, injectors);\n        addInjectorsForMethods(clazz.getDeclaredMethods(), false, injectors);\n    }\n\n    void injectStatics(List<Class<?>> staticInjections) {\n        final List<Injector> injectors = new ArrayList<>();\n\n        for (Class<?> clazz : staticInjections) {\n            addInjectorsForFields(clazz.getDeclaredFields(), true, injectors);\n            addInjectorsForMethods(clazz.getDeclaredMethods(), true, injectors);\n        }\n\n        callInContext((ContextualCallable<Void>) context -> {\n            for (Injector injector : injectors) {\n                injector.inject(context, null);\n            }\n            return null;\n        });\n    }\n\n    void addInjectorsForMethods(Method[] methods, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(methods), statics, injectors, MethodInjector::new);\n    }\n\n    void addInjectorsForFields(Field[] fields, boolean statics, List<Injector> injectors) {\n        addInjectorsForMembers(Arrays.asList(fields), statics, injectors, FieldInjector::new);\n    }\n\n    <M extends Member & AnnotatedElement> void addInjectorsForMembers(\n        List<M> members, boolean statics, List<Injector> injectors, InjectorFactory<M> injectorFactory) {\n        for (M member : members) {\n            if (isStatic(member) == statics) {\n                Inject inject = member.getAnnotation(Inject.class);\n                if (inject != null) {\n                    try {\n                        injectors.add(injectorFactory.create(this, member, inject.value()));\n                    } catch (MissingDependencyException e) {\n                        if (inject.required()) {\n                            throw new DependencyException(e);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    interface InjectorFactory<M extends Member & AnnotatedElement> {\n\n        Injector create(ContainerImpl container, M member, String name)\n            throws MissingDependencyException;\n    }\n\n    /**\n     * Determines if a given {@link Member} is static or not.\n     *\n     * @param member checked for the static modifier.\n     * @return true if member is static, false otherwise.\n     */\n    private static boolean isStatic(Member member) {\n        return Modifier.isStatic(member.getModifiers());\n    }\n\n    /**\n     * Determines if a given {@link Member} is considered to be public for reflection usage or not.\n     *\n     * @param member checked to see if it is public for reflection usage.\n     * @return true if member is public for reflection usage, false otherwise.\n     */\n    private static boolean isPublicForReflection(Member member) {\n        return Modifier.isPublic(member.getModifiers()) &&\n            Modifier.isPublic(member.getDeclaringClass().getModifiers());\n    }\n\n    static class FieldInjector implements Injector {\n\n        final Field field;\n        final InternalFactory<?> factory;\n        final ExternalContext<?> externalContext;\n\n        public FieldInjector(ContainerImpl container, Field field, String name)\n            throws MissingDependencyException {\n            this.field = field;\n            if (!isPublicForReflection(field) && !field.isAccessible()) {\n                SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    field.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access field: \"\n                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n                }\n            }\n\n            final Key<?> key = Key.newInstance(field.getType(), name);\n            factory = container.getFactory(key);\n            if (factory == null) {\n                throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + field + \".\");\n            }\n\n            this.externalContext = ExternalContext.newInstance(field, key, container);\n        }\n\n        @Override\n        public void inject(InternalContext context, Object o) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                field.set(o, factory.create(context));\n            } catch (IllegalAccessException e) {\n                throw new AssertionError(e);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    /**\n     * Gets parameter injectors.\n     *\n     * @param member         to which the parameters belong\n     * @param annotations    on the parameters\n     * @param parameterTypes parameter types\n     * @return injections\n     */\n    <M extends AccessibleObject & Member> ParameterInjector<?>[] getParametersInjectors(\n        M member,\n        Annotation[][] annotations,\n        Class<?>[] parameterTypes,\n        String defaultName\n    ) throws MissingDependencyException {\n        final List<ParameterInjector<?>> parameterInjectors = new ArrayList<>();\n\n        final Iterator<Annotation[]> annotationsIterator = Arrays.asList(annotations).iterator();\n        for (Class<?> parameterType : parameterTypes) {\n            Inject annotation = findInject(annotationsIterator.next());\n            String name = annotation == null ? defaultName : annotation.value();\n            Key<?> key = Key.newInstance(parameterType, name);\n            parameterInjectors.add(createParameterInjector(key, member));\n        }\n\n        return toArray(parameterInjectors);\n    }\n\n    <T> ParameterInjector<T> createParameterInjector(Key<T> key, Member member) throws MissingDependencyException {\n        final InternalFactory<? extends T> factory = getFactory(key);\n        if (factory == null) {\n            throw new MissingDependencyException(\"No mapping found for dependency \" + key + \" in \" + member + \".\");\n        }\n\n        final ExternalContext<T> externalContext = ExternalContext.newInstance(member, key, this);\n        return new ParameterInjector<>(externalContext, factory);\n    }\n\n    private ParameterInjector<?>[] toArray(List<ParameterInjector<?>> parameterInjections) {\n        return parameterInjections.toArray(new ParameterInjector[0]);\n    }\n\n    /**\n     * Finds the {@link Inject} annotation in an array of annotations.\n     */\n    Inject findInject(Annotation[] annotations) {\n        for (Annotation annotation : annotations) {\n            if (annotation.annotationType() == Inject.class) {\n                return (Inject) annotation;\n            }\n        }\n        return null;\n    }\n\nstatic class MethodInjector implements Injector {\n\n    final Method method;\n    final ParameterInjector<?>[] parameterInjectors;\n\n    private MethodInjector(ContainerImpl container, Method method, String name) throws MissingDependencyException {\n        this.method = method;\n        if (!isPublicForReflection(method) && !method.isAccessible()) {\n            final SecurityManager sm = System.getSecurityManager();\n            try {\n                if (sm != null) {\n                    sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                }\n                method.setAccessible(true);\n            } catch (AccessControlException e) {\n                throw new DependencyException(\"Security manager in use, could not access method: \"\n                    + name + \"(\" + method.getName() + \")\", e);\n            }\n        }\n\n        final Class<?>[] parameterTypes = method.getParameterTypes();\n        if (parameterTypes.length == 0) {\n            throw new DependencyException(method + \" has no parameters to inject.\");\n        }\n        parameterInjectors = container.getParametersInjectors(\n            method, method.getParameterAnnotations(), parameterTypes, name);\n    }\n\n    @Override\n    public void inject(InternalContext context, Object o) {\n        try {\n            method.invoke(o, getParameters(method, context, parameterInjectors));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n    Map<Class<?>, ConstructorInjector<?>> constructors = new ReferenceCache<Class<?>, ConstructorInjector<?>>() {\n        @Override\n        protected ConstructorInjector<?> create(Class<?> implementation) {\n            return new ConstructorInjector<>(ContainerImpl.this, implementation);\n        }\n    };\n\n    static class ConstructorInjector<T> {\n\n        final Class<T> implementation;\n        final List<Injector> injectors;\n        final Constructor<T> constructor;\n        final ParameterInjector<?>[] parameterInjectors;\n\n        ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n            this.implementation = implementation;\n\n            constructor = findConstructorIn(implementation);\n            if (!isPublicForReflection(constructor) && !constructor.isAccessible()) {\n                final SecurityManager sm = System.getSecurityManager();\n                try {\n                    if (sm != null) {\n                        sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n                    }\n                    constructor.setAccessible(true);\n                } catch (AccessControlException e) {\n                    throw new DependencyException(\"Security manager in use, could not access constructor: \"\n                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n                }\n            }\n\n            MissingDependencyException exception = null;\n            Inject inject = null;\n            ParameterInjector<?>[] parameters = null;\n\n            try {\n                inject = constructor.getAnnotation(Inject.class);\n                parameters = constructParameterInjector(inject, container, constructor);\n            } catch (MissingDependencyException e) {\n                exception = e;\n            }\n            parameterInjectors = parameters;\n\n            if (exception != null) {\n                if (inject != null && inject.required()) {\n                    throw new DependencyException(exception);\n                }\n            }\n            injectors = container.injectors.get(implementation);\n        }\n\n        ParameterInjector<?>[] constructParameterInjector(\n            Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException {\n            return constructor.getParameterTypes().length == 0\n                ? null // default constructor.\n                : container.getParametersInjectors(\n                constructor,\n                constructor.getParameterAnnotations(),\n                constructor.getParameterTypes(),\n                inject.value()\n            );\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private Constructor<T> findConstructorIn(Class<T> implementation) {\n            Constructor<T> found = null;\n            final Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation.getDeclaredConstructors();\n            for (Constructor<T> constructor : declaredConstructors) {\n                if (constructor.getAnnotation(Inject.class) != null) {\n                    if (found != null) {\n                        throw new DependencyException(\"More than one constructor annotated\"\n                            + \" with @Inject found in \" + implementation + \".\");\n                    }\n                    found = constructor;\n                }\n            }\n            if (found != null) {\n                return found;\n            }\n\n            // If no annotated constructor is found, look for a no-arg constructor\n            // instead.\n            try {\n                return implementation.getDeclaredConstructor();\n            } catch (NoSuchMethodException e) {\n                throw new DependencyException(\"Could not find a suitable constructor in \" + implementation.getName() + \".\");\n            }\n        }\n\n        /**\n         * Construct an instance. Returns {@code Object} instead of {@code T} because it may return a proxy.\n         */\n        Object construct(InternalContext context, Class<? super T> expectedType) {\n            final ConstructionContext<T> constructionContext = context.getConstructionContext(this);\n\n            // We have a circular reference between constructors. Return a proxy.\n            if (constructionContext.isConstructing()) {\n                // TODO (crazybob): if we can't proxy this object, can we proxy the\n                // other object?\n                return constructionContext.createProxy(expectedType);\n            }\n\n            // If we're re-entering this factory while injecting fields or methods,\n            // return the same instance. This prevents infinite loops.\n            T t = constructionContext.getCurrentReference();\n            if (t != null) {\n                return t;\n            }\n\n            try {\n                // First time through...\n                constructionContext.startConstruction();\n                try {\n                    final Object[] parameters = getParameters(constructor, context, parameterInjectors);\n                    t = constructor.newInstance(parameters);\n                    constructionContext.setProxyDelegates(t);\n                } finally {\n                    constructionContext.finishConstruction();\n                }\n\n                // Store reference. If an injector re-enters this factory, they'll\n                // get the same reference.\n                constructionContext.setCurrentReference(t);\n\n                // Inject fields and methods.\n                for (Injector injector : injectors) {\n                    injector.inject(context, t);\n                }\n\n                return t;\n            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                throw new RuntimeException(e);\n            } finally {\n                constructionContext.removeCurrentReference();\n            }\n        }\n    }\n\n    static class ParameterInjector<T> {\n\n        final ExternalContext<T> externalContext;\n        final InternalFactory<? extends T> factory;\n\n        public ParameterInjector(ExternalContext<T> externalContext, InternalFactory<? extends T> factory) {\n            this.externalContext = externalContext;\n            this.factory = factory;\n        }\n\n        T inject(Member member, InternalContext context) {\n            final ExternalContext<?> previous = context.getExternalContext();\n            context.setExternalContext(externalContext);\n            try {\n                return factory.create(context);\n            } finally {\n                context.setExternalContext(previous);\n            }\n        }\n    }\n\n    private static Object[] getParameters(Member member, InternalContext context, ParameterInjector<?>[] parameterInjectors) {\n        if (parameterInjectors == null) {\n            return null;\n        }\n\n        final Object[] parameters = new Object[parameterInjectors.length];\n        for (int i = 0; i < parameters.length; i++) {\n            parameters[i] = parameterInjectors[i].inject(member, context);\n        }\n        return parameters;\n    }\n\n    void inject(Object o, InternalContext context) {\n        final List<Injector> injectors = this.injectors.get(o.getClass());\n        for (Injector injector : injectors) {\n            injector.inject(context, o);\n        }\n    }\n\n    <T> T inject(Class<T> implementation, InternalContext context) {\n        try {\n            final ConstructorInjector<T> constructor = getConstructor(implementation);\n            return implementation.cast(constructor.construct(context, implementation));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, String name, InternalContext context) {\n        final ExternalContext<?> previous = context.getExternalContext();\n        final Key<T> key = Key.newInstance(type, name);\n        context.setExternalContext(ExternalContext.newInstance(null, key, this));\n        try {\n            final InternalFactory<? extends T> o = getFactory(key);\n            if (o != null) {\n                return getFactory(key).create(context);\n            } else {\n                return null;\n            }\n        } finally {\n            context.setExternalContext(previous);\n        }\n    }\n\n    <T> T getInstance(Class<T> type, InternalContext context) {\n        return getInstance(type, DEFAULT_NAME, context);\n    }\n\n    @Override\n    public void inject(final Object o) {\n        callInContext((ContextualCallable<Void>) context -> {\n            inject(o, context);\n            return null;\n        });\n    }\n\n    @Override\n    public <T> T inject(final Class<T> implementation) {\n        return callInContext(context -> inject(implementation, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type, final String name) {\n        return callInContext(context -> getInstance(type, name, context));\n    }\n\n    @Override\n    public <T> T getInstance(final Class<T> type) {\n        return callInContext(context -> getInstance(type, context));\n    }\n\n    @Override\n    public Set<String> getInstanceNames(final Class<?> type) {\n        Set<String> names = factoryNamesByType.get(type);\n        if (names == null) {\n            names = Collections.emptySet();\n        }\n        return names;\n    }\n\n    ThreadLocal<Object[]> localContext = ThreadLocal.withInitial(() -> new Object[1]);\n\n    /**\n     * Looks up thread local context. Creates (and removes) a new context if necessary.\n     */\n    <T> T callInContext(ContextualCallable<T> callable) {\n        final Object[] reference = localContext.get();\n        if (reference[0] == null) {\n            reference[0] = new InternalContext(this);\n            try {\n                return callable.call((InternalContext) reference[0]);\n            } finally {\n                // Only remove the context if this call created it.\n                reference[0] = null;\n                // WW-3768: ThreadLocal was not removed\n                localContext.remove();\n            }\n        } else {\n            // Someone else will clean up this context.\n            return callable.call((InternalContext) reference[0]);\n        }\n    }\n\n    interface ContextualCallable<T> {\n        T call(InternalContext context);\n    }\n\n    /**\n     * Gets a constructor function for a given implementation class.\n     */\n    @SuppressWarnings(\"unchecked\")\n    <T> ConstructorInjector<T> getConstructor(Class<T> implementation) {\n        return (ConstructorInjector<T>) constructors.get(implementation);\n    }\n\n    final ThreadLocal<Object> localScopeStrategy = new ThreadLocal<>();\n\n    @Override\n    public void setScopeStrategy(Scope.Strategy scopeStrategy) {\n        this.localScopeStrategy.set(scopeStrategy);\n    }\n\n    @Override\n    public void removeScopeStrategy() {\n        this.localScopeStrategy.remove();\n    }\n\n    /**\n     * Injects a field or method in a given object.\n     */\n    interface Injector extends Serializable {\n        void inject(InternalContext context, Object o);\n    }\n\n    static class MissingDependencyException extends Exception {\n        MissingDependencyException(String message) {\n            super(message);\n        }\n    }\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.interceptor.AliasInterceptor.setAcceptedPatterns(AcceptedPatternsChecker) may expose internal representation by storing an externally mutable object into AliasInterceptor.acceptedPatterns",
        "fileName": "com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "methodStartLineNumber": 129,
        "methodEndLineNumber": 132,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n",
        "classStartLineNumber": 94,
        "classEndLineNumber": 292,
        "classCode": "public class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.interceptor.AliasInterceptor.setAcceptedPatterns(AcceptedPatternsChecker) may expose internal representation by storing an externally mutable object into AliasInterceptor.acceptedPatterns-com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "classSize": 199
    },
    {
        "explanation": "com.opensymphony.xwork2.interceptor.AliasInterceptor.setExcludedPatterns(ExcludedPatternsChecker) may expose internal representation by storing an externally mutable object into AliasInterceptor.excludedPatterns",
        "fileName": "com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "methodStartLineNumber": 124,
        "methodEndLineNumber": 127,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n",
        "classStartLineNumber": 94,
        "classEndLineNumber": 292,
        "classCode": "public class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.interceptor.AliasInterceptor.setExcludedPatterns(ExcludedPatternsChecker) may expose internal representation by storing an externally mutable object into AliasInterceptor.excludedPatterns-com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "classSize": 199
    },
    {
        "explanation": "com.opensymphony.xwork2.interceptor.AliasInterceptor.setLocalizedTextProvider(LocalizedTextProvider) may expose internal representation by storing an externally mutable object into AliasInterceptor.localizedTextProvider",
        "fileName": "com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "methodStartLineNumber": 119,
        "methodEndLineNumber": 122,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n",
        "classStartLineNumber": 94,
        "classEndLineNumber": 292,
        "classCode": "public class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.interceptor.AliasInterceptor.setLocalizedTextProvider(LocalizedTextProvider) may expose internal representation by storing an externally mutable object into AliasInterceptor.localizedTextProvider-com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "classSize": 199
    },
    {
        "explanation": "Class com.opensymphony.xwork2.interceptor.AliasInterceptor defines non-transient non-serializable instance field acceptedPatterns",
        "fileName": "com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "methodStartLineNumber": 93,
        "methodEndLineNumber": 291,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": " */\npublic class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n",
        "classStartLineNumber": 94,
        "classEndLineNumber": 292,
        "classCode": "public class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n",
        "compositeId": "Class com.opensymphony.xwork2.interceptor.AliasInterceptor defines non-transient non-serializable instance field acceptedPatterns-com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "classSize": 199,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.security.AcceptedPatternsChecker;\nimport com.opensymphony.xwork2.security.ExcludedPatternsChecker;\nimport com.opensymphony.xwork2.util.ClearableValueStack;\nimport com.opensymphony.xwork2.util.Evaluated;\nimport com.opensymphony.xwork2.LocalizedTextProvider;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.ValueStackFactory;\nimport com.opensymphony.xwork2.util.reflection.ReflectionContextState;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.dispatcher.HttpParameters;\nimport org.apache.struts2.dispatcher.Parameter;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.util.Map;\n\n\n/**\n * <!-- START SNIPPET: description -->\n *\n * The aim of this Interceptor is to alias a named parameter to a different named parameter. By acting as the glue\n * between actions sharing similar parameters (but with different names), it can help greatly with action chaining.\n *\n * <p>Action's alias expressions should be in the form of  <code>#{ \"name1\" : \"alias1\", \"name2\" : \"alias2\" }</code>.\n * This means that assuming an action (or something else in the stack) has a value for the expression named <i>name1</i> and the\n * action this interceptor is applied to has a setter named <i>alias1</i>, <i>alias1</i> will be set with the value from\n * <i>name1</i>.\n * </p>\n *\n * <!-- END SNIPPET: description -->\n *\n * <p><u>Interceptor parameters:</u></p>\n *\n * <!-- START SNIPPET: parameters -->\n *\n * <ul>\n *\n * <li>aliasesKey (optional) - the name of the action parameter to look for the alias map (by default this is\n * <i>aliases</i>).</li>\n *\n * </ul>\n *\n * <!-- END SNIPPET: parameters -->\n *\n * <p><u>Extending the interceptor:</u></p>\n *\n * <!-- START SNIPPET: extending -->\n *\n * This interceptor does not have any known extension points.\n *\n * <!-- END SNIPPET: extending -->\n *\n * <p><u>Example code:</u></p>\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n *     &lt;!-- The value for the foo parameter will be applied as if it were named bar --&gt;\n *     &lt;param name=\"aliases\"&gt;#{ 'foo' : 'bar' }&lt;/param&gt;\n *\n *     &lt;interceptor-ref name=\"alias\"/&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n * &lt;/action&gt;\n * <!-- END SNIPPET: example -->\n * </pre>\n *\n * @author Matthew Payne\n */\npublic class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private transient ExcludedPatternsChecker excludedPatterns;\n    private transient AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n"
    },
    {
        "explanation": "Class com.opensymphony.xwork2.interceptor.AliasInterceptor defines non-transient non-serializable instance field excludedPatterns",
        "fileName": "com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "methodStartLineNumber": 93,
        "methodEndLineNumber": 291,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": " */\npublic class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n",
        "classStartLineNumber": 94,
        "classEndLineNumber": 292,
        "classCode": "public class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n",
        "compositeId": "Class com.opensymphony.xwork2.interceptor.AliasInterceptor defines non-transient non-serializable instance field excludedPatterns-com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "classSize": 199,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.security.AcceptedPatternsChecker;\nimport com.opensymphony.xwork2.security.ExcludedPatternsChecker;\nimport com.opensymphony.xwork2.util.ClearableValueStack;\nimport com.opensymphony.xwork2.util.Evaluated;\nimport com.opensymphony.xwork2.LocalizedTextProvider;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.ValueStackFactory;\nimport com.opensymphony.xwork2.util.reflection.ReflectionContextState;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.dispatcher.HttpParameters;\nimport org.apache.struts2.dispatcher.Parameter;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.util.Map;\n\n\n/**\n * <!-- START SNIPPET: description -->\n *\n * The aim of this Interceptor is to alias a named parameter to a different named parameter. By acting as the glue\n * between actions sharing similar parameters (but with different names), it can help greatly with action chaining.\n *\n * <p>Action's alias expressions should be in the form of  <code>#{ \"name1\" : \"alias1\", \"name2\" : \"alias2\" }</code>.\n * This means that assuming an action (or something else in the stack) has a value for the expression named <i>name1</i> and the\n * action this interceptor is applied to has a setter named <i>alias1</i>, <i>alias1</i> will be set with the value from\n * <i>name1</i>.\n * </p>\n *\n * <!-- END SNIPPET: description -->\n *\n * <p><u>Interceptor parameters:</u></p>\n *\n * <!-- START SNIPPET: parameters -->\n *\n * <ul>\n *\n * <li>aliasesKey (optional) - the name of the action parameter to look for the alias map (by default this is\n * <i>aliases</i>).</li>\n *\n * </ul>\n *\n * <!-- END SNIPPET: parameters -->\n *\n * <p><u>Extending the interceptor:</u></p>\n *\n * <!-- START SNIPPET: extending -->\n *\n * This interceptor does not have any known extension points.\n *\n * <!-- END SNIPPET: extending -->\n *\n * <p><u>Example code:</u></p>\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n *     &lt;!-- The value for the foo parameter will be applied as if it were named bar --&gt;\n *     &lt;param name=\"aliases\"&gt;#{ 'foo' : 'bar' }&lt;/param&gt;\n *\n *     &lt;interceptor-ref name=\"alias\"/&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n * &lt;/action&gt;\n * <!-- END SNIPPET: example -->\n * </pre>\n *\n * @author Matthew Payne\n */\npublic class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private transient ExcludedPatternsChecker excludedPatterns;\n    private transient AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n"
    },
    {
        "explanation": "Class com.opensymphony.xwork2.interceptor.AliasInterceptor defines non-transient non-serializable instance field valueStackFactory",
        "fileName": "com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "methodStartLineNumber": 93,
        "methodEndLineNumber": 291,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": " */\npublic class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n",
        "classStartLineNumber": 94,
        "classEndLineNumber": 292,
        "classCode": "public class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n",
        "compositeId": "Class com.opensymphony.xwork2.interceptor.AliasInterceptor defines non-transient non-serializable instance field valueStackFactory-com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "classSize": 199,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.security.AcceptedPatternsChecker;\nimport com.opensymphony.xwork2.security.ExcludedPatternsChecker;\nimport com.opensymphony.xwork2.util.ClearableValueStack;\nimport com.opensymphony.xwork2.util.Evaluated;\nimport com.opensymphony.xwork2.LocalizedTextProvider;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.ValueStackFactory;\nimport com.opensymphony.xwork2.util.reflection.ReflectionContextState;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.dispatcher.HttpParameters;\nimport org.apache.struts2.dispatcher.Parameter;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.util.Map;\n\n\n/**\n * <!-- START SNIPPET: description -->\n *\n * The aim of this Interceptor is to alias a named parameter to a different named parameter. By acting as the glue\n * between actions sharing similar parameters (but with different names), it can help greatly with action chaining.\n *\n * <p>Action's alias expressions should be in the form of  <code>#{ \"name1\" : \"alias1\", \"name2\" : \"alias2\" }</code>.\n * This means that assuming an action (or something else in the stack) has a value for the expression named <i>name1</i> and the\n * action this interceptor is applied to has a setter named <i>alias1</i>, <i>alias1</i> will be set with the value from\n * <i>name1</i>.\n * </p>\n *\n * <!-- END SNIPPET: description -->\n *\n * <p><u>Interceptor parameters:</u></p>\n *\n * <!-- START SNIPPET: parameters -->\n *\n * <ul>\n *\n * <li>aliasesKey (optional) - the name of the action parameter to look for the alias map (by default this is\n * <i>aliases</i>).</li>\n *\n * </ul>\n *\n * <!-- END SNIPPET: parameters -->\n *\n * <p><u>Extending the interceptor:</u></p>\n *\n * <!-- START SNIPPET: extending -->\n *\n * This interceptor does not have any known extension points.\n *\n * <!-- END SNIPPET: extending -->\n *\n * <p><u>Example code:</u></p>\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n *     &lt;!-- The value for the foo parameter will be applied as if it were named bar --&gt;\n *     &lt;param name=\"aliases\"&gt;#{ 'foo' : 'bar' }&lt;/param&gt;\n *\n *     &lt;interceptor-ref name=\"alias\"/&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n * &lt;/action&gt;\n * <!-- END SNIPPET: example -->\n * </pre>\n *\n * @author Matthew Payne\n */\npublic class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected transient ValueStackFactory valueStackFactory;\n    protected transient LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private transient ExcludedPatternsChecker excludedPatterns;\n    private transient AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.interceptor.AliasInterceptor is Serializable; consider declaring a serialVersionUID",
        "fileName": "com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "methodStartLineNumber": 93,
        "methodEndLineNumber": 291,
        "warning_type": "SE_NO_SERIALVERSIONID",
        "codeSnippet": " */\npublic class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n",
        "classStartLineNumber": 94,
        "classEndLineNumber": 292,
        "classCode": "public class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.interceptor.AliasInterceptor is Serializable; consider declaring a serialVersionUID-com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "classSize": 199
    },
    {
        "explanation": "AliasInterceptor.acceptedPatterns not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.AliasInterceptor.isAccepted(String)",
        "fileName": "com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "methodStartLineNumber": 232,
        "methodEndLineNumber": 243,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n",
        "classStartLineNumber": 94,
        "classEndLineNumber": 292,
        "classCode": "public class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n",
        "compositeId": "AliasInterceptor.acceptedPatterns not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.AliasInterceptor.isAccepted(String)-com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "classSize": 199,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.security.AcceptedPatternsChecker;\nimport com.opensymphony.xwork2.security.ExcludedPatternsChecker;\nimport com.opensymphony.xwork2.util.ClearableValueStack;\nimport com.opensymphony.xwork2.util.Evaluated;\nimport com.opensymphony.xwork2.LocalizedTextProvider;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.ValueStackFactory;\nimport com.opensymphony.xwork2.util.reflection.ReflectionContextState;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.dispatcher.HttpParameters;\nimport org.apache.struts2.dispatcher.Parameter;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.util.Map;\n\n\n/**\n * <!-- START SNIPPET: description -->\n *\n * The aim of this Interceptor is to alias a named parameter to a different named parameter. By acting as the glue\n * between actions sharing similar parameters (but with different names), it can help greatly with action chaining.\n *\n * <p>Action's alias expressions should be in the form of  <code>#{ \"name1\" : \"alias1\", \"name2\" : \"alias2\" }</code>.\n * This means that assuming an action (or something else in the stack) has a value for the expression named <i>name1</i> and the\n * action this interceptor is applied to has a setter named <i>alias1</i>, <i>alias1</i> will be set with the value from\n * <i>name1</i>.\n * </p>\n *\n * <!-- END SNIPPET: description -->\n *\n * <p><u>Interceptor parameters:</u></p>\n *\n * <!-- START SNIPPET: parameters -->\n *\n * <ul>\n *\n * <li>aliasesKey (optional) - the name of the action parameter to look for the alias map (by default this is\n * <i>aliases</i>).</li>\n *\n * </ul>\n *\n * <!-- END SNIPPET: parameters -->\n *\n * <p><u>Extending the interceptor:</u></p>\n *\n * <!-- START SNIPPET: extending -->\n *\n * This interceptor does not have any known extension points.\n *\n * <!-- END SNIPPET: extending -->\n *\n * <p><u>Example code:</u></p>\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n *     &lt;!-- The value for the foo parameter will be applied as if it were named bar --&gt;\n *     &lt;param name=\"aliases\"&gt;#{ 'foo' : 'bar' }&lt;/param&gt;\n *\n *     &lt;interceptor-ref name=\"alias\"/&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n * &lt;/action&gt;\n * <!-- END SNIPPET: example -->\n * </pre>\n *\n * @author Matthew Payne\n */\npublic class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        if (acceptedPatterns == null) {\n            throw new IllegalStateException(\"acceptedPatterns is not initialized\");\n        }\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n"
    },
    {
        "explanation": "AliasInterceptor.acceptedPatterns not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.AliasInterceptor.setAcceptParamNames(String)",
        "fileName": "com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "methodStartLineNumber": 278,
        "methodEndLineNumber": 281,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n",
        "classStartLineNumber": 94,
        "classEndLineNumber": 292,
        "classCode": "public class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n",
        "compositeId": "AliasInterceptor.acceptedPatterns not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.AliasInterceptor.setAcceptParamNames(String)-com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "classSize": 199
    },
    {
        "explanation": "AliasInterceptor.excludedPatterns not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.AliasInterceptor.isExcluded(String)",
        "fileName": "com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "methodStartLineNumber": 245,
        "methodEndLineNumber": 256,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n",
        "classStartLineNumber": 94,
        "classEndLineNumber": 292,
        "classCode": "public class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n",
        "compositeId": "AliasInterceptor.excludedPatterns not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.AliasInterceptor.isExcluded(String)-com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "classSize": 199,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.config.entities.ActionConfig;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.security.AcceptedPatternsChecker;\nimport com.opensymphony.xwork2.security.ExcludedPatternsChecker;\nimport com.opensymphony.xwork2.util.ClearableValueStack;\nimport com.opensymphony.xwork2.util.Evaluated;\nimport com.opensymphony.xwork2.LocalizedTextProvider;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.ValueStackFactory;\nimport com.opensymphony.xwork2.util.reflection.ReflectionContextState;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.dispatcher.HttpParameters;\nimport org.apache.struts2.dispatcher.Parameter;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.util.Map;\n\n\n/**\n * <!-- START SNIPPET: description -->\n *\n * The aim of this Interceptor is to alias a named parameter to a different named parameter. By acting as the glue\n * between actions sharing similar parameters (but with different names), it can help greatly with action chaining.\n *\n * <p>Action's alias expressions should be in the form of  <code>#{ \"name1\" : \"alias1\", \"name2\" : \"alias2\" }</code>.\n * This means that assuming an action (or something else in the stack) has a value for the expression named <i>name1</i> and the\n * action this interceptor is applied to has a setter named <i>alias1</i>, <i>alias1</i> will be set with the value from\n * <i>name1</i>.\n * </p>\n *\n * <!-- END SNIPPET: description -->\n *\n * <p><u>Interceptor parameters:</u></p>\n *\n * <!-- START SNIPPET: parameters -->\n *\n * <ul>\n *\n * <li>aliasesKey (optional) - the name of the action parameter to look for the alias map (by default this is\n * <i>aliases</i>).</li>\n *\n * </ul>\n *\n * <!-- END SNIPPET: parameters -->\n *\n * <p><u>Extending the interceptor:</u></p>\n *\n * <!-- START SNIPPET: extending -->\n *\n * This interceptor does not have any known extension points.\n *\n * <!-- END SNIPPET: extending -->\n *\n * <p><u>Example code:</u></p>\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n *     &lt;!-- The value for the foo parameter will be applied as if it were named bar --&gt;\n *     &lt;param name=\"aliases\"&gt;#{ 'foo' : 'bar' }&lt;/param&gt;\n *\n *     &lt;interceptor-ref name=\"alias\"/&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n * &lt;/action&gt;\n * <!-- END SNIPPET: example -->\n * </pre>\n *\n * @author Matthew Payne\n */\npublic class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        if (excludedPatterns == null) {\n            LOG.error(\"excludedPatterns is not initialized!\");\n            return false;\n        }\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n"
    },
    {
        "explanation": "AliasInterceptor.excludedPatterns not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.AliasInterceptor.setExcludeParams(String)",
        "fileName": "com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "methodStartLineNumber": 288,
        "methodEndLineNumber": 291,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n",
        "classStartLineNumber": 94,
        "classEndLineNumber": 292,
        "classCode": "public class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n",
        "compositeId": "AliasInterceptor.excludedPatterns not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.AliasInterceptor.setExcludeParams(String)-com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "classSize": 199
    },
    {
        "explanation": "AliasInterceptor.localizedTextProvider not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.AliasInterceptor.intercept(ActionInvocation)",
        "fileName": "com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "methodStartLineNumber": 149,
        "methodEndLineNumber": 230,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n",
        "classStartLineNumber": 94,
        "classEndLineNumber": 292,
        "classCode": "public class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n",
        "compositeId": "AliasInterceptor.localizedTextProvider not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.AliasInterceptor.intercept(ActionInvocation)-com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "classSize": 199
    },
    {
        "explanation": "AliasInterceptor.valueStackFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.AliasInterceptor.intercept(ActionInvocation)",
        "fileName": "com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "methodStartLineNumber": 149,
        "methodEndLineNumber": 230,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n",
        "classStartLineNumber": 94,
        "classEndLineNumber": 292,
        "classCode": "public class AliasInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(AliasInterceptor.class);\n\n    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n\n    protected ValueStackFactory valueStackFactory;\n    protected LocalizedTextProvider localizedTextProvider;\n    protected boolean devMode = false;\n\n    private ExcludedPatternsChecker excludedPatterns;\n    private AcceptedPatternsChecker acceptedPatterns;\n\n    @Inject(StrutsConstants.STRUTS_DEVMODE)\n    public void setDevMode(String mode) {\n        this.devMode = Boolean.parseBoolean(mode);\n    }   \n\n    @Inject\n    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    @Inject\n    public void setLocalizedTextProvider(LocalizedTextProvider localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    @Inject\n    public void setExcludedPatterns(ExcludedPatternsChecker excludedPatterns) {\n        this.excludedPatterns = excludedPatterns;\n    }\n\n    @Inject\n    public void setAcceptedPatterns(AcceptedPatternsChecker acceptedPatterns) {\n        this.acceptedPatterns = acceptedPatterns;\n    }\n\n    /**\n     * <p>\n     * Sets the name of the action parameter to look for the alias map.\n     * </p>\n     *\n     * <p>\n     * Default is <code>aliases</code>.\n     * </p>\n     *\n     * @param aliasesKey  the name of the action parameter\n     */\n    public void setAliasesKey(String aliasesKey) {\n        this.aliasesKey = aliasesKey;\n    }\n\n    @Override public String intercept(ActionInvocation invocation) throws Exception {\n\n        ActionConfig config = invocation.getProxy().getConfig();\n        ActionContext ac = invocation.getInvocationContext();\n        Object action = invocation.getAction();\n\n        // get the action's parameters\n        final Map<String, String> parameters = config.getParams();\n\n        if (parameters.containsKey(aliasesKey)) {\n\n            String aliasExpression = parameters.get(aliasesKey);\n            ValueStack stack = ac.getValueStack();\n            Object obj = stack.findValue(aliasExpression);\n\n            if (obj instanceof Map) {\n                //get secure stack\n                ValueStack newStack = valueStackFactory.createValueStack(stack);\n                boolean clearableStack = newStack instanceof ClearableValueStack;\n                if (clearableStack) {\n                    //if the stack's context can be cleared, do that to prevent OGNL\n                    //from having access to objects in the stack, see XW-641\n                    ((ClearableValueStack)newStack).clearContextValues();\n                    Map<String, Object> context = newStack.getContext();\n                    ReflectionContextState.setCreatingNullObjects(context, true);\n                    ReflectionContextState.setDenyMethodExecution(context, true);\n                    ReflectionContextState.setReportingConversionErrors(context, true);\n\n                    //keep locale from original context\n                    newStack.getActionContext().withLocale(stack.getActionContext().getLocale());\n                }\n\n                // override\n                Map aliases = (Map) obj;\n                for (Object o : aliases.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    String name = entry.getKey().toString();\n                    if (isNotAcceptableExpression(name)) {\n                        continue;\n                    }\n                    String alias = (String) entry.getValue();\n                    if (isNotAcceptableExpression(alias)) {\n                        continue;\n                    }\n                    Evaluated value = new Evaluated(stack.findValue(name));\n                    if (!value.isDefined()) {\n                        // workaround\n                        HttpParameters contextParameters = ActionContext.getContext().getParameters();\n\n                        if (null != contextParameters) {\n                            Parameter param = contextParameters.get(name);\n                            if (param.isDefined()) {\n                                value = new Evaluated(param.getValue());\n                            }\n                        }\n                    }\n                    if (value.isDefined()) {\n                        try {\n                            newStack.setValue(alias, value.get());\n                        } catch (RuntimeException e) {\n                            if (devMode) {\n                                String developerNotification = localizedTextProvider.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n                                });\n                                LOG.error(developerNotification);\n                                if (action instanceof ValidationAware) {\n                                    ((ValidationAware) action).addActionMessage(developerNotification);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (clearableStack) {\n                    stack.getActionContext().withConversionErrors(newStack.getActionContext().getConversionErrors());\n                }\n            } else {\n                LOG.debug(\"invalid alias expression: {}\", aliasesKey);\n            }\n        }\n        \n        return invocation.invoke();\n    }\n\n    protected boolean isAccepted(String paramName) {\n        AcceptedPatternsChecker.IsAccepted result = acceptedPatterns.isAccepted(paramName);\n        if (result.isAccepted()) {\n            return true;\n        }\n\n        LOG.warn(\"Parameter [{}] didn't match accepted pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getAcceptedPattern());\n\n        return false;\n    }\n\n    protected boolean isExcluded(String paramName) {\n        ExcludedPatternsChecker.IsExcluded result = excludedPatterns.isExcluded(paramName);\n        if (!result.isExcluded()) {\n            return false;\n        }\n\n        LOG.warn(\"Parameter [{}] matches excluded pattern [{}]! See Accepted / Excluded patterns at\\n\" +\n                        \"https://struts.apache.org/security/#accepted--excluded-patterns\",\n                paramName, result.getExcludedPattern());\n\n        return true;\n    }\n\n    /**\n     * Checks if expression contains vulnerable code\n     *\n     * @param expression of interceptor\n     * @return true|false\n     */\n    protected boolean isNotAcceptableExpression(String expression) {\n        return isExcluded(expression) || !isAccepted(expression);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that are allowed in the parameter map (aka whitelist).\n     * <p>\n     * Don't change the default unless you know what you are doing in terms\n     * of security implications.\n     * </p>\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setAcceptParamNames(String commaDelim) {\n        acceptedPatterns.setAcceptedPatterns(commaDelim);\n    }\n\n    /**\n     * Sets a comma-delimited list of regular expressions to match\n     * parameters that should be removed from the parameter map.\n     *\n     * @param commaDelim A comma-delimited list of regular expressions\n     */\n    public void setExcludeParams(String commaDelim) {\n        excludedPatterns.setExcludedPatterns(commaDelim);\n    }\n\n}\n",
        "compositeId": "AliasInterceptor.valueStackFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.AliasInterceptor.intercept(ActionInvocation)-com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
        "classSize": 199
    },
    {
        "explanation": "com.opensymphony.xwork2.interceptor.ChainingInterceptor.getExcludes() may expose internal representation by returning ChainingInterceptor.excludes",
        "fileName": "com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "methodStartLineNumber": 220,
        "methodEndLineNumber": 222,
        "warning_type": "EI_EXPOSE_REP",
        "codeSnippet": "    public Collection<String> getExcludes() {\n        return excludes;\n",
        "classStartLineNumber": 117,
        "classEndLineNumber": 270,
        "classCode": "public class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return excludes;\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        return includes;\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.interceptor.ChainingInterceptor.getExcludes() may expose internal representation by returning ChainingInterceptor.excludes-com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "classSize": 154,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionChainResult;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.Result;\nimport com.opensymphony.xwork2.Unchainable;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.util.ProxyUtil;\nimport com.opensymphony.xwork2.util.CompoundRoot;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\nimport com.opensymphony.xwork2.util.reflection.ReflectionProvider;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.util.*;\n\n\n/**\n * <!-- START SNIPPET: description -->\n * <p>\n * An interceptor that copies all the properties of every object in the value stack to the currently executing object,\n * except for any object that implements {@link Unchainable}. A collection of optional <i>includes</i> and\n * <i>excludes</i> may be provided to control how and which parameters are copied. Only includes or excludes may be\n * specified. Specifying both results in undefined behavior. See the javadocs for {@link ReflectionProvider#copy(Object, Object,\n * java.util.Map, java.util.Collection, java.util.Collection)} for more information.\n * </p>\n *\n * <p>\n * <b>Note:</b> It is important to remember that this interceptor does nothing if there are no objects already on the stack.\n * <br>This means two things:\n * <br><b>One</b>, you can safely apply it to all your actions without any worry of adverse affects.\n * <br><b>Two</b>, it is up to you to ensure an object exists in the stack prior to invoking this action. The most typical way this is done\n * is through the use of the <b>chain</b> result type, which combines with this interceptor to make up the action\n * chaining feature.\n * </p>\n *\n * <p>\n * <b>Note:</b> By default Errors, Field errors and Message aren't copied during chaining, to change the behaviour you can specify\n * the below three constants in struts.properties or struts.xml:\n * </p>\n *\n * <ul>\n * <li>struts.chaining.copyErrors - set to true to copy Action Errors</li>\n * <li>struts.chaining.copyFieldErrors - set to true to copy Field Errors</li>\n * <li>struts.chaining.copyMessages - set to true to copy Action Messages</li>\n * </ul>\n *\n * <p>\n * <u>Example:</u>\n * </p>\n *\n * <pre>\n * &lt;constant name=\"struts.xwork.chaining.copyErrors\" value=\"true\"/&gt;\n * </pre>\n *\n * <p>\n * <b>Note:</b> By default actionErrors and actionMessages are excluded when copping object's properties.\n * </p>\n * <!-- END SNIPPET: description -->\n * <u>Interceptor parameters:</u>\n * <!-- START SNIPPET: parameters -->\n * <ul>\n * <li>excludes (optional) - the list of parameter names to exclude from copying (all others will be included).</li>\n * <li>includes (optional) - the list of parameter names to include when copying (all others will be excluded).</li>\n * </ul>\n * <!-- END SNIPPET: parameters -->\n * <u>Extending the interceptor:</u>\n * <!-- START SNIPPET: extending -->\n * <p>\n * There are no known extension points to this interceptor.\n * </p>\n * <!-- END SNIPPET: extending -->\n * <u>Example code:</u>\n *\n * <!-- START SNIPPET: example -->\n * <pre>\n * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\" type=\"chain\"&gt;otherAction&lt;/result&gt;\n * &lt;/action&gt;\n * </pre>\n *\n * <pre>\n * &lt;action name=\"otherAction\" class=\"com.examples.OtherAction\"&gt;\n *     &lt;interceptor-ref name=\"chain\"/&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n * &lt;/action&gt;\n * </pre>\n * <!-- END SNIPPET: example -->\n *\n *\n * @author mrdon\n * @author tm_jee ( tm_jee(at)yahoo.co.uk )\n * @see com.opensymphony.xwork2.ActionChainResult\n */\npublic class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return a copy of the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return new ArrayList<>(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        return includes;\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.interceptor.ChainingInterceptor.getIncludes() may expose internal representation by returning ChainingInterceptor.includes",
        "fileName": "com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "methodStartLineNumber": 247,
        "methodEndLineNumber": 249,
        "warning_type": "EI_EXPOSE_REP",
        "codeSnippet": "    public Collection<String> getIncludes() {\n        return includes;\n",
        "classStartLineNumber": 117,
        "classEndLineNumber": 270,
        "classCode": "public class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return excludes;\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        return includes;\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.interceptor.ChainingInterceptor.getIncludes() may expose internal representation by returning ChainingInterceptor.includes-com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "classSize": 154,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionChainResult;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.Result;\nimport com.opensymphony.xwork2.Unchainable;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.util.ProxyUtil;\nimport com.opensymphony.xwork2.util.CompoundRoot;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\nimport com.opensymphony.xwork2.util.reflection.ReflectionProvider;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.util.*;\n\n\n/**\n * <!-- START SNIPPET: description -->\n * <p>\n * An interceptor that copies all the properties of every object in the value stack to the currently executing object,\n * except for any object that implements {@link Unchainable}. A collection of optional <i>includes</i> and\n * <i>excludes</i> may be provided to control how and which parameters are copied. Only includes or excludes may be\n * specified. Specifying both results in undefined behavior. See the javadocs for {@link ReflectionProvider#copy(Object, Object,\n * java.util.Map, java.util.Collection, java.util.Collection)} for more information.\n * </p>\n *\n * <p>\n * <b>Note:</b> It is important to remember that this interceptor does nothing if there are no objects already on the stack.\n * <br>This means two things:\n * <br><b>One</b>, you can safely apply it to all your actions without any worry of adverse affects.\n * <br><b>Two</b>, it is up to you to ensure an object exists in the stack prior to invoking this action. The most typical way this is done\n * is through the use of the <b>chain</b> result type, which combines with this interceptor to make up the action\n * chaining feature.\n * </p>\n *\n * <p>\n * <b>Note:</b> By default Errors, Field errors and Message aren't copied during chaining, to change the behaviour you can specify\n * the below three constants in struts.properties or struts.xml:\n * </p>\n *\n * <ul>\n * <li>struts.chaining.copyErrors - set to true to copy Action Errors</li>\n * <li>struts.chaining.copyFieldErrors - set to true to copy Field Errors</li>\n * <li>struts.chaining.copyMessages - set to true to copy Action Messages</li>\n * </ul>\n *\n * <p>\n * <u>Example:</u>\n * </p>\n *\n * <pre>\n * &lt;constant name=\"struts.xwork.chaining.copyErrors\" value=\"true\"/&gt;\n * </pre>\n *\n * <p>\n * <b>Note:</b> By default actionErrors and actionMessages are excluded when copping object's properties.\n * </p>\n * <!-- END SNIPPET: description -->\n * <u>Interceptor parameters:</u>\n * <!-- START SNIPPET: parameters -->\n * <ul>\n * <li>excludes (optional) - the list of parameter names to exclude from copying (all others will be included).</li>\n * <li>includes (optional) - the list of parameter names to include when copying (all others will be excluded).</li>\n * </ul>\n * <!-- END SNIPPET: parameters -->\n * <u>Extending the interceptor:</u>\n * <!-- START SNIPPET: extending -->\n * <p>\n * There are no known extension points to this interceptor.\n * </p>\n * <!-- END SNIPPET: extending -->\n * <u>Example code:</u>\n *\n * <!-- START SNIPPET: example -->\n * <pre>\n * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\" type=\"chain\"&gt;otherAction&lt;/result&gt;\n * &lt;/action&gt;\n * </pre>\n *\n * <pre>\n * &lt;action name=\"otherAction\" class=\"com.examples.OtherAction\"&gt;\n *     &lt;interceptor-ref name=\"chain\"/&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n * &lt;/action&gt;\n * </pre>\n * <!-- END SNIPPET: example -->\n *\n *\n * @author mrdon\n * @author tm_jee ( tm_jee(at)yahoo.co.uk )\n * @see com.opensymphony.xwork2.ActionChainResult\n */\npublic class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return excludes;\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        if (includes == null) {\n            return Collections.emptyList();\n        }\n        return new ArrayList<>(includes);\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.interceptor.ChainingInterceptor.setExcludesCollection(Collection) may expose internal representation by storing an externally mutable object into ChainingInterceptor.excludes",
        "fileName": "com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "methodStartLineNumber": 238,
        "methodEndLineNumber": 241,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n",
        "classStartLineNumber": 117,
        "classEndLineNumber": 270,
        "classCode": "public class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return excludes;\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        return includes;\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.interceptor.ChainingInterceptor.setExcludesCollection(Collection) may expose internal representation by storing an externally mutable object into ChainingInterceptor.excludes-com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "classSize": 154
    },
    {
        "explanation": "com.opensymphony.xwork2.interceptor.ChainingInterceptor.setIncludesCollection(Collection) may expose internal representation by storing an externally mutable object into ChainingInterceptor.includes",
        "fileName": "com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "methodStartLineNumber": 266,
        "methodEndLineNumber": 269,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n",
        "classStartLineNumber": 117,
        "classEndLineNumber": 270,
        "classCode": "public class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return excludes;\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        return includes;\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.interceptor.ChainingInterceptor.setIncludesCollection(Collection) may expose internal representation by storing an externally mutable object into ChainingInterceptor.includes-com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "classSize": 154,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionChainResult;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.Result;\nimport com.opensymphony.xwork2.Unchainable;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.util.ProxyUtil;\nimport com.opensymphony.xwork2.util.CompoundRoot;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\nimport com.opensymphony.xwork2.util.reflection.ReflectionProvider;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.util.*;\n\n\n/**\n * <!-- START SNIPPET: description -->\n * <p>\n * An interceptor that copies all the properties of every object in the value stack to the currently executing object,\n * except for any object that implements {@link Unchainable}. A collection of optional <i>includes</i> and\n * <i>excludes</i> may be provided to control how and which parameters are copied. Only includes or excludes may be\n * specified. Specifying both results in undefined behavior. See the javadocs for {@link ReflectionProvider#copy(Object, Object,\n * java.util.Map, java.util.Collection, java.util.Collection)} for more information.\n * </p>\n *\n * <p>\n * <b>Note:</b> It is important to remember that this interceptor does nothing if there are no objects already on the stack.\n * <br>This means two things:\n * <br><b>One</b>, you can safely apply it to all your actions without any worry of adverse affects.\n * <br><b>Two</b>, it is up to you to ensure an object exists in the stack prior to invoking this action. The most typical way this is done\n * is through the use of the <b>chain</b> result type, which combines with this interceptor to make up the action\n * chaining feature.\n * </p>\n *\n * <p>\n * <b>Note:</b> By default Errors, Field errors and Message aren't copied during chaining, to change the behaviour you can specify\n * the below three constants in struts.properties or struts.xml:\n * </p>\n *\n * <ul>\n * <li>struts.chaining.copyErrors - set to true to copy Action Errors</li>\n * <li>struts.chaining.copyFieldErrors - set to true to copy Field Errors</li>\n * <li>struts.chaining.copyMessages - set to true to copy Action Messages</li>\n * </ul>\n *\n * <p>\n * <u>Example:</u>\n * </p>\n *\n * <pre>\n * &lt;constant name=\"struts.xwork.chaining.copyErrors\" value=\"true\"/&gt;\n * </pre>\n *\n * <p>\n * <b>Note:</b> By default actionErrors and actionMessages are excluded when copping object's properties.\n * </p>\n * <!-- END SNIPPET: description -->\n * <u>Interceptor parameters:</u>\n * <!-- START SNIPPET: parameters -->\n * <ul>\n * <li>excludes (optional) - the list of parameter names to exclude from copying (all others will be included).</li>\n * <li>includes (optional) - the list of parameter names to include when copying (all others will be excluded).</li>\n * </ul>\n * <!-- END SNIPPET: parameters -->\n * <u>Extending the interceptor:</u>\n * <!-- START SNIPPET: extending -->\n * <p>\n * There are no known extension points to this interceptor.\n * </p>\n * <!-- END SNIPPET: extending -->\n * <u>Example code:</u>\n *\n * <!-- START SNIPPET: example -->\n * <pre>\n * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\" type=\"chain\"&gt;otherAction&lt;/result&gt;\n * &lt;/action&gt;\n * </pre>\n *\n * <pre>\n * &lt;action name=\"otherAction\" class=\"com.examples.OtherAction\"&gt;\n *     &lt;interceptor-ref name=\"chain\"/&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n * &lt;/action&gt;\n * </pre>\n * <!-- END SNIPPET: example -->\n *\n *\n * @author mrdon\n * @author tm_jee ( tm_jee(at)yahoo.co.uk )\n * @see com.opensymphony.xwork2.ActionChainResult\n */\npublic class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return excludes;\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        return includes;\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        if (includes != null) {\n            this.includes = new ArrayList<>(includes);\n        } else {\n            this.includes = null;\n        }\n    }\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.interceptor.ChainingInterceptor.setReflectionProvider(ReflectionProvider) may expose internal representation by storing an externally mutable object into ChainingInterceptor.reflectionProvider",
        "fileName": "com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "methodStartLineNumber": 135,
        "methodEndLineNumber": 138,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n",
        "classStartLineNumber": 117,
        "classEndLineNumber": 270,
        "classCode": "public class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return excludes;\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        return includes;\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.interceptor.ChainingInterceptor.setReflectionProvider(ReflectionProvider) may expose internal representation by storing an externally mutable object into ChainingInterceptor.reflectionProvider-com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "classSize": 154
    },
    {
        "explanation": "Class com.opensymphony.xwork2.interceptor.ChainingInterceptor defines non-transient non-serializable instance field reflectionProvider",
        "fileName": "com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "methodStartLineNumber": 116,
        "methodEndLineNumber": 269,
        "warning_type": "SE_BAD_FIELD",
        "codeSnippet": " */\npublic class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return excludes;\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        return includes;\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n",
        "classStartLineNumber": 117,
        "classEndLineNumber": 270,
        "classCode": "public class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return excludes;\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        return includes;\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n\n}\n",
        "compositeId": "Class com.opensymphony.xwork2.interceptor.ChainingInterceptor defines non-transient non-serializable instance field reflectionProvider-com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "classSize": 154,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionChainResult;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.Result;\nimport com.opensymphony.xwork2.Unchainable;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.util.ProxyUtil;\nimport com.opensymphony.xwork2.util.CompoundRoot;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\nimport com.opensymphony.xwork2.util.reflection.ReflectionProvider;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.util.*;\n\n\n/**\n * <!-- START SNIPPET: description -->\n * <p>\n * An interceptor that copies all the properties of every object in the value stack to the currently executing object,\n * except for any object that implements {@link Unchainable}. A collection of optional <i>includes</i> and\n * <i>excludes</i> may be provided to control how and which parameters are copied. Only includes or excludes may be\n * specified. Specifying both results in undefined behavior. See the javadocs for {@link ReflectionProvider#copy(Object, Object,\n * java.util.Map, java.util.Collection, java.util.Collection)} for more information.\n * </p>\n *\n * <p>\n * <b>Note:</b> It is important to remember that this interceptor does nothing if there are no objects already on the stack.\n * <br>This means two things:\n * <br><b>One</b>, you can safely apply it to all your actions without any worry of adverse affects.\n * <br><b>Two</b>, it is up to you to ensure an object exists in the stack prior to invoking this action. The most typical way this is done\n * is through the use of the <b>chain</b> result type, which combines with this interceptor to make up the action\n * chaining feature.\n * </p>\n *\n * <p>\n * <b>Note:</b> By default Errors, Field errors and Message aren't copied during chaining, to change the behaviour you can specify\n * the below three constants in struts.properties or struts.xml:\n * </p>\n *\n * <ul>\n * <li>struts.chaining.copyErrors - set to true to copy Action Errors</li>\n * <li>struts.chaining.copyFieldErrors - set to true to copy Field Errors</li>\n * <li>struts.chaining.copyMessages - set to true to copy Action Messages</li>\n * </ul>\n *\n * <p>\n * <u>Example:</u>\n * </p>\n *\n * <pre>\n * &lt;constant name=\"struts.xwork.chaining.copyErrors\" value=\"true\"/&gt;\n * </pre>\n *\n * <p>\n * <b>Note:</b> By default actionErrors and actionMessages are excluded when copping object's properties.\n * </p>\n * <!-- END SNIPPET: description -->\n * <u>Interceptor parameters:</u>\n * <!-- START SNIPPET: parameters -->\n * <ul>\n * <li>excludes (optional) - the list of parameter names to exclude from copying (all others will be included).</li>\n * <li>includes (optional) - the list of parameter names to include when copying (all others will be excluded).</li>\n * </ul>\n * <!-- END SNIPPET: parameters -->\n * <u>Extending the interceptor:</u>\n * <!-- START SNIPPET: extending -->\n * <p>\n * There are no known extension points to this interceptor.\n * </p>\n * <!-- END SNIPPET: extending -->\n * <u>Example code:</u>\n *\n * <!-- START SNIPPET: example -->\n * <pre>\n * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\" type=\"chain\"&gt;otherAction&lt;/result&gt;\n * &lt;/action&gt;\n * </pre>\n *\n * <pre>\n * &lt;action name=\"otherAction\" class=\"com.examples.OtherAction\"&gt;\n *     &lt;interceptor-ref name=\"chain\"/&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n * &lt;/action&gt;\n * </pre>\n * <!-- END SNIPPET: example -->\n *\n *\n * @author mrdon\n * @author tm_jee ( tm_jee(at)yahoo.co.uk )\n * @see com.opensymphony.xwork2.ActionChainResult\n */\npublic class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected transient ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return excludes;\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        return includes;\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.interceptor.ChainingInterceptor is Serializable; consider declaring a serialVersionUID",
        "fileName": "com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "methodStartLineNumber": 116,
        "methodEndLineNumber": 269,
        "warning_type": "SE_NO_SERIALVERSIONID",
        "codeSnippet": " */\npublic class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return excludes;\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        return includes;\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n",
        "classStartLineNumber": 117,
        "classEndLineNumber": 270,
        "classCode": "public class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return excludes;\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        return includes;\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.interceptor.ChainingInterceptor is Serializable; consider declaring a serialVersionUID-com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "classSize": 154
    },
    {
        "explanation": "ChainingInterceptor.reflectionProvider not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.ChainingInterceptor.copyStack(ActionInvocation, CompoundRoot)",
        "fileName": "com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "methodStartLineNumber": 164,
        "methodEndLineNumber": 178,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n",
        "classStartLineNumber": 117,
        "classEndLineNumber": 270,
        "classCode": "public class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return excludes;\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        return includes;\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n\n}\n",
        "compositeId": "ChainingInterceptor.reflectionProvider not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.ChainingInterceptor.copyStack(ActionInvocation, CompoundRoot)-com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
        "classSize": 154,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionChainResult;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.Result;\nimport com.opensymphony.xwork2.Unchainable;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.util.ProxyUtil;\nimport com.opensymphony.xwork2.util.CompoundRoot;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\nimport com.opensymphony.xwork2.util.reflection.ReflectionProvider;\nimport org.apache.struts2.StrutsConstants;\n\nimport java.util.*;\n\n\n/**\n * <!-- START SNIPPET: description -->\n * <p>\n * An interceptor that copies all the properties of every object in the value stack to the currently executing object,\n * except for any object that implements {@link Unchainable}. A collection of optional <i>includes</i> and\n * <i>excludes</i> may be provided to control how and which parameters are copied. Only includes or excludes may be\n * specified. Specifying both results in undefined behavior. See the javadocs for {@link ReflectionProvider#copy(Object, Object,\n * java.util.Map, java.util.Collection, java.util.Collection)} for more information.\n * </p>\n *\n * <p>\n * <b>Note:</b> It is important to remember that this interceptor does nothing if there are no objects already on the stack.\n * <br>This means two things:\n * <br><b>One</b>, you can safely apply it to all your actions without any worry of adverse affects.\n * <br><b>Two</b>, it is up to you to ensure an object exists in the stack prior to invoking this action. The most typical way this is done\n * is through the use of the <b>chain</b> result type, which combines with this interceptor to make up the action\n * chaining feature.\n * </p>\n *\n * <p>\n * <b>Note:</b> By default Errors, Field errors and Message aren't copied during chaining, to change the behaviour you can specify\n * the below three constants in struts.properties or struts.xml:\n * </p>\n *\n * <ul>\n * <li>struts.chaining.copyErrors - set to true to copy Action Errors</li>\n * <li>struts.chaining.copyFieldErrors - set to true to copy Field Errors</li>\n * <li>struts.chaining.copyMessages - set to true to copy Action Messages</li>\n * </ul>\n *\n * <p>\n * <u>Example:</u>\n * </p>\n *\n * <pre>\n * &lt;constant name=\"struts.xwork.chaining.copyErrors\" value=\"true\"/&gt;\n * </pre>\n *\n * <p>\n * <b>Note:</b> By default actionErrors and actionMessages are excluded when copping object's properties.\n * </p>\n * <!-- END SNIPPET: description -->\n * <u>Interceptor parameters:</u>\n * <!-- START SNIPPET: parameters -->\n * <ul>\n * <li>excludes (optional) - the list of parameter names to exclude from copying (all others will be included).</li>\n * <li>includes (optional) - the list of parameter names to include when copying (all others will be excluded).</li>\n * </ul>\n * <!-- END SNIPPET: parameters -->\n * <u>Extending the interceptor:</u>\n * <!-- START SNIPPET: extending -->\n * <p>\n * There are no known extension points to this interceptor.\n * </p>\n * <!-- END SNIPPET: extending -->\n * <u>Example code:</u>\n *\n * <!-- START SNIPPET: example -->\n * <pre>\n * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\" type=\"chain\"&gt;otherAction&lt;/result&gt;\n * &lt;/action&gt;\n * </pre>\n *\n * <pre>\n * &lt;action name=\"otherAction\" class=\"com.examples.OtherAction\"&gt;\n *     &lt;interceptor-ref name=\"chain\"/&gt;\n *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n * &lt;/action&gt;\n * </pre>\n * <!-- END SNIPPET: example -->\n *\n *\n * @author mrdon\n * @author tm_jee ( tm_jee(at)yahoo.co.uk )\n * @see com.opensymphony.xwork2.ActionChainResult\n */\npublic class ChainingInterceptor extends AbstractInterceptor {\n\n    private static final Logger LOG = LogManager.getLogger(ChainingInterceptor.class);\n\n    private static final String ACTION_ERRORS = \"actionErrors\";\n    private static final String FIELD_ERRORS = \"fieldErrors\";\n    private static final String ACTION_MESSAGES = \"actionMessages\";\n\n    private boolean copyMessages = false;\n    private boolean copyErrors = false;\n    private boolean copyFieldErrors = false;\n\n    protected Collection<String> excludes;\n\n    protected Collection<String> includes;\n    protected ReflectionProvider reflectionProvider;\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider prov) {\n        this.reflectionProvider = prov;\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_ERRORS, required = false)\n    public void setCopyErrors(String copyErrors) {\n        this.copyErrors = \"true\".equalsIgnoreCase(copyErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_FIELD_ERRORS, required = false)\n    public void setCopyFieldErrors(String copyFieldErrors) {\n        this.copyFieldErrors = \"true\".equalsIgnoreCase(copyFieldErrors);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_CHAINING_COPY_MESSAGES, required = false)\n    public void setCopyMessages(String copyMessages) {\n        this.copyMessages = \"true\".equalsIgnoreCase(copyMessages);\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        ValueStack stack = invocation.getStack();\n        CompoundRoot root = stack.getRoot();\n        if (shouldCopyStack(invocation, root)) {\n            copyStack(invocation, root);\n        }\n        return invocation.invoke();\n    }\n\n    private void copyStack(ActionInvocation invocation, CompoundRoot root) {\n        if (reflectionProvider == null) {\n            throw new IllegalStateException(\"reflectionProvider is not initialized\");\n        }\n        List list = prepareList(root);\n        Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n        for (Object object : list) {\n            if (shouldCopy(object)) {\n                Object action = invocation.getAction();\n                Class<?> editable = null;\n                if(ProxyUtil.isProxy(action)) {\n                    editable = ProxyUtil.ultimateTargetClass(action);\n                }\n                reflectionProvider.copy(object, action, ctxMap, prepareExcludes(), includes, editable);\n            }\n        }\n    }\n\n    private Collection<String> prepareExcludes() {\n        Collection<String> localExcludes = excludes;\n        if (!copyErrors || !copyMessages ||!copyFieldErrors) {\n            if (localExcludes == null) {\n                localExcludes = new HashSet<String>();\n                if (!copyErrors) {\n                    localExcludes.add(ACTION_ERRORS);\n                }\n                if (!copyMessages) {\n                    localExcludes.add(ACTION_MESSAGES);\n                }\n                if (!copyFieldErrors) {\n                    localExcludes.add(FIELD_ERRORS);\n                }\n            }\n        }\n        return localExcludes;\n    }\n\n    private boolean shouldCopy(Object o) {\n        return o != null && !(o instanceof Unchainable);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List prepareList(CompoundRoot root) {\n        List list = new ArrayList(root);\n        list.remove(0);\n        Collections.reverse(list);\n        return list;\n    }\n\n    private boolean shouldCopyStack(ActionInvocation invocation, CompoundRoot root) throws Exception {\n        Result result = invocation.getResult();\n        return root.size() > 1 && (result == null || ActionChainResult.class.isAssignableFrom(result.getClass()));\n    }\n\n    /**\n     * Gets list of parameter names to exclude\n     *\n     * @return the exclude list\n     */\n    public Collection<String> getExcludes() {\n        return excludes;\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list as comma separated String\n     */\n    public void setExcludes(String excludes) {\n        this.excludes = TextParseUtil.commaDelimitedStringToSet(excludes);\n    }\n\n    /**\n     * Sets the list of parameter names to exclude from copying (all others will be included).\n     *\n     * @param excludes the excludes list\n     */\n    public void setExcludesCollection(Collection<String> excludes) {\n        this.excludes = excludes;\n    }\n\n    /**\n     * Gets list of parameter names to include\n     *\n     * @return the include list\n     */\n    public Collection<String> getIncludes() {\n        return includes;\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list as comma separated String\n     */\n    public void setIncludes(String includes) {\n        this.includes = TextParseUtil.commaDelimitedStringToSet(includes);\n    }\n\n    /**\n     * Sets the list of parameter names to include when copying (all others will be excluded).\n     *\n     * @param includes the includes list\n     */\n    public void setIncludesCollection(Collection<String> includes) {\n        this.includes = includes;\n    }\n\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.interceptor.WithLazyParams$LazyParamInjector.setOgnlUtil(OgnlUtil) may expose internal representation by storing an externally mutable object into WithLazyParams$LazyParamInjector.ognlUtil",
        "fileName": "com/opensymphony/xwork2/interceptor/WithLazyParams.java",
        "methodStartLineNumber": 68,
        "methodEndLineNumber": 71,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "        public void setOgnlUtil(OgnlUtil ognlUtil) {\n            this.ognlUtil = ognlUtil;\n        }\n",
        "classStartLineNumber": 41,
        "classEndLineNumber": 80,
        "classCode": "    class LazyParamInjector {\n\n        protected OgnlUtil ognlUtil;\n        protected TextParser textParser;\n        protected ReflectionProvider reflectionProvider;\n\n        private final TextParseUtil.ParsedValueEvaluator valueEvaluator;\n\n        public LazyParamInjector(final ValueStack valueStack) {\n            valueEvaluator = new TextParseUtil.ParsedValueEvaluator() {\n                public Object evaluate(String parsedValue) {\n                    return valueStack.findValue(parsedValue); // no asType !!!\n                }\n            };\n        }\n\n        @Inject\n        public void setTextParser(TextParser textParser) {\n            this.textParser = textParser;\n        }\n\n        @Inject\n        public void setReflectionProvider(ReflectionProvider reflectionProvider) {\n            this.reflectionProvider = reflectionProvider;\n        }\n\n        @Inject\n        public void setOgnlUtil(OgnlUtil ognlUtil) {\n            this.ognlUtil = ognlUtil;\n        }\n\n        public Interceptor injectParams(Interceptor interceptor, Map<String, String> params, ActionContext invocationContext) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                Object paramValue = textParser.evaluate(new char[]{ '$' }, entry.getValue(), valueEvaluator, TextParser.DEFAULT_LOOP_COUNT);\n                ognlUtil.setProperty(entry.getKey(), paramValue, interceptor, invocationContext.getContextMap());\n            }\n\n            return interceptor;\n        }\n    }\n",
        "compositeId": "com.opensymphony.xwork2.interceptor.WithLazyParams$LazyParamInjector.setOgnlUtil(OgnlUtil) may expose internal representation by storing an externally mutable object into WithLazyParams$LazyParamInjector.ognlUtil-com/opensymphony/xwork2/interceptor/WithLazyParams.java",
        "classSize": 40
    },
    {
        "explanation": "com.opensymphony.xwork2.interceptor.WithLazyParams$LazyParamInjector.setReflectionProvider(ReflectionProvider) may expose internal representation by storing an externally mutable object into WithLazyParams$LazyParamInjector.reflectionProvider",
        "fileName": "com/opensymphony/xwork2/interceptor/WithLazyParams.java",
        "methodStartLineNumber": 63,
        "methodEndLineNumber": 66,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "        public void setReflectionProvider(ReflectionProvider reflectionProvider) {\n            this.reflectionProvider = reflectionProvider;\n        }\n",
        "classStartLineNumber": 41,
        "classEndLineNumber": 80,
        "classCode": "    class LazyParamInjector {\n\n        protected OgnlUtil ognlUtil;\n        protected TextParser textParser;\n        protected ReflectionProvider reflectionProvider;\n\n        private final TextParseUtil.ParsedValueEvaluator valueEvaluator;\n\n        public LazyParamInjector(final ValueStack valueStack) {\n            valueEvaluator = new TextParseUtil.ParsedValueEvaluator() {\n                public Object evaluate(String parsedValue) {\n                    return valueStack.findValue(parsedValue); // no asType !!!\n                }\n            };\n        }\n\n        @Inject\n        public void setTextParser(TextParser textParser) {\n            this.textParser = textParser;\n        }\n\n        @Inject\n        public void setReflectionProvider(ReflectionProvider reflectionProvider) {\n            this.reflectionProvider = reflectionProvider;\n        }\n\n        @Inject\n        public void setOgnlUtil(OgnlUtil ognlUtil) {\n            this.ognlUtil = ognlUtil;\n        }\n\n        public Interceptor injectParams(Interceptor interceptor, Map<String, String> params, ActionContext invocationContext) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                Object paramValue = textParser.evaluate(new char[]{ '$' }, entry.getValue(), valueEvaluator, TextParser.DEFAULT_LOOP_COUNT);\n                ognlUtil.setProperty(entry.getKey(), paramValue, interceptor, invocationContext.getContextMap());\n            }\n\n            return interceptor;\n        }\n    }\n",
        "compositeId": "com.opensymphony.xwork2.interceptor.WithLazyParams$LazyParamInjector.setReflectionProvider(ReflectionProvider) may expose internal representation by storing an externally mutable object into WithLazyParams$LazyParamInjector.reflectionProvider-com/opensymphony/xwork2/interceptor/WithLazyParams.java",
        "classSize": 40
    },
    {
        "explanation": "The class com.opensymphony.xwork2.interceptor.WithLazyParams$LazyParamInjector$1 could be refactored into a named _static_ inner class",
        "fileName": "com/opensymphony/xwork2/interceptor/WithLazyParams.java",
        "methodStartLineNumber": 48,
        "methodEndLineNumber": 56,
        "warning_type": "SIC_INNER_SHOULD_BE_STATIC_ANON",
        "codeSnippet": "\n        public LazyParamInjector(final ValueStack valueStack) {\n            valueEvaluator = new TextParseUtil.ParsedValueEvaluator() {\n                public Object evaluate(String parsedValue) {\n                    return valueStack.findValue(parsedValue); // no asType !!!\n                }\n            };\n        }\n",
        "classStartLineNumber": 41,
        "classEndLineNumber": 80,
        "classCode": "    class LazyParamInjector {\n\n        protected OgnlUtil ognlUtil;\n        protected TextParser textParser;\n        protected ReflectionProvider reflectionProvider;\n\n        private final TextParseUtil.ParsedValueEvaluator valueEvaluator;\n\n        public LazyParamInjector(final ValueStack valueStack) {\n            valueEvaluator = new TextParseUtil.ParsedValueEvaluator() {\n                public Object evaluate(String parsedValue) {\n                    return valueStack.findValue(parsedValue); // no asType !!!\n                }\n            };\n        }\n\n        @Inject\n        public void setTextParser(TextParser textParser) {\n            this.textParser = textParser;\n        }\n\n        @Inject\n        public void setReflectionProvider(ReflectionProvider reflectionProvider) {\n            this.reflectionProvider = reflectionProvider;\n        }\n\n        @Inject\n        public void setOgnlUtil(OgnlUtil ognlUtil) {\n            this.ognlUtil = ognlUtil;\n        }\n\n        public Interceptor injectParams(Interceptor interceptor, Map<String, String> params, ActionContext invocationContext) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                Object paramValue = textParser.evaluate(new char[]{ '$' }, entry.getValue(), valueEvaluator, TextParser.DEFAULT_LOOP_COUNT);\n                ognlUtil.setProperty(entry.getKey(), paramValue, interceptor, invocationContext.getContextMap());\n            }\n\n            return interceptor;\n        }\n    }\n",
        "compositeId": "The class com.opensymphony.xwork2.interceptor.WithLazyParams$LazyParamInjector$1 could be refactored into a named _static_ inner class-com/opensymphony/xwork2/interceptor/WithLazyParams.java",
        "classSize": 40,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.ognl.OgnlUtil;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.TextParser;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.reflection.ReflectionProvider;\n\nimport java.util.Map;\n\n/**\n * Interceptors marked with this interface won't be fully initialised during initialisation.\n * Appropriated params will be injected just before usage of the interceptor.\n *\n * Please be aware that in such case {@link Interceptor#init()} method must be prepared for this.\n *\n * @since 2.5.9\n */\npublic interface WithLazyParams {\n\nclass LazyParamInjector {\n\n    protected OgnlUtil ognlUtil;\n    protected TextParser textParser;\n    protected ReflectionProvider reflectionProvider;\n\n    private final TextParseUtil.ParsedValueEvaluator valueEvaluator;\n\n    public LazyParamInjector(final ValueStack valueStack) {\n        valueEvaluator = new LazyParamEvaluator(valueStack);\n    }\n\n    @Inject\n    public void setTextParser(TextParser textParser) {\n        this.textParser = textParser;\n    }\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider reflectionProvider) {\n        this.reflectionProvider = reflectionProvider;\n    }\n\n    @Inject\n    public void setOgnlUtil(OgnlUtil ognlUtil) {\n        this.ognlUtil = ognlUtil;\n    }\n\n    public Interceptor injectParams(Interceptor interceptor, Map<String, String> params, ActionContext invocationContext) {\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            Object paramValue = textParser.evaluate(new char[]{ '$' }, entry.getValue(), valueEvaluator, TextParser.DEFAULT_LOOP_COUNT);\n            ognlUtil.setProperty(entry.getKey(), paramValue, interceptor, invocationContext.getContextMap());\n        }\n\n        return interceptor;\n    }\n\n    private static class LazyParamEvaluator implements TextParseUtil.ParsedValueEvaluator {\n        private final ValueStack valueStack;\n\n        public LazyParamEvaluator(ValueStack valueStack) {\n            this.valueStack = valueStack;\n        }\n\n        @Override\n        public Object evaluate(String parsedValue) {\n            return valueStack.findValue(parsedValue);\n        }\n    }\n}\n}\n"
    },
    {
        "explanation": "Unread public/protected field: com.opensymphony.xwork2.interceptor.WithLazyParams$LazyParamInjector.reflectionProvider",
        "fileName": "com/opensymphony/xwork2/interceptor/WithLazyParams.java",
        "methodStartLineNumber": 48,
        "methodEndLineNumber": 79,
        "warning_type": "URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD",
        "codeSnippet": "\n        public LazyParamInjector(final ValueStack valueStack) {\n            valueEvaluator = new TextParseUtil.ParsedValueEvaluator() {\n                public Object evaluate(String parsedValue) {\n                    return valueStack.findValue(parsedValue); // no asType !!!\n                }\n            };\n        }\n\n        @Inject\n        public void setTextParser(TextParser textParser) {\n            this.textParser = textParser;\n        }\n\n        @Inject\n        public void setReflectionProvider(ReflectionProvider reflectionProvider) {\n            this.reflectionProvider = reflectionProvider;\n        }\n\n        @Inject\n        public void setOgnlUtil(OgnlUtil ognlUtil) {\n            this.ognlUtil = ognlUtil;\n        }\n\n        public Interceptor injectParams(Interceptor interceptor, Map<String, String> params, ActionContext invocationContext) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                Object paramValue = textParser.evaluate(new char[]{ '$' }, entry.getValue(), valueEvaluator, TextParser.DEFAULT_LOOP_COUNT);\n                ognlUtil.setProperty(entry.getKey(), paramValue, interceptor, invocationContext.getContextMap());\n            }\n\n            return interceptor;\n",
        "classStartLineNumber": 41,
        "classEndLineNumber": 80,
        "classCode": "    class LazyParamInjector {\n\n        protected OgnlUtil ognlUtil;\n        protected TextParser textParser;\n        protected ReflectionProvider reflectionProvider;\n\n        private final TextParseUtil.ParsedValueEvaluator valueEvaluator;\n\n        public LazyParamInjector(final ValueStack valueStack) {\n            valueEvaluator = new TextParseUtil.ParsedValueEvaluator() {\n                public Object evaluate(String parsedValue) {\n                    return valueStack.findValue(parsedValue); // no asType !!!\n                }\n            };\n        }\n\n        @Inject\n        public void setTextParser(TextParser textParser) {\n            this.textParser = textParser;\n        }\n\n        @Inject\n        public void setReflectionProvider(ReflectionProvider reflectionProvider) {\n            this.reflectionProvider = reflectionProvider;\n        }\n\n        @Inject\n        public void setOgnlUtil(OgnlUtil ognlUtil) {\n            this.ognlUtil = ognlUtil;\n        }\n\n        public Interceptor injectParams(Interceptor interceptor, Map<String, String> params, ActionContext invocationContext) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                Object paramValue = textParser.evaluate(new char[]{ '$' }, entry.getValue(), valueEvaluator, TextParser.DEFAULT_LOOP_COUNT);\n                ognlUtil.setProperty(entry.getKey(), paramValue, interceptor, invocationContext.getContextMap());\n            }\n\n            return interceptor;\n        }\n    }\n",
        "compositeId": "Unread public/protected field: com.opensymphony.xwork2.interceptor.WithLazyParams$LazyParamInjector.reflectionProvider-com/opensymphony/xwork2/interceptor/WithLazyParams.java",
        "classSize": 40,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.ognl.OgnlUtil;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.TextParser;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.reflection.ReflectionProvider;\n\nimport java.util.Map;\n\n/**\n * Interceptors marked with this interface won't be fully initialised during initialisation.\n * Appropriated params will be injected just before usage of the interceptor.\n *\n * Please be aware that in such case {@link Interceptor#init()} method must be prepared for this.\n *\n * @since 2.5.9\n */\npublic interface WithLazyParams {\n\nclass LazyParamInjector {\n\n    protected OgnlUtil ognlUtil;\n    protected TextParser textParser;\n    private ReflectionProvider reflectionProvider;\n\n    private final TextParseUtil.ParsedValueEvaluator valueEvaluator;\n\n    public LazyParamInjector(final ValueStack valueStack) {\n        valueEvaluator = new TextParseUtil.ParsedValueEvaluator() {\n            public Object evaluate(String parsedValue) {\n                return valueStack.findValue(parsedValue); // no asType !!!\n            }\n        };\n    }\n\n    @Inject\n    public void setTextParser(TextParser textParser) {\n        this.textParser = textParser;\n    }\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider reflectionProvider) {\n        this.reflectionProvider = reflectionProvider;\n    }\n\n    @Inject\n    public void setOgnlUtil(OgnlUtil ognlUtil) {\n        this.ognlUtil = ognlUtil;\n    }\n\n    public Interceptor injectParams(Interceptor interceptor, Map<String, String> params, ActionContext invocationContext) {\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            Object paramValue = textParser.evaluate(new char[]{ '$' }, entry.getValue(), valueEvaluator, TextParser.DEFAULT_LOOP_COUNT);\n            ognlUtil.setProperty(entry.getKey(), paramValue, interceptor, invocationContext.getContextMap());\n        }\n\n        return interceptor;\n    }\n}\n}\n"
    },
    {
        "explanation": "WithLazyParams$LazyParamInjector.ognlUtil not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.WithLazyParams$LazyParamInjector.injectParams(Interceptor, Map, ActionContext)",
        "fileName": "com/opensymphony/xwork2/interceptor/WithLazyParams.java",
        "methodStartLineNumber": 72,
        "methodEndLineNumber": 79,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "        public Interceptor injectParams(Interceptor interceptor, Map<String, String> params, ActionContext invocationContext) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                Object paramValue = textParser.evaluate(new char[]{ '$' }, entry.getValue(), valueEvaluator, TextParser.DEFAULT_LOOP_COUNT);\n                ognlUtil.setProperty(entry.getKey(), paramValue, interceptor, invocationContext.getContextMap());\n            }\n\n            return interceptor;\n",
        "classStartLineNumber": 41,
        "classEndLineNumber": 80,
        "classCode": "    class LazyParamInjector {\n\n        protected OgnlUtil ognlUtil;\n        protected TextParser textParser;\n        protected ReflectionProvider reflectionProvider;\n\n        private final TextParseUtil.ParsedValueEvaluator valueEvaluator;\n\n        public LazyParamInjector(final ValueStack valueStack) {\n            valueEvaluator = new TextParseUtil.ParsedValueEvaluator() {\n                public Object evaluate(String parsedValue) {\n                    return valueStack.findValue(parsedValue); // no asType !!!\n                }\n            };\n        }\n\n        @Inject\n        public void setTextParser(TextParser textParser) {\n            this.textParser = textParser;\n        }\n\n        @Inject\n        public void setReflectionProvider(ReflectionProvider reflectionProvider) {\n            this.reflectionProvider = reflectionProvider;\n        }\n\n        @Inject\n        public void setOgnlUtil(OgnlUtil ognlUtil) {\n            this.ognlUtil = ognlUtil;\n        }\n\n        public Interceptor injectParams(Interceptor interceptor, Map<String, String> params, ActionContext invocationContext) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                Object paramValue = textParser.evaluate(new char[]{ '$' }, entry.getValue(), valueEvaluator, TextParser.DEFAULT_LOOP_COUNT);\n                ognlUtil.setProperty(entry.getKey(), paramValue, interceptor, invocationContext.getContextMap());\n            }\n\n            return interceptor;\n        }\n    }\n",
        "compositeId": "WithLazyParams$LazyParamInjector.ognlUtil not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.WithLazyParams$LazyParamInjector.injectParams(Interceptor, Map, ActionContext)-com/opensymphony/xwork2/interceptor/WithLazyParams.java",
        "classSize": 40,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.ognl.OgnlUtil;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.TextParser;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.reflection.ReflectionProvider;\n\nimport java.util.Map;\n\n/**\n * Interceptors marked with this interface won't be fully initialised during initialisation.\n * Appropriated params will be injected just before usage of the interceptor.\n *\n * Please be aware that in such case {@link Interceptor#init()} method must be prepared for this.\n *\n * @since 2.5.9\n */\npublic interface WithLazyParams {\n\nclass LazyParamInjector {\n\n    protected OgnlUtil ognlUtil;\n    protected TextParser textParser;\n    protected ReflectionProvider reflectionProvider;\n\n    private final TextParseUtil.ParsedValueEvaluator valueEvaluator;\n\n    public LazyParamInjector(final ValueStack valueStack) {\n        valueEvaluator = new TextParseUtil.ParsedValueEvaluator() {\n            public Object evaluate(String parsedValue) {\n                return valueStack.findValue(parsedValue); // no asType !!!\n            }\n        };\n        this.ognlUtil = new OgnlUtil(); // Initialize ognlUtil in the constructor\n    }\n\n    @Inject\n    public void setTextParser(TextParser textParser) {\n        this.textParser = textParser;\n    }\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider reflectionProvider) {\n        this.reflectionProvider = reflectionProvider;\n    }\n\n    @Inject\n    public void setOgnlUtil(OgnlUtil ognlUtil) {\n        this.ognlUtil = ognlUtil;\n    }\n\n    public Interceptor injectParams(Interceptor interceptor, Map<String, String> params, ActionContext invocationContext) {\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            Object paramValue = textParser.evaluate(new char[]{ '$' }, entry.getValue(), valueEvaluator, TextParser.DEFAULT_LOOP_COUNT);\n            ognlUtil.setProperty(entry.getKey(), paramValue, interceptor, invocationContext.getContextMap());\n        }\n\n        return interceptor;\n    }\n}\n}\n"
    },
    {
        "explanation": "WithLazyParams$LazyParamInjector.textParser not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.WithLazyParams$LazyParamInjector.injectParams(Interceptor, Map, ActionContext)",
        "fileName": "com/opensymphony/xwork2/interceptor/WithLazyParams.java",
        "methodStartLineNumber": 72,
        "methodEndLineNumber": 79,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "        public Interceptor injectParams(Interceptor interceptor, Map<String, String> params, ActionContext invocationContext) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                Object paramValue = textParser.evaluate(new char[]{ '$' }, entry.getValue(), valueEvaluator, TextParser.DEFAULT_LOOP_COUNT);\n                ognlUtil.setProperty(entry.getKey(), paramValue, interceptor, invocationContext.getContextMap());\n            }\n\n            return interceptor;\n",
        "classStartLineNumber": 41,
        "classEndLineNumber": 80,
        "classCode": "    class LazyParamInjector {\n\n        protected OgnlUtil ognlUtil;\n        protected TextParser textParser;\n        protected ReflectionProvider reflectionProvider;\n\n        private final TextParseUtil.ParsedValueEvaluator valueEvaluator;\n\n        public LazyParamInjector(final ValueStack valueStack) {\n            valueEvaluator = new TextParseUtil.ParsedValueEvaluator() {\n                public Object evaluate(String parsedValue) {\n                    return valueStack.findValue(parsedValue); // no asType !!!\n                }\n            };\n        }\n\n        @Inject\n        public void setTextParser(TextParser textParser) {\n            this.textParser = textParser;\n        }\n\n        @Inject\n        public void setReflectionProvider(ReflectionProvider reflectionProvider) {\n            this.reflectionProvider = reflectionProvider;\n        }\n\n        @Inject\n        public void setOgnlUtil(OgnlUtil ognlUtil) {\n            this.ognlUtil = ognlUtil;\n        }\n\n        public Interceptor injectParams(Interceptor interceptor, Map<String, String> params, ActionContext invocationContext) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                Object paramValue = textParser.evaluate(new char[]{ '$' }, entry.getValue(), valueEvaluator, TextParser.DEFAULT_LOOP_COUNT);\n                ognlUtil.setProperty(entry.getKey(), paramValue, interceptor, invocationContext.getContextMap());\n            }\n\n            return interceptor;\n        }\n    }\n",
        "compositeId": "WithLazyParams$LazyParamInjector.textParser not initialized in constructor and dereferenced in com.opensymphony.xwork2.interceptor.WithLazyParams$LazyParamInjector.injectParams(Interceptor, Map, ActionContext)-com/opensymphony/xwork2/interceptor/WithLazyParams.java",
        "classSize": 40,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.ognl.OgnlUtil;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.TextParser;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.reflection.ReflectionProvider;\n\nimport java.util.Map;\n\n/**\n * Interceptors marked with this interface won't be fully initialised during initialisation.\n * Appropriated params will be injected just before usage of the interceptor.\n *\n * Please be aware that in such case {@link Interceptor#init()} method must be prepared for this.\n *\n * @since 2.5.9\n */\npublic interface WithLazyParams {\n\nclass LazyParamInjector {\n\n    protected OgnlUtil ognlUtil;\n    protected TextParser textParser;\n    protected ReflectionProvider reflectionProvider;\n\n    private final TextParseUtil.ParsedValueEvaluator valueEvaluator;\n\n    public LazyParamInjector(final ValueStack valueStack) {\n        valueEvaluator = new TextParseUtil.ParsedValueEvaluator() {\n            public Object evaluate(String parsedValue) {\n                return valueStack.findValue(parsedValue); // no asType !!!\n            }\n        };\n    }\n\n    @Inject\n    public void setTextParser(TextParser textParser) {\n        this.textParser = textParser;\n    }\n\n    @Inject\n    public void setReflectionProvider(ReflectionProvider reflectionProvider) {\n        this.reflectionProvider = reflectionProvider;\n    }\n\n    @Inject\n    public void setOgnlUtil(OgnlUtil ognlUtil) {\n        this.ognlUtil = ognlUtil;\n    }\n\n    public Interceptor injectParams(Interceptor interceptor, Map<String, String> params, ActionContext invocationContext) {\n        if (textParser == null) {\n            throw new IllegalStateException(\"textParser is not initialized\");\n        }\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            Object paramValue = textParser.evaluate(new char[]{ '$' }, entry.getValue(), valueEvaluator, TextParser.DEFAULT_LOOP_COUNT);\n            ognlUtil.setProperty(entry.getKey(), paramValue, interceptor, invocationContext.getContextMap());\n        }\n\n        return interceptor;\n    }\n}\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.mock.MockActionInvocation.getInvocationContext() may expose internal representation by returning MockActionInvocation.invocationContext",
        "fileName": "com/opensymphony/xwork2/mock/MockActionInvocation.java",
        "methodStartLineNumber": 56,
        "methodEndLineNumber": 58,
        "warning_type": "EI_EXPOSE_REP",
        "codeSnippet": "    public ActionContext getInvocationContext() {\n        return invocationContext;\n",
        "classStartLineNumber": 36,
        "classEndLineNumber": 127,
        "classCode": "public class MockActionInvocation implements ActionInvocation {\n\n    private Object action;\n    private ActionContext invocationContext;\n    private ActionEventListener actionEventListener;\n    private ActionProxy proxy;\n    private Result result;\n    private String resultCode;\n    private ValueStack stack;\n\n    private List<PreResultListener> preResultListeners = new ArrayList<>();\n\n    public Object getAction() {\n        return action;\n    }\n\n    public void setAction(Object action) {\n        this.action = action;\n    }\n\n    public ActionContext getInvocationContext() {\n        return invocationContext;\n    }\n\n    public void setInvocationContext(ActionContext invocationContext) {\n        this.invocationContext = invocationContext;\n    }\n\n    public ActionProxy getProxy() {\n        return proxy;\n    }\n\n    public void setProxy(ActionProxy proxy) {\n        this.proxy = proxy;\n    }\n\n    public Result getResult() {\n        return result;\n    }\n\n    public void setResult(Result result) {\n        this.result = result;\n    }\n\n    public String getResultCode() {\n        return resultCode;\n    }\n\n    public void setResultCode(String resultCode) {\n        this.resultCode = resultCode;\n    }\n\n    public ValueStack getStack() {\n        return stack;\n    }\n\n    public void setStack(ValueStack stack) {\n        this.stack = stack;\n    }\n\n    public boolean isExecuted() {\n        return false;\n    }\n\n    public void addPreResultListener(PreResultListener listener) {\n    \tpreResultListeners.add(listener);\n    }\n\n    public String invoke() throws Exception {\n        for (Object preResultListener : preResultListeners) {\n            PreResultListener listener = (PreResultListener) preResultListener;\n            listener.beforeResult(this, resultCode);\n        }\n        return resultCode;\n    }\n\n    public String invokeActionOnly() throws Exception {\n        return resultCode;\n    }\n\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n    \n    public ActionEventListener getActionEventListener() {\n        return this.actionEventListener;\n    }\n\n    public void init(ActionProxy proxy) {\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.mock.MockActionInvocation.getInvocationContext() may expose internal representation by returning MockActionInvocation.invocationContext-com/opensymphony/xwork2/mock/MockActionInvocation.java",
        "classSize": 92
    },
    {
        "explanation": "com.opensymphony.xwork2.mock.MockActionInvocation.getProxy() may expose internal representation by returning MockActionInvocation.proxy",
        "fileName": "com/opensymphony/xwork2/mock/MockActionInvocation.java",
        "methodStartLineNumber": 64,
        "methodEndLineNumber": 66,
        "warning_type": "EI_EXPOSE_REP",
        "codeSnippet": "    public ActionProxy getProxy() {\n        return proxy;\n",
        "classStartLineNumber": 36,
        "classEndLineNumber": 127,
        "classCode": "public class MockActionInvocation implements ActionInvocation {\n\n    private Object action;\n    private ActionContext invocationContext;\n    private ActionEventListener actionEventListener;\n    private ActionProxy proxy;\n    private Result result;\n    private String resultCode;\n    private ValueStack stack;\n\n    private List<PreResultListener> preResultListeners = new ArrayList<>();\n\n    public Object getAction() {\n        return action;\n    }\n\n    public void setAction(Object action) {\n        this.action = action;\n    }\n\n    public ActionContext getInvocationContext() {\n        return invocationContext;\n    }\n\n    public void setInvocationContext(ActionContext invocationContext) {\n        this.invocationContext = invocationContext;\n    }\n\n    public ActionProxy getProxy() {\n        return proxy;\n    }\n\n    public void setProxy(ActionProxy proxy) {\n        this.proxy = proxy;\n    }\n\n    public Result getResult() {\n        return result;\n    }\n\n    public void setResult(Result result) {\n        this.result = result;\n    }\n\n    public String getResultCode() {\n        return resultCode;\n    }\n\n    public void setResultCode(String resultCode) {\n        this.resultCode = resultCode;\n    }\n\n    public ValueStack getStack() {\n        return stack;\n    }\n\n    public void setStack(ValueStack stack) {\n        this.stack = stack;\n    }\n\n    public boolean isExecuted() {\n        return false;\n    }\n\n    public void addPreResultListener(PreResultListener listener) {\n    \tpreResultListeners.add(listener);\n    }\n\n    public String invoke() throws Exception {\n        for (Object preResultListener : preResultListeners) {\n            PreResultListener listener = (PreResultListener) preResultListener;\n            listener.beforeResult(this, resultCode);\n        }\n        return resultCode;\n    }\n\n    public String invokeActionOnly() throws Exception {\n        return resultCode;\n    }\n\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n    \n    public ActionEventListener getActionEventListener() {\n        return this.actionEventListener;\n    }\n\n    public void init(ActionProxy proxy) {\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.mock.MockActionInvocation.getProxy() may expose internal representation by returning MockActionInvocation.proxy-com/opensymphony/xwork2/mock/MockActionInvocation.java",
        "classSize": 92
    },
    {
        "explanation": "com.opensymphony.xwork2.mock.MockActionInvocation.getStack() may expose internal representation by returning MockActionInvocation.stack",
        "fileName": "com/opensymphony/xwork2/mock/MockActionInvocation.java",
        "methodStartLineNumber": 88,
        "methodEndLineNumber": 90,
        "warning_type": "EI_EXPOSE_REP",
        "codeSnippet": "    public ValueStack getStack() {\n        return stack;\n",
        "classStartLineNumber": 36,
        "classEndLineNumber": 127,
        "classCode": "public class MockActionInvocation implements ActionInvocation {\n\n    private Object action;\n    private ActionContext invocationContext;\n    private ActionEventListener actionEventListener;\n    private ActionProxy proxy;\n    private Result result;\n    private String resultCode;\n    private ValueStack stack;\n\n    private List<PreResultListener> preResultListeners = new ArrayList<>();\n\n    public Object getAction() {\n        return action;\n    }\n\n    public void setAction(Object action) {\n        this.action = action;\n    }\n\n    public ActionContext getInvocationContext() {\n        return invocationContext;\n    }\n\n    public void setInvocationContext(ActionContext invocationContext) {\n        this.invocationContext = invocationContext;\n    }\n\n    public ActionProxy getProxy() {\n        return proxy;\n    }\n\n    public void setProxy(ActionProxy proxy) {\n        this.proxy = proxy;\n    }\n\n    public Result getResult() {\n        return result;\n    }\n\n    public void setResult(Result result) {\n        this.result = result;\n    }\n\n    public String getResultCode() {\n        return resultCode;\n    }\n\n    public void setResultCode(String resultCode) {\n        this.resultCode = resultCode;\n    }\n\n    public ValueStack getStack() {\n        return stack;\n    }\n\n    public void setStack(ValueStack stack) {\n        this.stack = stack;\n    }\n\n    public boolean isExecuted() {\n        return false;\n    }\n\n    public void addPreResultListener(PreResultListener listener) {\n    \tpreResultListeners.add(listener);\n    }\n\n    public String invoke() throws Exception {\n        for (Object preResultListener : preResultListeners) {\n            PreResultListener listener = (PreResultListener) preResultListener;\n            listener.beforeResult(this, resultCode);\n        }\n        return resultCode;\n    }\n\n    public String invokeActionOnly() throws Exception {\n        return resultCode;\n    }\n\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n    \n    public ActionEventListener getActionEventListener() {\n        return this.actionEventListener;\n    }\n\n    public void init(ActionProxy proxy) {\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.mock.MockActionInvocation.getStack() may expose internal representation by returning MockActionInvocation.stack-com/opensymphony/xwork2/mock/MockActionInvocation.java",
        "classSize": 92
    },
    {
        "explanation": "com.opensymphony.xwork2.mock.MockActionInvocation.setInvocationContext(ActionContext) may expose internal representation by storing an externally mutable object into MockActionInvocation.invocationContext",
        "fileName": "com/opensymphony/xwork2/mock/MockActionInvocation.java",
        "methodStartLineNumber": 60,
        "methodEndLineNumber": 63,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setInvocationContext(ActionContext invocationContext) {\n        this.invocationContext = invocationContext;\n    }\n",
        "classStartLineNumber": 36,
        "classEndLineNumber": 127,
        "classCode": "public class MockActionInvocation implements ActionInvocation {\n\n    private Object action;\n    private ActionContext invocationContext;\n    private ActionEventListener actionEventListener;\n    private ActionProxy proxy;\n    private Result result;\n    private String resultCode;\n    private ValueStack stack;\n\n    private List<PreResultListener> preResultListeners = new ArrayList<>();\n\n    public Object getAction() {\n        return action;\n    }\n\n    public void setAction(Object action) {\n        this.action = action;\n    }\n\n    public ActionContext getInvocationContext() {\n        return invocationContext;\n    }\n\n    public void setInvocationContext(ActionContext invocationContext) {\n        this.invocationContext = invocationContext;\n    }\n\n    public ActionProxy getProxy() {\n        return proxy;\n    }\n\n    public void setProxy(ActionProxy proxy) {\n        this.proxy = proxy;\n    }\n\n    public Result getResult() {\n        return result;\n    }\n\n    public void setResult(Result result) {\n        this.result = result;\n    }\n\n    public String getResultCode() {\n        return resultCode;\n    }\n\n    public void setResultCode(String resultCode) {\n        this.resultCode = resultCode;\n    }\n\n    public ValueStack getStack() {\n        return stack;\n    }\n\n    public void setStack(ValueStack stack) {\n        this.stack = stack;\n    }\n\n    public boolean isExecuted() {\n        return false;\n    }\n\n    public void addPreResultListener(PreResultListener listener) {\n    \tpreResultListeners.add(listener);\n    }\n\n    public String invoke() throws Exception {\n        for (Object preResultListener : preResultListeners) {\n            PreResultListener listener = (PreResultListener) preResultListener;\n            listener.beforeResult(this, resultCode);\n        }\n        return resultCode;\n    }\n\n    public String invokeActionOnly() throws Exception {\n        return resultCode;\n    }\n\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n    \n    public ActionEventListener getActionEventListener() {\n        return this.actionEventListener;\n    }\n\n    public void init(ActionProxy proxy) {\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.mock.MockActionInvocation.setInvocationContext(ActionContext) may expose internal representation by storing an externally mutable object into MockActionInvocation.invocationContext-com/opensymphony/xwork2/mock/MockActionInvocation.java",
        "classSize": 92
    },
    {
        "explanation": "com.opensymphony.xwork2.mock.MockActionInvocation.setProxy(ActionProxy) may expose internal representation by storing an externally mutable object into MockActionInvocation.proxy",
        "fileName": "com/opensymphony/xwork2/mock/MockActionInvocation.java",
        "methodStartLineNumber": 68,
        "methodEndLineNumber": 71,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setProxy(ActionProxy proxy) {\n        this.proxy = proxy;\n    }\n",
        "classStartLineNumber": 36,
        "classEndLineNumber": 127,
        "classCode": "public class MockActionInvocation implements ActionInvocation {\n\n    private Object action;\n    private ActionContext invocationContext;\n    private ActionEventListener actionEventListener;\n    private ActionProxy proxy;\n    private Result result;\n    private String resultCode;\n    private ValueStack stack;\n\n    private List<PreResultListener> preResultListeners = new ArrayList<>();\n\n    public Object getAction() {\n        return action;\n    }\n\n    public void setAction(Object action) {\n        this.action = action;\n    }\n\n    public ActionContext getInvocationContext() {\n        return invocationContext;\n    }\n\n    public void setInvocationContext(ActionContext invocationContext) {\n        this.invocationContext = invocationContext;\n    }\n\n    public ActionProxy getProxy() {\n        return proxy;\n    }\n\n    public void setProxy(ActionProxy proxy) {\n        this.proxy = proxy;\n    }\n\n    public Result getResult() {\n        return result;\n    }\n\n    public void setResult(Result result) {\n        this.result = result;\n    }\n\n    public String getResultCode() {\n        return resultCode;\n    }\n\n    public void setResultCode(String resultCode) {\n        this.resultCode = resultCode;\n    }\n\n    public ValueStack getStack() {\n        return stack;\n    }\n\n    public void setStack(ValueStack stack) {\n        this.stack = stack;\n    }\n\n    public boolean isExecuted() {\n        return false;\n    }\n\n    public void addPreResultListener(PreResultListener listener) {\n    \tpreResultListeners.add(listener);\n    }\n\n    public String invoke() throws Exception {\n        for (Object preResultListener : preResultListeners) {\n            PreResultListener listener = (PreResultListener) preResultListener;\n            listener.beforeResult(this, resultCode);\n        }\n        return resultCode;\n    }\n\n    public String invokeActionOnly() throws Exception {\n        return resultCode;\n    }\n\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n    \n    public ActionEventListener getActionEventListener() {\n        return this.actionEventListener;\n    }\n\n    public void init(ActionProxy proxy) {\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.mock.MockActionInvocation.setProxy(ActionProxy) may expose internal representation by storing an externally mutable object into MockActionInvocation.proxy-com/opensymphony/xwork2/mock/MockActionInvocation.java",
        "classSize": 92
    },
    {
        "explanation": "com.opensymphony.xwork2.mock.MockActionInvocation.setStack(ValueStack) may expose internal representation by storing an externally mutable object into MockActionInvocation.stack",
        "fileName": "com/opensymphony/xwork2/mock/MockActionInvocation.java",
        "methodStartLineNumber": 92,
        "methodEndLineNumber": 95,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setStack(ValueStack stack) {\n        this.stack = stack;\n    }\n",
        "classStartLineNumber": 36,
        "classEndLineNumber": 127,
        "classCode": "public class MockActionInvocation implements ActionInvocation {\n\n    private Object action;\n    private ActionContext invocationContext;\n    private ActionEventListener actionEventListener;\n    private ActionProxy proxy;\n    private Result result;\n    private String resultCode;\n    private ValueStack stack;\n\n    private List<PreResultListener> preResultListeners = new ArrayList<>();\n\n    public Object getAction() {\n        return action;\n    }\n\n    public void setAction(Object action) {\n        this.action = action;\n    }\n\n    public ActionContext getInvocationContext() {\n        return invocationContext;\n    }\n\n    public void setInvocationContext(ActionContext invocationContext) {\n        this.invocationContext = invocationContext;\n    }\n\n    public ActionProxy getProxy() {\n        return proxy;\n    }\n\n    public void setProxy(ActionProxy proxy) {\n        this.proxy = proxy;\n    }\n\n    public Result getResult() {\n        return result;\n    }\n\n    public void setResult(Result result) {\n        this.result = result;\n    }\n\n    public String getResultCode() {\n        return resultCode;\n    }\n\n    public void setResultCode(String resultCode) {\n        this.resultCode = resultCode;\n    }\n\n    public ValueStack getStack() {\n        return stack;\n    }\n\n    public void setStack(ValueStack stack) {\n        this.stack = stack;\n    }\n\n    public boolean isExecuted() {\n        return false;\n    }\n\n    public void addPreResultListener(PreResultListener listener) {\n    \tpreResultListeners.add(listener);\n    }\n\n    public String invoke() throws Exception {\n        for (Object preResultListener : preResultListeners) {\n            PreResultListener listener = (PreResultListener) preResultListener;\n            listener.beforeResult(this, resultCode);\n        }\n        return resultCode;\n    }\n\n    public String invokeActionOnly() throws Exception {\n        return resultCode;\n    }\n\n    public void setActionEventListener(ActionEventListener listener) {\n        this.actionEventListener = listener;\n    }\n    \n    public ActionEventListener getActionEventListener() {\n        return this.actionEventListener;\n    }\n\n    public void init(ActionProxy proxy) {\n    }\n\n}\n",
        "compositeId": "com.opensymphony.xwork2.mock.MockActionInvocation.setStack(ValueStack) may expose internal representation by storing an externally mutable object into MockActionInvocation.stack-com/opensymphony/xwork2/mock/MockActionInvocation.java",
        "classSize": 92
    },
    {
        "explanation": "Unchecked/unconfirmed cast from ognl.PropertyAccessor to com.opensymphony.xwork2.ognl.accessor.XWorkCollectionPropertyAccessor in com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor.setXWorkCollectionPropertyAccessor(PropertyAccessor)",
        "fileName": "com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
        "methodStartLineNumber": 60,
        "methodEndLineNumber": 63,
        "warning_type": "BC_UNCONFIRMED_CAST",
        "codeSnippet": "    public void setXWorkCollectionPropertyAccessor(PropertyAccessor acc) {\n        this._sAcc = (XWorkCollectionPropertyAccessor) acc;\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 195,
        "classCode": "public class XWorkListPropertyAccessor extends ListPropertyAccessor {\n\n    private XWorkCollectionPropertyAccessor _sAcc = new XWorkCollectionPropertyAccessor();\n    \n    private XWorkConverter xworkConverter;\n    private ObjectFactory objectFactory;\n    private ObjectTypeDeterminer objectTypeDeterminer;\n    private OgnlUtil ognlUtil;\n    private int autoGrowCollectionLimit = 255;\n\n    @Inject(value = StrutsConstants.STRUTS_OGNL_AUTO_GROWTH_COLLECTION_LIMIT, required = false)\n    public void setAutoGrowCollectionLimit(String value) {\n        this.autoGrowCollectionLimit = Integer.parseInt(value);\n    }\n\n    @Inject(\"java.util.Collection\")\n    public void setXWorkCollectionPropertyAccessor(PropertyAccessor acc) {\n        this._sAcc = (XWorkCollectionPropertyAccessor) acc;\n    }\n    \n    @Inject\n    public void setXWorkConverter(XWorkConverter conv) {\n        this.xworkConverter = conv;\n    }\n    \n    @Inject\n    public void setObjectFactory(ObjectFactory fac) {\n        this.objectFactory = fac;\n    }\n    \n    @Inject\n    public void setObjectTypeDeterminer(ObjectTypeDeterminer ot) {\n        this.objectTypeDeterminer = ot;\n    }\n    \n    @Inject\n    public void setOgnlUtil(OgnlUtil util) {\n        this.ognlUtil = util;\n    }\n\n    @Override\n    public Object getProperty(Map context, Object target, Object name) throws OgnlException {\n\n        if (ReflectionContextState.isGettingByKeyProperty(context)\n                || name.equals(XWorkCollectionPropertyAccessor.KEY_PROPERTY_FOR_CREATION)) {\n            return _sAcc.getProperty(context, target, name);\n        } else if (name instanceof String) {\n            return super.getProperty(context, target, name);\n        }\n        ReflectionContextState.updateCurrentPropertyPath(context, name);\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        \n        if (name instanceof Number\n                && ReflectionContextState.isCreatingNullObjects(context)\n                && objectTypeDeterminer.shouldCreateIfNew(lastClass,lastProperty,target,null,true)) {\n\n            List list = (List) target;\n            int index = ((Number) name).intValue();\n            int listSize = list.size();\n\n            if (lastClass == null || lastProperty == null) {\n                return super.getProperty(context, target, name);\n            }\n            Class beanClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n            if (listSize <= index) {\n                Object result;\n\n                if (index > autoGrowCollectionLimit) {\n                    throw new OgnlException(\"Error auto growing collection size to \" + index + \" which limited to \"\n                                            + autoGrowCollectionLimit);\n                }\n\n                for (int i = listSize; i < index; i++) {\n                    list.add(null);\n                }\n                try {\n                    list.add(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            } else if (list.get(index) == null) {\n                Object result;\n                try {\n                    list.set(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            }\n        }\n        return super.getProperty(context, target, name);\n    }\n\n    @Override\n    public void setProperty(Map context, Object target, Object name, Object value)\n            throws OgnlException {\n\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        Class convertToClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n\n        if (name instanceof String && value.getClass().isArray()) {\n            // looks like the input game in the form of \"someList.foo\" and\n            // we are expected to define the index values ourselves.\n            // So let's do it:\n\n            Collection c = (Collection) target;\n            Object[] values = (Object[]) value;\n            for (Object v : values) {\n                try {\n                    Object o = objectFactory.buildBean(convertToClass, context);\n                    ognlUtil.setValue((String) name, context, o, v);\n                    c.add(o);\n                } catch (Exception e) {\n                    throw new OgnlException(\"Error converting given String values for Collection.\", e);\n                }\n            }\n\n            // we don't want to do the normal list property setting now, since we've already done the work\n            // just return instead\n            return;\n        }\n\n        Object realValue = getRealValue(context, value, convertToClass);\n\n        if (target instanceof List && name instanceof Number) {\n            //make sure there are enough spaces in the List to set\n            List list = (List) target;\n            int listSize = list.size();\n            int count = ((Number) name).intValue();\n            if(count > autoGrowCollectionLimit)\n            \tthrow new OgnlException(\"Error auto growing collection size to \" + count + \" which limited to \"\n\t\t\t\t\t\t+ autoGrowCollectionLimit);\n            if (count >= listSize) {\n                for (int i = listSize; i <= count; i++) {\n                    list.add(null);\n                }\n            }\n        }\n\n        super.setProperty(context, target, name, realValue);\n    }\n\n    private Object getRealValue(Map context, Object value, Class convertToClass) {\n        if (value == null || convertToClass == null) {\n            return value;\n        }\n        return xworkConverter.convertValue(context, value, convertToClass);\n    }\n}\n",
        "compositeId": "Unchecked/unconfirmed cast from ognl.PropertyAccessor to com.opensymphony.xwork2.ognl.accessor.XWorkCollectionPropertyAccessor in com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor.setXWorkCollectionPropertyAccessor(PropertyAccessor)-com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
        "classSize": 152,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.ognl.accessor;\n\nimport com.opensymphony.xwork2.ObjectFactory;\nimport com.opensymphony.xwork2.conversion.ObjectTypeDeterminer;\nimport com.opensymphony.xwork2.conversion.impl.XWorkConverter;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.ognl.OgnlUtil;\nimport com.opensymphony.xwork2.util.reflection.ReflectionContextState;\nimport ognl.ListPropertyAccessor;\nimport ognl.OgnlException;\nimport ognl.PropertyAccessor;\nimport org.apache.struts2.StrutsConstants;\nimport org.apache.struts2.StrutsException;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Overrides the list property accessor so in the case of trying\n * to add properties of a given bean and the JavaBean is not present,\n * this class will create the necessary blank JavaBeans.\n *\n * @author Gabriel Zimmerman\n */\npublic class XWorkListPropertyAccessor extends ListPropertyAccessor {\n\n    private XWorkCollectionPropertyAccessor _sAcc = new XWorkCollectionPropertyAccessor();\n    \n    private XWorkConverter xworkConverter;\n    private ObjectFactory objectFactory;\n    private ObjectTypeDeterminer objectTypeDeterminer;\n    private OgnlUtil ognlUtil;\n    private int autoGrowCollectionLimit = 255;\n\n    @Inject(value = StrutsConstants.STRUTS_OGNL_AUTO_GROWTH_COLLECTION_LIMIT, required = false)\n    public void setAutoGrowCollectionLimit(String value) {\n        this.autoGrowCollectionLimit = Integer.parseInt(value);\n    }\n\n    @Inject(\"java.util.Collection\")\n    public void setXWorkCollectionPropertyAccessor(PropertyAccessor acc) {\n        if (acc instanceof XWorkCollectionPropertyAccessor) {\n            this._sAcc = (XWorkCollectionPropertyAccessor) acc;\n        } else {\n            throw new IllegalArgumentException(\"Invalid PropertyAccessor type. Expected XWorkCollectionPropertyAccessor.\");\n        }\n    }\n    \n    @Inject\n    public void setXWorkConverter(XWorkConverter conv) {\n        this.xworkConverter = conv;\n    }\n    \n    @Inject\n    public void setObjectFactory(ObjectFactory fac) {\n        this.objectFactory = fac;\n    }\n    \n    @Inject\n    public void setObjectTypeDeterminer(ObjectTypeDeterminer ot) {\n        this.objectTypeDeterminer = ot;\n    }\n    \n    @Inject\n    public void setOgnlUtil(OgnlUtil util) {\n        this.ognlUtil = util;\n    }\n\n    @Override\n    public Object getProperty(Map context, Object target, Object name) throws OgnlException {\n\n        if (ReflectionContextState.isGettingByKeyProperty(context)\n                || name.equals(XWorkCollectionPropertyAccessor.KEY_PROPERTY_FOR_CREATION)) {\n            return _sAcc.getProperty(context, target, name);\n        } else if (name instanceof String) {\n            return super.getProperty(context, target, name);\n        }\n        ReflectionContextState.updateCurrentPropertyPath(context, name);\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        \n        if (name instanceof Number\n                && ReflectionContextState.isCreatingNullObjects(context)\n                && objectTypeDeterminer.shouldCreateIfNew(lastClass,lastProperty,target,null,true)) {\n\n            List list = (List) target;\n            int index = ((Number) name).intValue();\n            int listSize = list.size();\n\n            if (lastClass == null || lastProperty == null) {\n                return super.getProperty(context, target, name);\n            }\n            Class beanClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n            if (listSize <= index) {\n                Object result;\n\n                if (index > autoGrowCollectionLimit) {\n                    throw new OgnlException(\"Error auto growing collection size to \" + index + \" which limited to \"\n                                            + autoGrowCollectionLimit);\n                }\n\n                for (int i = listSize; i < index; i++) {\n                    list.add(null);\n                }\n                try {\n                    list.add(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            } else if (list.get(index) == null) {\n                Object result;\n                try {\n                    list.set(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            }\n        }\n        return super.getProperty(context, target, name);\n    }\n\n    @Override\n    public void setProperty(Map context, Object target, Object name, Object value)\n            throws OgnlException {\n\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        Class convertToClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n\n        if (name instanceof String && value.getClass().isArray()) {\n            // looks like the input game in the form of \"someList.foo\" and\n            // we are expected to define the index values ourselves.\n            // So let's do it:\n\n            Collection c = (Collection) target;\n            Object[] values = (Object[]) value;\n            for (Object v : values) {\n                try {\n                    Object o = objectFactory.buildBean(convertToClass, context);\n                    ognlUtil.setValue((String) name, context, o, v);\n                    c.add(o);\n                } catch (Exception e) {\n                    throw new OgnlException(\"Error converting given String values for Collection.\", e);\n                }\n            }\n\n            // we don't want to do the normal list property setting now, since we've already done the work\n            // just return instead\n            return;\n        }\n\n        Object realValue = getRealValue(context, value, convertToClass);\n\n        if (target instanceof List && name instanceof Number) {\n            //make sure there are enough spaces in the List to set\n            List list = (List) target;\n            int listSize = list.size();\n            int count = ((Number) name).intValue();\n            if(count > autoGrowCollectionLimit)\n            \tthrow new OgnlException(\"Error auto growing collection size to \" + count + \" which limited to \"\n\t\t\t\t\t\t+ autoGrowCollectionLimit);\n            if (count >= listSize) {\n                for (int i = listSize; i <= count; i++) {\n                    list.add(null);\n                }\n            }\n        }\n\n        super.setProperty(context, target, name, realValue);\n    }\n\n    private Object getRealValue(Map context, Object value, Class convertToClass) {\n        if (value == null || convertToClass == null) {\n            return value;\n        }\n        return xworkConverter.convertValue(context, value, convertToClass);\n    }\n}\n"
    },
    {
        "explanation": "com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor.setObjectFactory(ObjectFactory) may expose internal representation by storing an externally mutable object into XWorkListPropertyAccessor.objectFactory",
        "fileName": "com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
        "methodStartLineNumber": 70,
        "methodEndLineNumber": 73,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setObjectFactory(ObjectFactory fac) {\n        this.objectFactory = fac;\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 195,
        "classCode": "public class XWorkListPropertyAccessor extends ListPropertyAccessor {\n\n    private XWorkCollectionPropertyAccessor _sAcc = new XWorkCollectionPropertyAccessor();\n    \n    private XWorkConverter xworkConverter;\n    private ObjectFactory objectFactory;\n    private ObjectTypeDeterminer objectTypeDeterminer;\n    private OgnlUtil ognlUtil;\n    private int autoGrowCollectionLimit = 255;\n\n    @Inject(value = StrutsConstants.STRUTS_OGNL_AUTO_GROWTH_COLLECTION_LIMIT, required = false)\n    public void setAutoGrowCollectionLimit(String value) {\n        this.autoGrowCollectionLimit = Integer.parseInt(value);\n    }\n\n    @Inject(\"java.util.Collection\")\n    public void setXWorkCollectionPropertyAccessor(PropertyAccessor acc) {\n        this._sAcc = (XWorkCollectionPropertyAccessor) acc;\n    }\n    \n    @Inject\n    public void setXWorkConverter(XWorkConverter conv) {\n        this.xworkConverter = conv;\n    }\n    \n    @Inject\n    public void setObjectFactory(ObjectFactory fac) {\n        this.objectFactory = fac;\n    }\n    \n    @Inject\n    public void setObjectTypeDeterminer(ObjectTypeDeterminer ot) {\n        this.objectTypeDeterminer = ot;\n    }\n    \n    @Inject\n    public void setOgnlUtil(OgnlUtil util) {\n        this.ognlUtil = util;\n    }\n\n    @Override\n    public Object getProperty(Map context, Object target, Object name) throws OgnlException {\n\n        if (ReflectionContextState.isGettingByKeyProperty(context)\n                || name.equals(XWorkCollectionPropertyAccessor.KEY_PROPERTY_FOR_CREATION)) {\n            return _sAcc.getProperty(context, target, name);\n        } else if (name instanceof String) {\n            return super.getProperty(context, target, name);\n        }\n        ReflectionContextState.updateCurrentPropertyPath(context, name);\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        \n        if (name instanceof Number\n                && ReflectionContextState.isCreatingNullObjects(context)\n                && objectTypeDeterminer.shouldCreateIfNew(lastClass,lastProperty,target,null,true)) {\n\n            List list = (List) target;\n            int index = ((Number) name).intValue();\n            int listSize = list.size();\n\n            if (lastClass == null || lastProperty == null) {\n                return super.getProperty(context, target, name);\n            }\n            Class beanClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n            if (listSize <= index) {\n                Object result;\n\n                if (index > autoGrowCollectionLimit) {\n                    throw new OgnlException(\"Error auto growing collection size to \" + index + \" which limited to \"\n                                            + autoGrowCollectionLimit);\n                }\n\n                for (int i = listSize; i < index; i++) {\n                    list.add(null);\n                }\n                try {\n                    list.add(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            } else if (list.get(index) == null) {\n                Object result;\n                try {\n                    list.set(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            }\n        }\n        return super.getProperty(context, target, name);\n    }\n\n    @Override\n    public void setProperty(Map context, Object target, Object name, Object value)\n            throws OgnlException {\n\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        Class convertToClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n\n        if (name instanceof String && value.getClass().isArray()) {\n            // looks like the input game in the form of \"someList.foo\" and\n            // we are expected to define the index values ourselves.\n            // So let's do it:\n\n            Collection c = (Collection) target;\n            Object[] values = (Object[]) value;\n            for (Object v : values) {\n                try {\n                    Object o = objectFactory.buildBean(convertToClass, context);\n                    ognlUtil.setValue((String) name, context, o, v);\n                    c.add(o);\n                } catch (Exception e) {\n                    throw new OgnlException(\"Error converting given String values for Collection.\", e);\n                }\n            }\n\n            // we don't want to do the normal list property setting now, since we've already done the work\n            // just return instead\n            return;\n        }\n\n        Object realValue = getRealValue(context, value, convertToClass);\n\n        if (target instanceof List && name instanceof Number) {\n            //make sure there are enough spaces in the List to set\n            List list = (List) target;\n            int listSize = list.size();\n            int count = ((Number) name).intValue();\n            if(count > autoGrowCollectionLimit)\n            \tthrow new OgnlException(\"Error auto growing collection size to \" + count + \" which limited to \"\n\t\t\t\t\t\t+ autoGrowCollectionLimit);\n            if (count >= listSize) {\n                for (int i = listSize; i <= count; i++) {\n                    list.add(null);\n                }\n            }\n        }\n\n        super.setProperty(context, target, name, realValue);\n    }\n\n    private Object getRealValue(Map context, Object value, Class convertToClass) {\n        if (value == null || convertToClass == null) {\n            return value;\n        }\n        return xworkConverter.convertValue(context, value, convertToClass);\n    }\n}\n",
        "compositeId": "com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor.setObjectFactory(ObjectFactory) may expose internal representation by storing an externally mutable object into XWorkListPropertyAccessor.objectFactory-com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
        "classSize": 152
    },
    {
        "explanation": "com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor.setOgnlUtil(OgnlUtil) may expose internal representation by storing an externally mutable object into XWorkListPropertyAccessor.ognlUtil",
        "fileName": "com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
        "methodStartLineNumber": 80,
        "methodEndLineNumber": 83,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setOgnlUtil(OgnlUtil util) {\n        this.ognlUtil = util;\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 195,
        "classCode": "public class XWorkListPropertyAccessor extends ListPropertyAccessor {\n\n    private XWorkCollectionPropertyAccessor _sAcc = new XWorkCollectionPropertyAccessor();\n    \n    private XWorkConverter xworkConverter;\n    private ObjectFactory objectFactory;\n    private ObjectTypeDeterminer objectTypeDeterminer;\n    private OgnlUtil ognlUtil;\n    private int autoGrowCollectionLimit = 255;\n\n    @Inject(value = StrutsConstants.STRUTS_OGNL_AUTO_GROWTH_COLLECTION_LIMIT, required = false)\n    public void setAutoGrowCollectionLimit(String value) {\n        this.autoGrowCollectionLimit = Integer.parseInt(value);\n    }\n\n    @Inject(\"java.util.Collection\")\n    public void setXWorkCollectionPropertyAccessor(PropertyAccessor acc) {\n        this._sAcc = (XWorkCollectionPropertyAccessor) acc;\n    }\n    \n    @Inject\n    public void setXWorkConverter(XWorkConverter conv) {\n        this.xworkConverter = conv;\n    }\n    \n    @Inject\n    public void setObjectFactory(ObjectFactory fac) {\n        this.objectFactory = fac;\n    }\n    \n    @Inject\n    public void setObjectTypeDeterminer(ObjectTypeDeterminer ot) {\n        this.objectTypeDeterminer = ot;\n    }\n    \n    @Inject\n    public void setOgnlUtil(OgnlUtil util) {\n        this.ognlUtil = util;\n    }\n\n    @Override\n    public Object getProperty(Map context, Object target, Object name) throws OgnlException {\n\n        if (ReflectionContextState.isGettingByKeyProperty(context)\n                || name.equals(XWorkCollectionPropertyAccessor.KEY_PROPERTY_FOR_CREATION)) {\n            return _sAcc.getProperty(context, target, name);\n        } else if (name instanceof String) {\n            return super.getProperty(context, target, name);\n        }\n        ReflectionContextState.updateCurrentPropertyPath(context, name);\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        \n        if (name instanceof Number\n                && ReflectionContextState.isCreatingNullObjects(context)\n                && objectTypeDeterminer.shouldCreateIfNew(lastClass,lastProperty,target,null,true)) {\n\n            List list = (List) target;\n            int index = ((Number) name).intValue();\n            int listSize = list.size();\n\n            if (lastClass == null || lastProperty == null) {\n                return super.getProperty(context, target, name);\n            }\n            Class beanClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n            if (listSize <= index) {\n                Object result;\n\n                if (index > autoGrowCollectionLimit) {\n                    throw new OgnlException(\"Error auto growing collection size to \" + index + \" which limited to \"\n                                            + autoGrowCollectionLimit);\n                }\n\n                for (int i = listSize; i < index; i++) {\n                    list.add(null);\n                }\n                try {\n                    list.add(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            } else if (list.get(index) == null) {\n                Object result;\n                try {\n                    list.set(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            }\n        }\n        return super.getProperty(context, target, name);\n    }\n\n    @Override\n    public void setProperty(Map context, Object target, Object name, Object value)\n            throws OgnlException {\n\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        Class convertToClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n\n        if (name instanceof String && value.getClass().isArray()) {\n            // looks like the input game in the form of \"someList.foo\" and\n            // we are expected to define the index values ourselves.\n            // So let's do it:\n\n            Collection c = (Collection) target;\n            Object[] values = (Object[]) value;\n            for (Object v : values) {\n                try {\n                    Object o = objectFactory.buildBean(convertToClass, context);\n                    ognlUtil.setValue((String) name, context, o, v);\n                    c.add(o);\n                } catch (Exception e) {\n                    throw new OgnlException(\"Error converting given String values for Collection.\", e);\n                }\n            }\n\n            // we don't want to do the normal list property setting now, since we've already done the work\n            // just return instead\n            return;\n        }\n\n        Object realValue = getRealValue(context, value, convertToClass);\n\n        if (target instanceof List && name instanceof Number) {\n            //make sure there are enough spaces in the List to set\n            List list = (List) target;\n            int listSize = list.size();\n            int count = ((Number) name).intValue();\n            if(count > autoGrowCollectionLimit)\n            \tthrow new OgnlException(\"Error auto growing collection size to \" + count + \" which limited to \"\n\t\t\t\t\t\t+ autoGrowCollectionLimit);\n            if (count >= listSize) {\n                for (int i = listSize; i <= count; i++) {\n                    list.add(null);\n                }\n            }\n        }\n\n        super.setProperty(context, target, name, realValue);\n    }\n\n    private Object getRealValue(Map context, Object value, Class convertToClass) {\n        if (value == null || convertToClass == null) {\n            return value;\n        }\n        return xworkConverter.convertValue(context, value, convertToClass);\n    }\n}\n",
        "compositeId": "com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor.setOgnlUtil(OgnlUtil) may expose internal representation by storing an externally mutable object into XWorkListPropertyAccessor.ognlUtil-com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
        "classSize": 152
    },
    {
        "explanation": "com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor.setXWorkCollectionPropertyAccessor(PropertyAccessor) may expose internal representation by storing an externally mutable object into XWorkListPropertyAccessor._sAcc",
        "fileName": "com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
        "methodStartLineNumber": 60,
        "methodEndLineNumber": 63,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setXWorkCollectionPropertyAccessor(PropertyAccessor acc) {\n        this._sAcc = (XWorkCollectionPropertyAccessor) acc;\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 195,
        "classCode": "public class XWorkListPropertyAccessor extends ListPropertyAccessor {\n\n    private XWorkCollectionPropertyAccessor _sAcc = new XWorkCollectionPropertyAccessor();\n    \n    private XWorkConverter xworkConverter;\n    private ObjectFactory objectFactory;\n    private ObjectTypeDeterminer objectTypeDeterminer;\n    private OgnlUtil ognlUtil;\n    private int autoGrowCollectionLimit = 255;\n\n    @Inject(value = StrutsConstants.STRUTS_OGNL_AUTO_GROWTH_COLLECTION_LIMIT, required = false)\n    public void setAutoGrowCollectionLimit(String value) {\n        this.autoGrowCollectionLimit = Integer.parseInt(value);\n    }\n\n    @Inject(\"java.util.Collection\")\n    public void setXWorkCollectionPropertyAccessor(PropertyAccessor acc) {\n        this._sAcc = (XWorkCollectionPropertyAccessor) acc;\n    }\n    \n    @Inject\n    public void setXWorkConverter(XWorkConverter conv) {\n        this.xworkConverter = conv;\n    }\n    \n    @Inject\n    public void setObjectFactory(ObjectFactory fac) {\n        this.objectFactory = fac;\n    }\n    \n    @Inject\n    public void setObjectTypeDeterminer(ObjectTypeDeterminer ot) {\n        this.objectTypeDeterminer = ot;\n    }\n    \n    @Inject\n    public void setOgnlUtil(OgnlUtil util) {\n        this.ognlUtil = util;\n    }\n\n    @Override\n    public Object getProperty(Map context, Object target, Object name) throws OgnlException {\n\n        if (ReflectionContextState.isGettingByKeyProperty(context)\n                || name.equals(XWorkCollectionPropertyAccessor.KEY_PROPERTY_FOR_CREATION)) {\n            return _sAcc.getProperty(context, target, name);\n        } else if (name instanceof String) {\n            return super.getProperty(context, target, name);\n        }\n        ReflectionContextState.updateCurrentPropertyPath(context, name);\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        \n        if (name instanceof Number\n                && ReflectionContextState.isCreatingNullObjects(context)\n                && objectTypeDeterminer.shouldCreateIfNew(lastClass,lastProperty,target,null,true)) {\n\n            List list = (List) target;\n            int index = ((Number) name).intValue();\n            int listSize = list.size();\n\n            if (lastClass == null || lastProperty == null) {\n                return super.getProperty(context, target, name);\n            }\n            Class beanClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n            if (listSize <= index) {\n                Object result;\n\n                if (index > autoGrowCollectionLimit) {\n                    throw new OgnlException(\"Error auto growing collection size to \" + index + \" which limited to \"\n                                            + autoGrowCollectionLimit);\n                }\n\n                for (int i = listSize; i < index; i++) {\n                    list.add(null);\n                }\n                try {\n                    list.add(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            } else if (list.get(index) == null) {\n                Object result;\n                try {\n                    list.set(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            }\n        }\n        return super.getProperty(context, target, name);\n    }\n\n    @Override\n    public void setProperty(Map context, Object target, Object name, Object value)\n            throws OgnlException {\n\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        Class convertToClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n\n        if (name instanceof String && value.getClass().isArray()) {\n            // looks like the input game in the form of \"someList.foo\" and\n            // we are expected to define the index values ourselves.\n            // So let's do it:\n\n            Collection c = (Collection) target;\n            Object[] values = (Object[]) value;\n            for (Object v : values) {\n                try {\n                    Object o = objectFactory.buildBean(convertToClass, context);\n                    ognlUtil.setValue((String) name, context, o, v);\n                    c.add(o);\n                } catch (Exception e) {\n                    throw new OgnlException(\"Error converting given String values for Collection.\", e);\n                }\n            }\n\n            // we don't want to do the normal list property setting now, since we've already done the work\n            // just return instead\n            return;\n        }\n\n        Object realValue = getRealValue(context, value, convertToClass);\n\n        if (target instanceof List && name instanceof Number) {\n            //make sure there are enough spaces in the List to set\n            List list = (List) target;\n            int listSize = list.size();\n            int count = ((Number) name).intValue();\n            if(count > autoGrowCollectionLimit)\n            \tthrow new OgnlException(\"Error auto growing collection size to \" + count + \" which limited to \"\n\t\t\t\t\t\t+ autoGrowCollectionLimit);\n            if (count >= listSize) {\n                for (int i = listSize; i <= count; i++) {\n                    list.add(null);\n                }\n            }\n        }\n\n        super.setProperty(context, target, name, realValue);\n    }\n\n    private Object getRealValue(Map context, Object value, Class convertToClass) {\n        if (value == null || convertToClass == null) {\n            return value;\n        }\n        return xworkConverter.convertValue(context, value, convertToClass);\n    }\n}\n",
        "compositeId": "com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor.setXWorkCollectionPropertyAccessor(PropertyAccessor) may expose internal representation by storing an externally mutable object into XWorkListPropertyAccessor._sAcc-com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
        "classSize": 152
    },
    {
        "explanation": "com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor.setXWorkConverter(XWorkConverter) may expose internal representation by storing an externally mutable object into XWorkListPropertyAccessor.xworkConverter",
        "fileName": "com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
        "methodStartLineNumber": 65,
        "methodEndLineNumber": 68,
        "warning_type": "EI_EXPOSE_REP2",
        "codeSnippet": "    public void setXWorkConverter(XWorkConverter conv) {\n        this.xworkConverter = conv;\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 195,
        "classCode": "public class XWorkListPropertyAccessor extends ListPropertyAccessor {\n\n    private XWorkCollectionPropertyAccessor _sAcc = new XWorkCollectionPropertyAccessor();\n    \n    private XWorkConverter xworkConverter;\n    private ObjectFactory objectFactory;\n    private ObjectTypeDeterminer objectTypeDeterminer;\n    private OgnlUtil ognlUtil;\n    private int autoGrowCollectionLimit = 255;\n\n    @Inject(value = StrutsConstants.STRUTS_OGNL_AUTO_GROWTH_COLLECTION_LIMIT, required = false)\n    public void setAutoGrowCollectionLimit(String value) {\n        this.autoGrowCollectionLimit = Integer.parseInt(value);\n    }\n\n    @Inject(\"java.util.Collection\")\n    public void setXWorkCollectionPropertyAccessor(PropertyAccessor acc) {\n        this._sAcc = (XWorkCollectionPropertyAccessor) acc;\n    }\n    \n    @Inject\n    public void setXWorkConverter(XWorkConverter conv) {\n        this.xworkConverter = conv;\n    }\n    \n    @Inject\n    public void setObjectFactory(ObjectFactory fac) {\n        this.objectFactory = fac;\n    }\n    \n    @Inject\n    public void setObjectTypeDeterminer(ObjectTypeDeterminer ot) {\n        this.objectTypeDeterminer = ot;\n    }\n    \n    @Inject\n    public void setOgnlUtil(OgnlUtil util) {\n        this.ognlUtil = util;\n    }\n\n    @Override\n    public Object getProperty(Map context, Object target, Object name) throws OgnlException {\n\n        if (ReflectionContextState.isGettingByKeyProperty(context)\n                || name.equals(XWorkCollectionPropertyAccessor.KEY_PROPERTY_FOR_CREATION)) {\n            return _sAcc.getProperty(context, target, name);\n        } else if (name instanceof String) {\n            return super.getProperty(context, target, name);\n        }\n        ReflectionContextState.updateCurrentPropertyPath(context, name);\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        \n        if (name instanceof Number\n                && ReflectionContextState.isCreatingNullObjects(context)\n                && objectTypeDeterminer.shouldCreateIfNew(lastClass,lastProperty,target,null,true)) {\n\n            List list = (List) target;\n            int index = ((Number) name).intValue();\n            int listSize = list.size();\n\n            if (lastClass == null || lastProperty == null) {\n                return super.getProperty(context, target, name);\n            }\n            Class beanClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n            if (listSize <= index) {\n                Object result;\n\n                if (index > autoGrowCollectionLimit) {\n                    throw new OgnlException(\"Error auto growing collection size to \" + index + \" which limited to \"\n                                            + autoGrowCollectionLimit);\n                }\n\n                for (int i = listSize; i < index; i++) {\n                    list.add(null);\n                }\n                try {\n                    list.add(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            } else if (list.get(index) == null) {\n                Object result;\n                try {\n                    list.set(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            }\n        }\n        return super.getProperty(context, target, name);\n    }\n\n    @Override\n    public void setProperty(Map context, Object target, Object name, Object value)\n            throws OgnlException {\n\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        Class convertToClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n\n        if (name instanceof String && value.getClass().isArray()) {\n            // looks like the input game in the form of \"someList.foo\" and\n            // we are expected to define the index values ourselves.\n            // So let's do it:\n\n            Collection c = (Collection) target;\n            Object[] values = (Object[]) value;\n            for (Object v : values) {\n                try {\n                    Object o = objectFactory.buildBean(convertToClass, context);\n                    ognlUtil.setValue((String) name, context, o, v);\n                    c.add(o);\n                } catch (Exception e) {\n                    throw new OgnlException(\"Error converting given String values for Collection.\", e);\n                }\n            }\n\n            // we don't want to do the normal list property setting now, since we've already done the work\n            // just return instead\n            return;\n        }\n\n        Object realValue = getRealValue(context, value, convertToClass);\n\n        if (target instanceof List && name instanceof Number) {\n            //make sure there are enough spaces in the List to set\n            List list = (List) target;\n            int listSize = list.size();\n            int count = ((Number) name).intValue();\n            if(count > autoGrowCollectionLimit)\n            \tthrow new OgnlException(\"Error auto growing collection size to \" + count + \" which limited to \"\n\t\t\t\t\t\t+ autoGrowCollectionLimit);\n            if (count >= listSize) {\n                for (int i = listSize; i <= count; i++) {\n                    list.add(null);\n                }\n            }\n        }\n\n        super.setProperty(context, target, name, realValue);\n    }\n\n    private Object getRealValue(Map context, Object value, Class convertToClass) {\n        if (value == null || convertToClass == null) {\n            return value;\n        }\n        return xworkConverter.convertValue(context, value, convertToClass);\n    }\n}\n",
        "compositeId": "com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor.setXWorkConverter(XWorkConverter) may expose internal representation by storing an externally mutable object into XWorkListPropertyAccessor.xworkConverter-com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
        "classSize": 152
    },
    {
        "explanation": "XWorkListPropertyAccessor.objectFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor.getProperty(Map, Object, Object)",
        "fileName": "com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
        "methodStartLineNumber": 86,
        "methodEndLineNumber": 137,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "\n        if (ReflectionContextState.isGettingByKeyProperty(context)\n                || name.equals(XWorkCollectionPropertyAccessor.KEY_PROPERTY_FOR_CREATION)) {\n            return _sAcc.getProperty(context, target, name);\n        } else if (name instanceof String) {\n            return super.getProperty(context, target, name);\n        }\n        ReflectionContextState.updateCurrentPropertyPath(context, name);\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        \n        if (name instanceof Number\n                && ReflectionContextState.isCreatingNullObjects(context)\n                && objectTypeDeterminer.shouldCreateIfNew(lastClass,lastProperty,target,null,true)) {\n\n            List list = (List) target;\n            int index = ((Number) name).intValue();\n            int listSize = list.size();\n\n            if (lastClass == null || lastProperty == null) {\n                return super.getProperty(context, target, name);\n            }\n            Class beanClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n            if (listSize <= index) {\n                Object result;\n\n                if (index > autoGrowCollectionLimit) {\n                    throw new OgnlException(\"Error auto growing collection size to \" + index + \" which limited to \"\n                                            + autoGrowCollectionLimit);\n                }\n\n                for (int i = listSize; i < index; i++) {\n                    list.add(null);\n                }\n                try {\n                    list.add(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            } else if (list.get(index) == null) {\n                Object result;\n                try {\n                    list.set(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            }\n        }\n        return super.getProperty(context, target, name);\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 195,
        "classCode": "public class XWorkListPropertyAccessor extends ListPropertyAccessor {\n\n    private XWorkCollectionPropertyAccessor _sAcc = new XWorkCollectionPropertyAccessor();\n    \n    private XWorkConverter xworkConverter;\n    private ObjectFactory objectFactory;\n    private ObjectTypeDeterminer objectTypeDeterminer;\n    private OgnlUtil ognlUtil;\n    private int autoGrowCollectionLimit = 255;\n\n    @Inject(value = StrutsConstants.STRUTS_OGNL_AUTO_GROWTH_COLLECTION_LIMIT, required = false)\n    public void setAutoGrowCollectionLimit(String value) {\n        this.autoGrowCollectionLimit = Integer.parseInt(value);\n    }\n\n    @Inject(\"java.util.Collection\")\n    public void setXWorkCollectionPropertyAccessor(PropertyAccessor acc) {\n        this._sAcc = (XWorkCollectionPropertyAccessor) acc;\n    }\n    \n    @Inject\n    public void setXWorkConverter(XWorkConverter conv) {\n        this.xworkConverter = conv;\n    }\n    \n    @Inject\n    public void setObjectFactory(ObjectFactory fac) {\n        this.objectFactory = fac;\n    }\n    \n    @Inject\n    public void setObjectTypeDeterminer(ObjectTypeDeterminer ot) {\n        this.objectTypeDeterminer = ot;\n    }\n    \n    @Inject\n    public void setOgnlUtil(OgnlUtil util) {\n        this.ognlUtil = util;\n    }\n\n    @Override\n    public Object getProperty(Map context, Object target, Object name) throws OgnlException {\n\n        if (ReflectionContextState.isGettingByKeyProperty(context)\n                || name.equals(XWorkCollectionPropertyAccessor.KEY_PROPERTY_FOR_CREATION)) {\n            return _sAcc.getProperty(context, target, name);\n        } else if (name instanceof String) {\n            return super.getProperty(context, target, name);\n        }\n        ReflectionContextState.updateCurrentPropertyPath(context, name);\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        \n        if (name instanceof Number\n                && ReflectionContextState.isCreatingNullObjects(context)\n                && objectTypeDeterminer.shouldCreateIfNew(lastClass,lastProperty,target,null,true)) {\n\n            List list = (List) target;\n            int index = ((Number) name).intValue();\n            int listSize = list.size();\n\n            if (lastClass == null || lastProperty == null) {\n                return super.getProperty(context, target, name);\n            }\n            Class beanClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n            if (listSize <= index) {\n                Object result;\n\n                if (index > autoGrowCollectionLimit) {\n                    throw new OgnlException(\"Error auto growing collection size to \" + index + \" which limited to \"\n                                            + autoGrowCollectionLimit);\n                }\n\n                for (int i = listSize; i < index; i++) {\n                    list.add(null);\n                }\n                try {\n                    list.add(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            } else if (list.get(index) == null) {\n                Object result;\n                try {\n                    list.set(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            }\n        }\n        return super.getProperty(context, target, name);\n    }\n\n    @Override\n    public void setProperty(Map context, Object target, Object name, Object value)\n            throws OgnlException {\n\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        Class convertToClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n\n        if (name instanceof String && value.getClass().isArray()) {\n            // looks like the input game in the form of \"someList.foo\" and\n            // we are expected to define the index values ourselves.\n            // So let's do it:\n\n            Collection c = (Collection) target;\n            Object[] values = (Object[]) value;\n            for (Object v : values) {\n                try {\n                    Object o = objectFactory.buildBean(convertToClass, context);\n                    ognlUtil.setValue((String) name, context, o, v);\n                    c.add(o);\n                } catch (Exception e) {\n                    throw new OgnlException(\"Error converting given String values for Collection.\", e);\n                }\n            }\n\n            // we don't want to do the normal list property setting now, since we've already done the work\n            // just return instead\n            return;\n        }\n\n        Object realValue = getRealValue(context, value, convertToClass);\n\n        if (target instanceof List && name instanceof Number) {\n            //make sure there are enough spaces in the List to set\n            List list = (List) target;\n            int listSize = list.size();\n            int count = ((Number) name).intValue();\n            if(count > autoGrowCollectionLimit)\n            \tthrow new OgnlException(\"Error auto growing collection size to \" + count + \" which limited to \"\n\t\t\t\t\t\t+ autoGrowCollectionLimit);\n            if (count >= listSize) {\n                for (int i = listSize; i <= count; i++) {\n                    list.add(null);\n                }\n            }\n        }\n\n        super.setProperty(context, target, name, realValue);\n    }\n\n    private Object getRealValue(Map context, Object value, Class convertToClass) {\n        if (value == null || convertToClass == null) {\n            return value;\n        }\n        return xworkConverter.convertValue(context, value, convertToClass);\n    }\n}\n",
        "compositeId": "XWorkListPropertyAccessor.objectFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor.getProperty(Map, Object, Object)-com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
        "classSize": 152
    },
    {
        "explanation": "XWorkListPropertyAccessor.objectFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor.setProperty(Map, Object, Object, Object)",
        "fileName": "com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
        "methodStartLineNumber": 142,
        "methodEndLineNumber": 188,
        "warning_type": "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR",
        "codeSnippet": "\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        Class convertToClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n\n        if (name instanceof String && value.getClass().isArray()) {\n            // looks like the input game in the form of \"someList.foo\" and\n            // we are expected to define the index values ourselves.\n            // So let's do it:\n\n            Collection c = (Collection) target;\n            Object[] values = (Object[]) value;\n            for (Object v : values) {\n                try {\n                    Object o = objectFactory.buildBean(convertToClass, context);\n                    ognlUtil.setValue((String) name, context, o, v);\n                    c.add(o);\n                } catch (Exception e) {\n                    throw new OgnlException(\"Error converting given String values for Collection.\", e);\n                }\n            }\n\n            // we don't want to do the normal list property setting now, since we've already done the work\n            // just return instead\n            return;\n        }\n\n        Object realValue = getRealValue(context, value, convertToClass);\n\n        if (target instanceof List && name instanceof Number) {\n            //make sure there are enough spaces in the List to set\n            List list = (List) target;\n            int listSize = list.size();\n            int count = ((Number) name).intValue();\n            if(count > autoGrowCollectionLimit)\n            \tthrow new OgnlException(\"Error auto growing collection size to \" + count + \" which limited to \"\n\t\t\t\t\t\t+ autoGrowCollectionLimit);\n            if (count >= listSize) {\n                for (int i = listSize; i <= count; i++) {\n                    list.add(null);\n                }\n            }\n        }\n\n        super.setProperty(context, target, name, realValue);\n    }\n",
        "classStartLineNumber": 44,
        "classEndLineNumber": 195,
        "classCode": "public class XWorkListPropertyAccessor extends ListPropertyAccessor {\n\n    private XWorkCollectionPropertyAccessor _sAcc = new XWorkCollectionPropertyAccessor();\n    \n    private XWorkConverter xworkConverter;\n    private ObjectFactory objectFactory;\n    private ObjectTypeDeterminer objectTypeDeterminer;\n    private OgnlUtil ognlUtil;\n    private int autoGrowCollectionLimit = 255;\n\n    @Inject(value = StrutsConstants.STRUTS_OGNL_AUTO_GROWTH_COLLECTION_LIMIT, required = false)\n    public void setAutoGrowCollectionLimit(String value) {\n        this.autoGrowCollectionLimit = Integer.parseInt(value);\n    }\n\n    @Inject(\"java.util.Collection\")\n    public void setXWorkCollectionPropertyAccessor(PropertyAccessor acc) {\n        this._sAcc = (XWorkCollectionPropertyAccessor) acc;\n    }\n    \n    @Inject\n    public void setXWorkConverter(XWorkConverter conv) {\n        this.xworkConverter = conv;\n    }\n    \n    @Inject\n    public void setObjectFactory(ObjectFactory fac) {\n        this.objectFactory = fac;\n    }\n    \n    @Inject\n    public void setObjectTypeDeterminer(ObjectTypeDeterminer ot) {\n        this.objectTypeDeterminer = ot;\n    }\n    \n    @Inject\n    public void setOgnlUtil(OgnlUtil util) {\n        this.ognlUtil = util;\n    }\n\n    @Override\n    public Object getProperty(Map context, Object target, Object name) throws OgnlException {\n\n        if (ReflectionContextState.isGettingByKeyProperty(context)\n                || name.equals(XWorkCollectionPropertyAccessor.KEY_PROPERTY_FOR_CREATION)) {\n            return _sAcc.getProperty(context, target, name);\n        } else if (name instanceof String) {\n            return super.getProperty(context, target, name);\n        }\n        ReflectionContextState.updateCurrentPropertyPath(context, name);\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        \n        if (name instanceof Number\n                && ReflectionContextState.isCreatingNullObjects(context)\n                && objectTypeDeterminer.shouldCreateIfNew(lastClass,lastProperty,target,null,true)) {\n\n            List list = (List) target;\n            int index = ((Number) name).intValue();\n            int listSize = list.size();\n\n            if (lastClass == null || lastProperty == null) {\n                return super.getProperty(context, target, name);\n            }\n            Class beanClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n            if (listSize <= index) {\n                Object result;\n\n                if (index > autoGrowCollectionLimit) {\n                    throw new OgnlException(\"Error auto growing collection size to \" + index + \" which limited to \"\n                                            + autoGrowCollectionLimit);\n                }\n\n                for (int i = listSize; i < index; i++) {\n                    list.add(null);\n                }\n                try {\n                    list.add(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            } else if (list.get(index) == null) {\n                Object result;\n                try {\n                    list.set(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            }\n        }\n        return super.getProperty(context, target, name);\n    }\n\n    @Override\n    public void setProperty(Map context, Object target, Object name, Object value)\n            throws OgnlException {\n\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        Class convertToClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n\n        if (name instanceof String && value.getClass().isArray()) {\n            // looks like the input game in the form of \"someList.foo\" and\n            // we are expected to define the index values ourselves.\n            // So let's do it:\n\n            Collection c = (Collection) target;\n            Object[] values = (Object[]) value;\n            for (Object v : values) {\n                try {\n                    Object o = objectFactory.buildBean(convertToClass, context);\n                    ognlUtil.setValue((String) name, context, o, v);\n                    c.add(o);\n                } catch (Exception e) {\n                    throw new OgnlException(\"Error converting given String values for Collection.\", e);\n                }\n            }\n\n            // we don't want to do the normal list property setting now, since we've already done the work\n            // just return instead\n            return;\n        }\n\n        Object realValue = getRealValue(context, value, convertToClass);\n\n        if (target instanceof List && name instanceof Number) {\n            //make sure there are enough spaces in the List to set\n            List list = (List) target;\n            int listSize = list.size();\n            int count = ((Number) name).intValue();\n            if(count > autoGrowCollectionLimit)\n            \tthrow new OgnlException(\"Error auto growing collection size to \" + count + \" which limited to \"\n\t\t\t\t\t\t+ autoGrowCollectionLimit);\n            if (count >= listSize) {\n                for (int i = listSize; i <= count; i++) {\n                    list.add(null);\n                }\n            }\n        }\n\n        super.setProperty(context, target, name, realValue);\n    }\n\n    private Object getRealValue(Map context, Object value, Class convertToClass) {\n        if (value == null || convertToClass == null) {\n            return value;\n        }\n        return xworkConverter.convertValue(context, value, convertToClass);\n    }\n}\n",
        "compositeId": "XWorkListPropertyAccessor.objectFactory not initialized in constructor and dereferenced in com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor.setProperty(Map, Object, Object, Object)-com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
        "classSize": 152,
        "status": "solved",
        "newClassCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.ognl.accessor;\n\nimport com.opensymphony.xwork2.ObjectFactory;\nimport com.opensymphony.xwork2.conversion.ObjectTypeDeterminer;\nimport com.opensymphony.xwork2.conversion.impl.XWorkConverter;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.ognl.OgnlUtil;\nimport com.opensymphony.xwork2.util.reflection.ReflectionContextState;\nimport ognl.ListPropertyAccessor;\nimport ognl.OgnlException;\nimport ognl.PropertyAccessor;\nimport org.apache.struts2.StrutsConstants;\nimport org.apache.struts2.StrutsException;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Overrides the list property accessor so in the case of trying\n * to add properties of a given bean and the JavaBean is not present,\n * this class will create the necessary blank JavaBeans.\n *\n * @author Gabriel Zimmerman\n */\npublic class XWorkListPropertyAccessor extends ListPropertyAccessor {\n\n    private XWorkCollectionPropertyAccessor _sAcc = new XWorkCollectionPropertyAccessor();\n    \n    private XWorkConverter xworkConverter;\n    private ObjectFactory objectFactory;\n    private ObjectTypeDeterminer objectTypeDeterminer;\n    private OgnlUtil ognlUtil;\n    private int autoGrowCollectionLimit = 255;\n\n    @Inject(value = StrutsConstants.STRUTS_OGNL_AUTO_GROWTH_COLLECTION_LIMIT, required = false)\n    public void setAutoGrowCollectionLimit(String value) {\n        this.autoGrowCollectionLimit = Integer.parseInt(value);\n    }\n\n    @Inject(\"java.util.Collection\")\n    public void setXWorkCollectionPropertyAccessor(PropertyAccessor acc) {\n        this._sAcc = (XWorkCollectionPropertyAccessor) acc;\n    }\n    \n    @Inject\n    public void setXWorkConverter(XWorkConverter conv) {\n        this.xworkConverter = conv;\n    }\n    \n    @Inject\n    public void setObjectFactory(ObjectFactory fac) {\n        this.objectFactory = fac;\n    }\n    \n    @Inject\n    public void setObjectTypeDeterminer(ObjectTypeDeterminer ot) {\n        this.objectTypeDeterminer = ot;\n    }\n    \n    @Inject\n    public void setOgnlUtil(OgnlUtil util) {\n        this.ognlUtil = util;\n    }\n\n    @Override\n    public Object getProperty(Map context, Object target, Object name) throws OgnlException {\n\n        if (ReflectionContextState.isGettingByKeyProperty(context)\n                || name.equals(XWorkCollectionPropertyAccessor.KEY_PROPERTY_FOR_CREATION)) {\n            return _sAcc.getProperty(context, target, name);\n        } else if (name instanceof String) {\n            return super.getProperty(context, target, name);\n        }\n        ReflectionContextState.updateCurrentPropertyPath(context, name);\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        \n        if (name instanceof Number\n                && ReflectionContextState.isCreatingNullObjects(context)\n                && objectTypeDeterminer.shouldCreateIfNew(lastClass,lastProperty,target,null,true)) {\n\n            List list = (List) target;\n            int index = ((Number) name).intValue();\n            int listSize = list.size();\n\n            if (lastClass == null || lastProperty == null) {\n                return super.getProperty(context, target, name);\n            }\n            Class beanClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n            if (listSize <= index) {\n                Object result;\n\n                if (index > autoGrowCollectionLimit) {\n                    throw new OgnlException(\"Error auto growing collection size to \" + index + \" which limited to \"\n                                            + autoGrowCollectionLimit);\n                }\n\n                for (int i = listSize; i < index; i++) {\n                    list.add(null);\n                }\n                try {\n                    list.add(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            } else if (list.get(index) == null) {\n                Object result;\n                try {\n                    list.set(index, result = objectFactory.buildBean(beanClass, context));\n                } catch (Exception exc) {\n                    throw new StrutsException(exc);\n                }\n                return result;\n            }\n        }\n        return super.getProperty(context, target, name);\n    }\n\n    @Override\n    public void setProperty(Map context, Object target, Object name, Object value)\n            throws OgnlException {\n\n        if (objectFactory == null) {\n            throw new OgnlException(\"ObjectFactory is not initialized.\");\n        }\n\n        Class lastClass = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n        String lastProperty = (String) context.get(XWorkConverter.LAST_BEAN_PROPERTY_ACCESSED);\n        Class convertToClass = objectTypeDeterminer.getElementClass(lastClass, lastProperty, name);\n\n        if (name instanceof String && value.getClass().isArray()) {\n            // looks like the input game in the form of \"someList.foo\" and\n            // we are expected to define the index values ourselves.\n            // So let's do it:\n\n            Collection c = (Collection) target;\n            Object[] values = (Object[]) value;\n            for (Object v : values) {\n                try {\n                    Object o = objectFactory.buildBean(convertToClass, context);\n                    ognlUtil.setValue((String) name, context, o, v);\n                    c.add(o);\n                } catch (Exception e) {\n                    throw new OgnlException(\"Error converting given String values for Collection.\", e);\n                }\n            }\n\n            // we don't want to do the normal list property setting now, since we've already done the work\n            // just return instead\n            return;\n        }\n\n        Object realValue = getRealValue(context, value, convertToClass);\n\n        if (target instanceof List && name instanceof Number) {\n            //make sure there are enough spaces in the List to set\n            List list = (List) target;\n            int listSize = list.size();\n            int count = ((Number) name).intValue();\n            if(count > autoGrowCollectionLimit)\n            \tthrow new OgnlException(\"Error auto growing collection size to \" + count + \" which limited to \"\n\t\t\t\t\t\t+ autoGrowCollectionLimit);\n            if (count >= listSize) {\n                for (int i = listSize; i <= count; i++) {\n                    list.add(null);\n                }\n            }\n        }\n\n        super.setProperty(context, target, name, realValue);\n    }\n\n    private Object getRealValue(Map context, Object value, Class convertToClass) {\n        if (value == null || convertToClass == null) {\n            return value;\n        }\n        return xworkConverter.convertValue(context, value, convertToClass);\n    }\n}\n"
    }
]